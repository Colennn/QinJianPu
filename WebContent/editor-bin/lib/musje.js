(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("snapsvg"), require("MIDI"));
	else if(typeof define === 'function' && define.amd)
		define(["snapsvg", "MIDI"], factory);
	else if(typeof exports === 'object')
		exports["musje"] = factory(require("snapsvg"), require("MIDI"));
	else
		root["musje"] = factory(root["Snap"], root["MIDI"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_42__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Score = exports.parse = undefined;
	
	var _parser = __webpack_require__(1);
	
	var _parser2 = _interopRequireDefault(_parser);
	
	var _Score = __webpack_require__(3);
	
	var _Score2 = _interopRequireDefault(_Score);
	
	var _Renderer = __webpack_require__(23);
	
	var _Renderer2 = _interopRequireDefault(_Renderer);
	
	var _util = __webpack_require__(2);
	
	var _PlayerMixin = __webpack_require__(41);
	
	var _PlayerMixin2 = _interopRequireDefault(_PlayerMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Render the score in jianpu (numbered musical notation).
	 * @member
	 * @function
	 * @param {string} svg
	 * @param {Object} lo - Layout options.
	 */
	_Score2.default.prototype.render = function (svg, lo) {
	  new _Renderer2.default(svg, lo).render(this);
	};
	
	(0, _util.defineProperties)(_Score2.default.prototype, _PlayerMixin2.default);
	
	/**
	 * Parse source musje string to be a Score instance.
	 * @param {string} input - Input of the musje source code.
	 * @return {Score} - A `Score` instance.
	 */
	var parse = exports.parse = function parse(input) {
	  return _parser2.default.parse(input);
	  // var plainScore = parser.parse(input);
	  // return new Score(plainScore);
	};
	
	exports.Score = _Score2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* parser generated by jison 0.4.17 */
	/*
	  Returns a Parser object of the following structure:
	
	  Parser: {
	    yy: {}
	  }
	
	  Parser.prototype: {
	    yy: {},
	    trace: function(),
	    symbols_: {associative list: name ==> number},
	    terminals_: {associative list: number ==> name},
	    productions_: [...],
	    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
	    table: [...],
	    defaultActions: {...},
	    parseError: function(str, hash),
	    parse: function(input),
	
	    lexer: {
	        EOF: 1,
	        parseError: function(str, hash),
	        setInput: function(input),
	        input: function(),
	        unput: function(str),
	        more: function(),
	        less: function(n),
	        pastInput: function(),
	        upcomingInput: function(),
	        showPosition: function(),
	        test_match: function(regex_match_array, rule_index),
	        next: function(),
	        lex: function(),
	        begin: function(condition),
	        popState: function(),
	        _currentRules: function(),
	        topState: function(),
	        pushState: function(condition),
	
	        options: {
	            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
	            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
	            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
	        },
	
	        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
	        rules: [...],
	        conditions: {associative list: name ==> set},
	    }
	  }
	
	
	  token location info (@$, _$, etc.): {
	    first_line: n,
	    last_line: n,
	    first_column: n,
	    last_column: n,
	    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
	  }
	
	
	  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
	    text:        (matched text)
	    token:       (the produced terminal token, if any)
	    line:        (yylineno)
	  }
	  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
	    loc:         (yylloc)
	    expected:    (string describing the set of expected tokens)
	    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
	  }
	*/
	var parser = (function(){
	var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,11],$V1=[1,15],$V2=[1,16],$V3=[1,17],$V4=[1,18],$V5=[1,19],$V6=[1,20],$V7=[1,23],$V8=[1,27],$V9=[1,34],$Va=[1,35],$Vb=[1,33],$Vc=[1,28],$Vd=[1,29],$Ve=[5,9,10,14,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vf=[2,8],$Vg=[5,9,10,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vh=[5,21,22,23,24,25,26],$Vi=[2,47],$Vj=[1,48],$Vk=[1,49],$Vl=[1,50],$Vm=[1,51],$Vn=[1,52],$Vo=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,48,51,53,58],$Vp=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,44,45,46,47,48,51,53,58],$Vq=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,44,45,46,47,48,50,51,53,58],$Vr=[1,63],$Vs=[1,64],$Vt=[5,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vu=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,48,51,53,58],$Vv=[5,9,10,21,22,23,24,25,26,28,29,34,39,41,48,51,53,58],$Vw=[39,41,50];
	var parser = {trace: function trace() { },
	yy: {},
	symbols_: {"0":29,"error":2,"e":3,"maybe_musje":4,"EOF":5,"space":6,"maybe_space":7,"musje":8,"S":9,"NL":10,"score_head":11,"part_list":12,"title":13,"TITLE":14,"COMPOSER":15,"part":16,"measure_list":17,"bar":18,"measure":19,"music_data":20,"|":21,"||":22,"|]":23,"|:":24,":|":25,":|:":26,"slurable":27,"TIE":28,"maybe_duration":30,"voice":31,"time_signature":32,"pitchful":33,"(":34,")":35,"note":36,"chord":37,"pitch":38,"STEP":39,"OCTAVE":40,"ACCIDENTAL":41,"type_modifier":42,"DOT":43,"_":44,"=":45,"HALF":46,"WHOLE":47,"<":48,"pitch_list":49,">":50,"{":51,"voice_list":52,"}":53,"voice_data_list":54,":":55,"voice_data":56,"restslurable_list":57,"BEATS":58,"BEAT_TYPE":59,"$accept":0,"$end":1},
	terminals_: {2:"error",5:"EOF",9:"S",10:"NL",14:"TITLE",15:"COMPOSER",21:"|",22:"||",23:"|]",24:"|:",25:":|",26:":|:",28:"TIE",29:"0",34:"(",35:")",39:"STEP",40:"OCTAVE",41:"ACCIDENTAL",43:"DOT",44:"_",45:"=",46:"HALF",47:"WHOLE",48:"<",50:">",51:"{",53:"}",54:"voice_data_list",55:":",57:"restslurable_list",58:"BEATS",59:"BEAT_TYPE"},
	productions_: [0,[3,2],[4,0],[4,2],[4,3],[4,1],[6,1],[6,1],[7,0],[7,2],[7,2],[8,1],[8,1],[8,2],[11,2],[13,1],[13,2],[12,1],[16,1],[16,3],[17,1],[17,4],[17,3],[19,2],[19,3],[18,1],[18,1],[18,1],[18,1],[18,1],[18,1],[20,1],[20,2],[20,2],[20,1],[20,1],[27,2],[27,3],[27,3],[27,4],[33,1],[33,1],[36,1],[38,1],[38,2],[38,2],[38,3],[30,0],[30,1],[30,1],[30,2],[42,1],[42,1],[42,2],[42,2],[42,3],[42,3],[42,1],[42,1],[37,3],[49,1],[49,2],[31,3],[52,1],[52,3],[56,1],[56,2],[32,2]],
	performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
	/* this == yyval */
	
	var $0 = $$.length - 1;
	switch (yystate) {
	case 1:
	 return $$[$0-1]; 
	break;
	case 2: case 3:
	 this.$ = null; 
	break;
	case 4: case 5:
	 this.$ = $$[$0]; removeLastEmptyMeasure($$[$0]); 
	break;
	case 10:
	 this.$ = $$[$0-1] ? $$[$0-1] + 1 : 1; 
	break;
	case 11:
	this.$ = { head: $$[$0] };
	break;
	case 12:
	this.$ = { parts: $$[$0] };
	break;
	case 13:
	this.$ = { head: $$[$0-1], parts: $$[$0] };
	break;
	case 15:
	 this.$ = { title: $$[$0] } 
	break;
	case 16:
	 this.$ =  { title: $$[$0-1], composer: $$[$0] } 
	break;
	case 17: case 60: case 63:
	this.$ = [$$[$0]];
	break;
	case 18:
	this.$ = { measures: $$[$0] };
	break;
	case 19:
	 this.$ = { measures: $$[$0]}; $$[$0][0].data.unshift({ bar: $$[$0-2] }); 
	break;
	case 20:
	 this.$ = [$$[$0]]; 
	break;
	case 21:
	 this.$ = $$[$0-3]; lastItem($$[$0-3]).data.push({ bar: $$[$0-2] }); $$[$0-3].push($$[$0]) 
	break;
	case 22:
	 this.$ = $$[$0-2]; lastItem($$[$0-2]).data.push({ bar: $$[$0-1] }); $$[$0-2].push({ data: [] }) 
	break;
	case 23:
	this.$ = { data: [$$[$0-1]] };
	break;
	case 24:
	 this.$ = $$[$0-2]; $$[$0-2].data.push($$[$0-1]) 
	break;
	case 25:
	this.$ = 'single';
	break;
	case 26:
	this.$ = 'double';
	break;
	case 27:
	this.$ = 'end';
	break;
	case 28:
	this.$ = 'repeat-begin';
	break;
	case 29:
	this.$ = 'repeat-end';
	break;
	case 30:
	this.$ = 'repeat-both';
	break;
	case 32:
	 this.$ = $$[$0-1]; onlyProperty($$[$0-1]).tie = '~' 
	break;
	case 33:
	this.$ = { rest: { duration: $$[$0] } };
	break;
	case 34:
	this.$ = { voice: $$[$0] };
	break;
	case 36:
	 this.$ = $$[$0-1]; onlyProperty($$[$0-1]).duration = $$[$0] 
	break;
	case 37:
	
	      this.$ = $$[$0-1];
	      extend(onlyProperty($$[$0-1]), {
	        duration: $$[$0],
	        slur: { begin: 'solid' }
	      })
	    
	break;
	case 38:
	
	      this.$ = $$[$0-2]
	      extend(onlyProperty($$[$0-2]), {
	        duration: $$[$0-1],
	        slur: { end: 'solid' }
	      })
	    
	break;
	case 39:
	
	      this.$ = $$[$0-2]
	      extend(onlyProperty($$[$0-2]), {
	        duration: $$[$0-1],
	        slur: { begin: 'solid', end: 'solid' }
	      })
	    
	break;
	case 40:
	this.$ = { note: $$[$0] };
	break;
	case 41:
	this.$ = { chord: $$[$0] };
	break;
	case 42:
	this.$ = { pitch: $$[$0] };
	break;
	case 43:
	this.$ = { step: +$$[$0] };
	break;
	case 44:
	this.$ = { step: +$$[$0-1], octave: octave($$[$0]) };
	break;
	case 45:
	this.$ = { accidental: $$[$0-1], step: +$$[$0] };
	break;
	case 46:
	this.$ = { accidental: $$[$0-2], step: +$$[$0-1], octave: octave($$[$0]) };
	break;
	case 48:
	this.$ = { type: $$[$0] };
	break;
	case 49:
	this.$ = { type: 4, dot: $$[$0].length };
	break;
	case 50:
	this.$ = { type: $$[$0-1], dot: $$[$0].length };
	break;
	case 51:
	this.$ = 8;
	break;
	case 52:
	this.$ = 16;
	break;
	case 53:
	this.$ = 32;
	break;
	case 54:
	this.$ = 64;
	break;
	case 55:
	this.$ = 128;
	break;
	case 56:
	this.$ = 256;
	break;
	case 57:
	this.$ = 2;
	break;
	case 58:
	this.$ = 1;
	break;
	case 59:
	this.$ = { pitches: $$[$0-1] };
	break;
	case 61: case 66:
	 this.$ = $$[$0-1]; $$[$0-1].push($$[$0]) 
	break;
	case 62:
	this.$ = $$[$0-1];
	break;
	case 64:
	 this.$ = $$[$0-2]; $$[$0-2].push($$[$0-1]) 
	break;
	case 67:
	this.$ = { time: { beats: +$$[$0-1], beatType: +$$[$0] } };
	break;
	}
	},
	table: [{3:1,4:2,5:[2,2],6:3,8:4,9:[1,5],10:[1,6],11:7,12:8,13:9,14:$V0,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{1:[3]},{5:[1,36]},o($Ve,$Vf,{7:37}),{5:[2,5]},o($Ve,[2,6]),o($Ve,[2,7]),{5:[2,11],12:38,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{5:[2,12]},o($Vg,$Vf,{7:39}),{5:[2,17]},o($Vg,[2,15],{15:[1,40]}),{5:[2,18],18:41,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},o([9,10,29,34,39,41,48,51,58],$Vf,{7:42}),o($Vh,[2,20],{27:22,31:24,32:25,33:26,36:30,37:31,38:32,20:43,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),o($Vg,[2,25]),o($Vg,[2,26]),o($Vg,[2,27]),o($Vg,[2,28]),o($Vg,[2,29]),o($Vg,[2,30]),o($Vg,$Vf,{7:44}),o($Vg,[2,31],{28:[1,45]}),o($Vg,$Vi,{30:46,42:47,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),o($Vg,[2,34]),o($Vg,[2,35]),o($Vo,$Vi,{42:47,30:53,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),{33:54,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb},{52:55,54:[1,56]},{59:[1,57]},o($Vp,[2,40]),o($Vp,[2,41]),o($Vp,[2,42]),{38:59,39:$V9,41:$Va,49:58},o($Vq,[2,43],{40:[1,60]}),{39:[1,61]},{1:[2,1]},{5:[2,3],8:62,9:$Vr,10:$Vs,11:7,12:8,13:9,14:$V0,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{5:[2,13]},o($Vt,[2,14],{9:$Vr,10:$Vs}),o($Vg,[2,16]),o($Vg,$Vf,{7:65}),{9:$Vr,10:$Vs,17:66,19:14,20:21,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},o($Vg,$Vf,{7:67}),o($Vt,[2,23],{9:$Vr,10:$Vs}),o($Vg,[2,32]),o($Vg,[2,33]),o($Vo,[2,48],{43:[1,68]}),o($Vo,[2,49]),o($Vu,[2,51]),o($Vu,[2,52],{44:[1,69],45:[1,70]}),o($Vu,[2,57]),o($Vu,[2,58]),o($Vv,[2,36],{35:[1,71]}),o($Vo,$Vi,{42:47,30:72,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),{53:[1,73]},{53:[2,63],55:[1,74]},o($Vg,[2,67]),{38:76,39:$V9,41:$Va,50:[1,75]},o($Vw,[2,60]),o($Vq,[2,44]),o($Vq,[2,45],{40:[1,77]}),{5:[2,4]},o($Ve,[2,9]),o($Ve,[2,10]),o($Vh,[2,22],{20:21,27:22,31:24,32:25,33:26,36:30,37:31,38:32,19:78,9:$Vr,10:$Vs,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),{5:[2,19],18:41,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},o($Vt,[2,24],{9:$Vr,10:$Vs}),o($Vo,[2,50]),o($Vu,[2,53]),o($Vu,[2,54],{44:[1,79],45:[1,80]}),o($Vv,[2,38]),o($Vv,[2,37],{35:[1,81]}),o($Vg,[2,62]),{27:83,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,56:82,57:[1,84]},o($Vp,[2,59]),o($Vw,[2,61]),o($Vq,[2,46]),o($Vh,[2,21],{27:22,31:24,32:25,33:26,36:30,37:31,38:32,20:43,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),o($Vu,[2,55]),o($Vu,[2,56]),o($Vv,[2,39]),{53:[2,64]},{53:[2,65]},{27:85,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb},{53:[2,66]}],
	defaultActions: {4:[2,5],8:[2,12],10:[2,17],36:[2,1],38:[2,13],62:[2,4],82:[2,64],83:[2,65],85:[2,66]},
	parseError: function parseError(str, hash) {
	    if (hash.recoverable) {
	        this.trace(str);
	    } else {
	        function _parseError (msg, hash) {
	            this.message = msg;
	            this.hash = hash;
	        }
	        _parseError.prototype = Error;
	
	        throw new _parseError(str, hash);
	    }
	},
	parse: function parse(input) {
	    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
	    var args = lstack.slice.call(arguments, 1);
	    var lexer = Object.create(this.lexer);
	    var sharedState = { yy: {} };
	    for (var k in this.yy) {
	        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
	            sharedState.yy[k] = this.yy[k];
	        }
	    }
	    lexer.setInput(input, sharedState.yy);
	    sharedState.yy.lexer = lexer;
	    sharedState.yy.parser = this;
	    if (typeof lexer.yylloc == 'undefined') {
	        lexer.yylloc = {};
	    }
	    var yyloc = lexer.yylloc;
	    lstack.push(yyloc);
	    var ranges = lexer.options && lexer.options.ranges;
	    if (typeof sharedState.yy.parseError === 'function') {
	        this.parseError = sharedState.yy.parseError;
	    } else {
	        this.parseError = Object.getPrototypeOf(this).parseError;
	    }
	    function popStack(n) {
	        stack.length = stack.length - 2 * n;
	        vstack.length = vstack.length - n;
	        lstack.length = lstack.length - n;
	    }
	    _token_stack:
	        var lex = function () {
	            var token;
	            token = lexer.lex() || EOF;
	            if (typeof token !== 'number') {
	                token = self.symbols_[token] || token;
	            }
	            return token;
	        };
	    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
	    while (true) {
	        state = stack[stack.length - 1];
	        if (this.defaultActions[state]) {
	            action = this.defaultActions[state];
	        } else {
	            if (symbol === null || typeof symbol == 'undefined') {
	                symbol = lex();
	            }
	            action = table[state] && table[state][symbol];
	        }
	                    if (typeof action === 'undefined' || !action.length || !action[0]) {
	                var errStr = '';
	                expected = [];
	                for (p in table[state]) {
	                    if (this.terminals_[p] && p > TERROR) {
	                        expected.push('\'' + this.terminals_[p] + '\'');
	                    }
	                }
	                if (lexer.showPosition) {
	                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
	                } else {
	                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
	                }
	                this.parseError(errStr, {
	                    text: lexer.match,
	                    token: this.terminals_[symbol] || symbol,
	                    line: lexer.yylineno,
	                    loc: yyloc,
	                    expected: expected
	                });
	            }
	        if (action[0] instanceof Array && action.length > 1) {
	            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
	        }
	        switch (action[0]) {
	        case 1:
	            stack.push(symbol);
	            vstack.push(lexer.yytext);
	            lstack.push(lexer.yylloc);
	            stack.push(action[1]);
	            symbol = null;
	            if (!preErrorSymbol) {
	                yyleng = lexer.yyleng;
	                yytext = lexer.yytext;
	                yylineno = lexer.yylineno;
	                yyloc = lexer.yylloc;
	                if (recovering > 0) {
	                    recovering--;
	                }
	            } else {
	                symbol = preErrorSymbol;
	                preErrorSymbol = null;
	            }
	            break;
	        case 2:
	            len = this.productions_[action[1]][1];
	            yyval.$ = vstack[vstack.length - len];
	            yyval._$ = {
	                first_line: lstack[lstack.length - (len || 1)].first_line,
	                last_line: lstack[lstack.length - 1].last_line,
	                first_column: lstack[lstack.length - (len || 1)].first_column,
	                last_column: lstack[lstack.length - 1].last_column
	            };
	            if (ranges) {
	                yyval._$.range = [
	                    lstack[lstack.length - (len || 1)].range[0],
	                    lstack[lstack.length - 1].range[1]
	                ];
	            }
	            r = this.performAction.apply(yyval, [
	                yytext,
	                yyleng,
	                yylineno,
	                sharedState.yy,
	                action[1],
	                vstack,
	                lstack
	            ].concat(args));
	            if (typeof r !== 'undefined') {
	                return r;
	            }
	            if (len) {
	                stack = stack.slice(0, -1 * len * 2);
	                vstack = vstack.slice(0, -1 * len);
	                lstack = lstack.slice(0, -1 * len);
	            }
	            stack.push(this.productions_[action[1]][0]);
	            vstack.push(yyval.$);
	            lstack.push(yyval._$);
	            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	            stack.push(newState);
	            break;
	        case 3:
	            return true;
	        }
	    }
	    return true;
	}};
	
	
	const extend = __webpack_require__(2).extend
	
	const lastItem = arr => arr[arr.length - 1]
	
	const onlyProperty = obj => obj[Object.keys(obj)[0]]
	
	const octave = str => {
	  const len = str.length
	  return str.charAt(0) === ',' ? -len : len
	}
	
	const removeLastEmptyMeasure = score => {
	  const parts = score.parts
	  if (!parts) return
	
	  parts.forEach(part => {
	    const lastMeasure = lastItem(part.measures)
	    if (lastMeasure.data.length === 0) part.measures.pop()
	  })
	}
	
	/* generated by jison-lex 0.3.4 */
	var lexer = (function(){
	var lexer = ({
	
	EOF:1,
	
	parseError:function parseError(str, hash) {
	        if (this.yy.parser) {
	            this.yy.parser.parseError(str, hash);
	        } else {
	            throw new Error(str);
	        }
	    },
	
	// resets the lexer, sets new input
	setInput:function (input, yy) {
	        this.yy = yy || this.yy || {};
	        this._input = input;
	        this._more = this._backtrack = this.done = false;
	        this.yylineno = this.yyleng = 0;
	        this.yytext = this.matched = this.match = '';
	        this.conditionStack = ['INITIAL'];
	        this.yylloc = {
	            first_line: 1,
	            first_column: 0,
	            last_line: 1,
	            last_column: 0
	        };
	        if (this.options.ranges) {
	            this.yylloc.range = [0,0];
	        }
	        this.offset = 0;
	        return this;
	    },
	
	// consumes and returns one char from the input
	input:function () {
	        var ch = this._input[0];
	        this.yytext += ch;
	        this.yyleng++;
	        this.offset++;
	        this.match += ch;
	        this.matched += ch;
	        var lines = ch.match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno++;
	            this.yylloc.last_line++;
	        } else {
	            this.yylloc.last_column++;
	        }
	        if (this.options.ranges) {
	            this.yylloc.range[1]++;
	        }
	
	        this._input = this._input.slice(1);
	        return ch;
	    },
	
	// unshifts one char (or a string) into the input
	unput:function (ch) {
	        var len = ch.length;
	        var lines = ch.split(/(?:\r\n?|\n)/g);
	
	        this._input = ch + this._input;
	        this.yytext = this.yytext.substr(0, this.yytext.length - len);
	        //this.yyleng -= len;
	        this.offset -= len;
	        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	        this.match = this.match.substr(0, this.match.length - 1);
	        this.matched = this.matched.substr(0, this.matched.length - 1);
	
	        if (lines.length - 1) {
	            this.yylineno -= lines.length - 1;
	        }
	        var r = this.yylloc.range;
	
	        this.yylloc = {
	            first_line: this.yylloc.first_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.first_column,
	            last_column: lines ?
	                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
	                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
	              this.yylloc.first_column - len
	        };
	
	        if (this.options.ranges) {
	            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	        }
	        this.yyleng = this.yytext.length;
	        return this;
	    },
	
	// When called from action, caches matched text and appends it on next action
	more:function () {
	        this._more = true;
	        return this;
	    },
	
	// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
	reject:function () {
	        if (this.options.backtrack_lexer) {
	            this._backtrack = true;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });
	
	        }
	        return this;
	    },
	
	// retain first n characters of the match
	less:function (n) {
	        this.unput(this.match.slice(n));
	    },
	
	// displays already matched input, i.e. for error messages
	pastInput:function () {
	        var past = this.matched.substr(0, this.matched.length - this.match.length);
	        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
	    },
	
	// displays upcoming input, i.e. for error messages
	upcomingInput:function () {
	        var next = this.match;
	        if (next.length < 20) {
	            next += this._input.substr(0, 20-next.length);
	        }
	        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	    },
	
	// displays the character position where the lexing error occurred, i.e. for error messages
	showPosition:function () {
	        var pre = this.pastInput();
	        var c = new Array(pre.length + 1).join("-");
	        return pre + this.upcomingInput() + "\n" + c + "^";
	    },
	
	// test the lexed token: return FALSE when not a match, otherwise return token
	test_match:function (match, indexed_rule) {
	        var token,
	            lines,
	            backup;
	
	        if (this.options.backtrack_lexer) {
	            // save context
	            backup = {
	                yylineno: this.yylineno,
	                yylloc: {
	                    first_line: this.yylloc.first_line,
	                    last_line: this.last_line,
	                    first_column: this.yylloc.first_column,
	                    last_column: this.yylloc.last_column
	                },
	                yytext: this.yytext,
	                match: this.match,
	                matches: this.matches,
	                matched: this.matched,
	                yyleng: this.yyleng,
	                offset: this.offset,
	                _more: this._more,
	                _input: this._input,
	                yy: this.yy,
	                conditionStack: this.conditionStack.slice(0),
	                done: this.done
	            };
	            if (this.options.ranges) {
	                backup.yylloc.range = this.yylloc.range.slice(0);
	            }
	        }
	
	        lines = match[0].match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno += lines.length;
	        }
	        this.yylloc = {
	            first_line: this.yylloc.last_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.last_column,
	            last_column: lines ?
	                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
	                         this.yylloc.last_column + match[0].length
	        };
	        this.yytext += match[0];
	        this.match += match[0];
	        this.matches = match;
	        this.yyleng = this.yytext.length;
	        if (this.options.ranges) {
	            this.yylloc.range = [this.offset, this.offset += this.yyleng];
	        }
	        this._more = false;
	        this._backtrack = false;
	        this._input = this._input.slice(match[0].length);
	        this.matched += match[0];
	        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
	        if (this.done && this._input) {
	            this.done = false;
	        }
	        if (token) {
	            return token;
	        } else if (this._backtrack) {
	            // recover context
	            for (var k in backup) {
	                this[k] = backup[k];
	            }
	            return false; // rule action called reject() implying the next rule should be tested instead.
	        }
	        return false;
	    },
	
	// return next match in input
	next:function () {
	        if (this.done) {
	            return this.EOF;
	        }
	        if (!this._input) {
	            this.done = true;
	        }
	
	        var token,
	            match,
	            tempMatch,
	            index;
	        if (!this._more) {
	            this.yytext = '';
	            this.match = '';
	        }
	        var rules = this._currentRules();
	        for (var i = 0; i < rules.length; i++) {
	            tempMatch = this._input.match(this.rules[rules[i]]);
	            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                match = tempMatch;
	                index = i;
	                if (this.options.backtrack_lexer) {
	                    token = this.test_match(tempMatch, rules[i]);
	                    if (token !== false) {
	                        return token;
	                    } else if (this._backtrack) {
	                        match = false;
	                        continue; // rule action called reject() implying a rule MISmatch.
	                    } else {
	                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	                        return false;
	                    }
	                } else if (!this.options.flex) {
	                    break;
	                }
	            }
	        }
	        if (match) {
	            token = this.test_match(match, rules[index]);
	            if (token !== false) {
	                return token;
	            }
	            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	            return false;
	        }
	        if (this._input === "") {
	            return this.EOF;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });
	        }
	    },
	
	// return next match that has a token
	lex:function lex() {
	        var r = this.next();
	        if (r) {
	            return r;
	        } else {
	            return this.lex();
	        }
	    },
	
	// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
	begin:function begin(condition) {
	        this.conditionStack.push(condition);
	    },
	
	// pop the previously active lexer condition state off the condition stack
	popState:function popState() {
	        var n = this.conditionStack.length - 1;
	        if (n > 0) {
	            return this.conditionStack.pop();
	        } else {
	            return this.conditionStack[0];
	        }
	    },
	
	// produce the lexer rule set which is active for the currently active lexer condition state
	_currentRules:function _currentRules() {
	        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
	            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	        } else {
	            return this.conditions["INITIAL"].rules;
	        }
	    },
	
	// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
	topState:function topState(n) {
	        n = this.conditionStack.length - 1 - Math.abs(n || 0);
	        if (n >= 0) {
	            return this.conditionStack[n];
	        } else {
	            return "INITIAL";
	        }
	    },
	
	// alias for begin(condition)
	pushState:function pushState(condition) {
	        this.begin(condition);
	    },
	
	// return the number of states currently on the stack
	stateStackSize:function stateStackSize() {
	        return this.conditionStack.length;
	    },
	options: {},
	performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
	var YYSTATE=YY_START;
	switch($avoiding_name_collisions) {
	case 0:return 9
	break;
	case 1:return 9
	break;
	case 2:return 9
	break;
	case 3: this.begin('title') 
	break;
	case 4: yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 2).trim()
	                          return 14 
	break;
	case 5: this.begin('INITIAL') 
	break;
	case 6: this.begin('INITIAL')
	                          yy_.yytext = yy_.yytext.trim()
	                          return 15 
	break;
	case 7: this.begin('time')
	                          yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 1)
	                          return 58 
	break;
	case 8: this.begin('INITIAL'); return 59 
	break;
	case 9:return 41
	break;
	case 10:return 39
	break;
	case 11:return 40
	break;
	case 12:return 43
	break;
	case 13:return 47
	break;
	case 14:return 46
	break;
	case 15:return 28
	break;
	case 16:return 44
	break;
	case 17:return 45
	break;
	case 18:return '.'
	break;
	case 19:return 29
	break;
	case 20:return 48
	break;
	case 21:return 50
	break;
	case 22:return 34
	break;
	case 23:return 35
	break;
	case 24:return '/'
	break;
	case 25:return '\\'
	break;
	case 26:return 23
	break;
	case 27:return 22
	break;
	case 28:return '[|'
	break;
	case 29:return 24
	break;
	case 30:return 26
	break;
	case 31:return 25
	break;
	case 32:return 21
	break;
	case 33:return 51
	break;
	case 34:return 53
	break;
	case 35:return 55
	break;
	case 36:return 10
	break;
	case 37:return 9
	break;
	case 38:return 5
	break;
	case 39:return 'INVALID'
	break;
	}
	},
	rules: [/^(?:\/\/[^\n]*)/,/^(?:\/\*([\s\S]*?)\*\/)/,/^(?:\/\*[\s\S]*)/,/^(?:<<)/,/^(?:.*>>)/,/^(?:([ \t])*([\n\r]))/,/^(?:.*)/,/^(?:(([1-9]\d{0,2})\/))/,/^(?:([1-9]\d{0,2})[^\d])/,/^(?:(#{1,2}|n|b{1,2}))/,/^(?:[1-7])/,/^(?:,+|'+)/,/^(?:\.+)/,/^(?:( *- *){3})/,/^(?:( *- *))/,/^(?: *~)/,/^(?:[_])/,/^(?:=)/,/^(?:\.)/,/^(?:[0])/,/^(?:<)/,/^(?:>)/,/^(?:\()/,/^(?:\))/,/^(?:\/)/,/^(?:\\)/,/^(?:\|\])/,/^(?:\|\|)/,/^(?:\[\|)/,/^(?:\|:)/,/^(?::\|:)/,/^(?::\|)/,/^(?:\|)/,/^(?:\{)/,/^(?:\})/,/^(?::)/,/^(?:([\n\r]))/,/^(?:([ \t]))/,/^(?:$)/,/^(?:.)/],
	conditions: {"time":{"rules":[8],"inclusive":false},"title":{"rules":[4,5,6],"inclusive":false},"INITIAL":{"rules":[0,1,2,3,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39],"inclusive":true}}
	});
	return lexer;
	})();
	parser.lexer = lexer;
	function Parser () {
	  this.yy = {};
	}
	Parser.prototype = parser;parser.Parser = Parser;
	return new Parser;
	})();
	module.exports = parser

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var IS_OBJECT = { 'funtion': true, 'object': true };
	var isObject = function isObject(obj) {
	  return IS_OBJECT[typeof obj === 'undefined' ? 'undefined' : _typeof(obj)] && !!obj;
	};
	
	var objEach = exports.objEach = function objEach(obj, callback) {
	  if (isObject(obj)) {
	    Object.keys(obj).forEach(function (key) {
	      callback(obj[key], key);
	    });
	  }
	};
	
	var extend = exports.extend = function extend(obj, ext) {
	  objEach(ext, function (val, key) {
	    obj[key] = val;
	  });
	  return obj;
	};
	
	var near = exports.near = function near(a, b) {
	  return Math.abs(a - b) < 0.00001;
	};
	
	var isAccessorProperty = function isAccessorProperty(value) {
	  return isObject(value) && (typeof value.get === 'function' || typeof value.set === 'function');
	};
	
	/**
	 * Define ES5 getter/setter properties
	 * @param {Object} obj - The object to be defined.
	 * @param {Object} props - ES5 getter/setter properties.
	 * For example:
	 * ```
	 * {
	 *   name: {
	 *     get: function () {...},
	 *     set: function () {...}
	 *   },
	 *   age: {
	 *      get:...
	 *   }
	 * }
	 * ```
	 */
	var defineProperties = exports.defineProperties = function defineProperties(obj, props) {
	  objEach(props, function (value, prop) {
	    var descriptor;
	    if (isAccessorProperty(value)) {
	      descriptor = value;
	    } else if (typeof value === 'function') {
	      descriptor = { value: value };
	    } else if (isObject(value) && value.constant) {
	      descriptor = { value: value.constant };
	    } else {
	      descriptor = {
	        value: value,
	        writable: true,
	        enumerable: true
	      };
	    }
	    Object.defineProperty(obj, prop, descriptor);
	  });
	};
	
	var toJSONWithDefault = true;
	
	var makeToJSON = exports.makeToJSON = function makeToJSON(values, elName) {
	  return function () {
	    var _this = this;
	
	    if (this.isEmpty) return;
	
	    var result = {};
	
	    objEach(values, function (defaultValue, prop) {
	      if (toJSONWithDefault || _this[prop] !== defaultValue) {
	        result[prop] = _this[prop];
	      }
	    });
	    if (!elName) return result;
	
	    var res = {};
	    res[elName] = result;
	    return res;
	  };
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _ScoreHead = __webpack_require__(4);
	
	var _ScoreHead2 = _interopRequireDefault(_ScoreHead);
	
	var _PartwiseParts = __webpack_require__(5);
	
	var _PartwiseParts2 = _interopRequireDefault(_PartwiseParts);
	
	var _TimewiseMeasures = __webpack_require__(21);
	
	var _TimewiseMeasures2 = _interopRequireDefault(_TimewiseMeasures);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @param {Object} score - plain score object.
	 * @mixes PlayerMixin
	 */
	
	var Score = function () {
	  function Score(score) {
	    _classCallCheck(this, Score);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      head: undefined,
	      parts: undefined
	    });
	
	    (0, _util.extend)(this, score);
	  }
	
	  /**
	   * Head of the score.
	   * @type {ScoreHead}
	   */
	
	
	  _createClass(Score, [{
	    key: 'walkCells',
	
	
	    /**
	     * A cell is identically a measure in a part or a part in a measure.
	     * @param {Function}
	     */
	    value: function walkCells(callback) {
	      this.parts.forEach(function (part, p) {
	        part.measures.forEach(function (cell, m) {
	          callback(cell, m, p);
	        });
	      });
	    }
	
	    /**
	     * Walk each music data.
	     * @param {Function} callback
	     */
	
	  }, {
	    key: 'walkMusicData',
	    value: function walkMusicData(callback) {
	      this.walkCells(function (cell, m, p) {
	        cell.data.forEach(function (data, d) {
	          callback(data, d, m, p);
	        });
	      });
	    }
	
	    /**
	     * Convert score to string.
	     * @return {string} Musje source code.
	     */
	
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return this.head + this.parts.map(function (part) {
	        return part.toString();
	      }).join('\n\n');
	    }
	
	    /**
	     * Custom toJSON method.
	     * @method
	     * @return {Object}
	     */
	
	  }, {
	    key: 'head',
	    get: function get() {
	      return this._head || (this._head = new _ScoreHead2.default());
	    },
	    set: function set(head) {
	      this._head = new _ScoreHead2.default(head);
	    }
	
	    /**
	     * Partwise parts.
	     * - (Getter)
	     * - (Setter)
	     * @type {PartwiseParts}
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this._parts || (this._parts = new _PartwiseParts2.default(this));
	    },
	    set: function set(parts) {
	      this.parts.removeAll();
	      this.parts.addParts(parts);
	      this.measures.fromPartwise();
	    }
	
	    /**
	     * Timewise measures, generated by the initialize function.
	     * @type {TimewiseMeasures}
	     * @readonly
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures || (this._measures = new _TimewiseMeasures2.default(this));
	    }
	  }]);
	
	  return Score;
	}();
	
	exports.default = Score;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Construct head of the score.
	 * @class
	 * @param {Object} head
	 */
	
	var ScoreHead = function () {
	  function ScoreHead(head) {
	    _classCallCheck(this, ScoreHead);
	
	    this.title = '';
	    this.subtitle = '';
	    this.subsubtitle = '';
	    this.composer = undefined;
	    this.arranger = undefined;
	    this.lyricist = undefined;
	    this.toJSON = (0, _util.makeToJSON)({
	      title: undefined,
	      subtitle: undefined,
	      subsubtitle: undefined,
	      composer: undefined,
	      lyricist: undefined
	    });
	
	    (0, _util.extend)(this, head);
	  }
	
	  /**
	   * Title of the score.
	   * @type {string}
	   * @default ''
	   */
	
	
	  /**
	   * Subtitle of the score.
	   * @type {string}
	   * @default ''
	   */
	
	
	  /**
	   * Subsubtitle of the score.
	   * @type {string}
	   * @default ''
	   */
	
	
	  /**
	   * Composer of the score.
	   * @type {string}
	   */
	
	
	  /**
	   * Arranger of the score.
	   * @type {string}
	   */
	
	
	  /**
	   * Lyricist of the score.
	   * @type {string}
	   */
	
	
	  _createClass(ScoreHead, [{
	    key: 'toString',
	
	
	    /**
	     * Convert score head to string.
	     * @return {string} The converted musje head source code.
	     */
	    value: function toString() {
	      var title = this.title ? '<<' + this.title + '>>' : '';
	      return title + ' ' + (this.composer || '') + '\n';
	    }
	  }, {
	    key: 'isEmpty',
	
	
	    /**
	     * Check if the score head is empty.
	     * @type {boolean}
	     * @readonly
	     */
	    get: function get() {
	      return !this.title && !this.subtitle && !this.subsubtitle && !this.composer && !this.arranger && !this.lyricist;
	    }
	  }]);
	
	  return ScoreHead;
	}();
	
	exports.default = ScoreHead;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _PartwisePart = __webpack_require__(6);
	
	var _PartwisePart2 = _interopRequireDefault(_PartwisePart);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _extendableBuiltin(cls) {
	  function ExtendableBuiltin() {
	    cls.apply(this, arguments);
	  }
	
	  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
	    constructor: {
	      value: cls,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	
	  if (Object.setPrototypeOf) {
	    Object.setPrototypeOf(ExtendableBuiltin, cls);
	  } else {
	    ExtendableBuiltin.__proto__ = cls;
	  }
	
	  return ExtendableBuiltin;
	}
	
	var PartwiseParts = function (_extendableBuiltin2) {
	  _inherits(PartwiseParts, _extendableBuiltin2);
	
	  function PartwiseParts(score) {
	    _classCallCheck(this, PartwiseParts);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PartwiseParts).call(this));
	
	    _this._score = score;
	    return _this;
	  }
	
	  /**
	   * Reference to the parent score.
	   * @type {Score}
	   * @readonly
	   */
	
	
	  _createClass(PartwiseParts, [{
	    key: 'addParts',
	
	
	    /**
	     * Add parts.
	     * @param {Object}
	     */
	    value: function addParts(parts) {
	      var _this2 = this;
	
	      parts.forEach(function (part) {
	        _this2.append(part);
	      });
	    }
	
	    /**
	     * Append a partwise part.
	     * @param {Object} part - Plain partwise part object.
	     * @override
	     */
	
	  }, {
	    key: 'append',
	    value: function append(part) {
	      var index = this.length;
	      var musjePart = new _PartwisePart2.default(index, this);
	      this.push(musjePart);
	      musjePart.measures = part.measures;
	    }
	
	    /**
	     * Remove all parts.
	     */
	
	  }, {
	    key: 'removeAll',
	    value: function removeAll() {
	      this.length = 0;
	    }
	  }, {
	    key: 'score',
	    get: function get() {
	      return this._score;
	    }
	  }]);
	
	  return PartwiseParts;
	}(_extendableBuiltin(Array));
	
	exports.default = PartwiseParts;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _Cell = __webpack_require__(7);
	
	var _Cell2 = _interopRequireDefault(_Cell);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param part {Object}
	 * @param index {number} - Index of this part in the parts.
	 * @param parts {PartwiseParts}
	 */
	
	var PartwisePart = function () {
	  function PartwisePart(index, parts) {
	    _classCallCheck(this, PartwisePart);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      measures: undefined
	    });
	
	    this._index = index;
	    this._parts = parts;
	  }
	
	  // head: { $ref: '#/objects/PartHead' },
	
	  /**
	   * Reference to the parent parts instance.
	   * @type {PartwiseParts}
	   * @readonly
	   */
	
	
	  _createClass(PartwisePart, [{
	    key: 'toString',
	
	
	    /**
	     * Convert a partwise part to sting.
	     * @return {string} Musje partwise part source code.
	     */
	    value: function toString() {
	      return this.measures.map(function (cell) {
	        return cell;
	      }).join(' ');
	    }
	
	    /**
	     * Custom toJSON method.
	     * @return {Object}
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this._parts;
	    }
	
	    /**
	     * Measure in a partwise part is cells.
	     * @type {Array.<Cell>}
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures || (this._measures = []);
	    },
	    set: function set(measures) {
	      var p = this._index;
	      var score = this.parts.score;
	
	      var mea = this._measures = [];
	      measures.forEach(function (cell, m) {
	        mea.push(new _Cell2.default(cell, m, p, score));
	      });
	    }
	  }]);
	
	  return PartwisePart;
	}();
	
	exports.default = PartwisePart;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _Time = __webpack_require__(9);
	
	var _Time2 = _interopRequireDefault(_Time);
	
	var _Bar = __webpack_require__(11);
	
	var _Bar2 = _interopRequireDefault(_Bar);
	
	var _Note = __webpack_require__(12);
	
	var _Note2 = _interopRequireDefault(_Note);
	
	var _Rest = __webpack_require__(17);
	
	var _Rest2 = _interopRequireDefault(_Rest);
	
	var _Chord = __webpack_require__(18);
	
	var _Chord2 = _interopRequireDefault(_Chord);
	
	var _Voice = __webpack_require__(19);
	
	var _Voice2 = _interopRequireDefault(_Voice);
	
	var _Beam = __webpack_require__(20);
	
	var _Beam2 = _interopRequireDefault(_Beam);
	
	var _util = __webpack_require__(2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Classes = { time: _Time2.default, bar: _Bar2.default, note: _Note2.default, rest: _Rest2.default, chord: _Chord2.default, voice: _Voice2.default };
	var Bar = _Bar2.default;
	
	/**
	 * Cell is either a measure in a partwise part, or
	 * a part in a timewise measure.
	 * @param cell {Object}
	 * @param mIndex {number} - Measure index of this cell.
	 * @param pIndex {number} - Part index of this cell.
	 */
	
	var Cell = function () {
	  function Cell(cell, mIndex, pIndex, score) {
	    _classCallCheck(this, Cell);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      data: undefined
	    });
	
	    this._mIndex = mIndex;
	    this._pIndex = pIndex;
	    this._score = score;
	    (0, _util.extend)(this, cell);
	    makeBeams(this, 1);
	  }
	
	  /**
	   * Reference to the root score instance.
	   * @type {Score}
	   * @readonly
	   */
	
	
	  _createClass(Cell, [{
	    key: 'append',
	
	
	    /**
	     * Append a music data to the cell.
	     * @param  {Object} musicData - Music data
	     */
	    value: function append(musicData) {
	      var type = Object.keys(musicData)[0]; // musicData has only one key
	      var instance = new Classes[type](musicData[type]);
	      instance._cell = this;
	      instance._index = this.data.length;
	      this.data.push(instance);
	    }
	
	    /**
	     * Width
	     * - (Getter) Get the cell width.
	     * - (Setter) Set the cell width, and this will cause the cell to reflow.
	     * @type {number}
	     */
	
	  }, {
	    key: 'flow',
	
	
	    /**
	     * Flow the cell.
	     */
	    value: function flow() {
	      var _layout = this.layout;
	      var defs = _layout.defs;
	      var options = _layout.options;
	      var musicDataSep = options.musicDataSep;
	
	      var x = 0;
	      var minHeight = void 0;
	
	      this.data.forEach(function (data) {
	        var def = data.def = defs.get(data);
	        data.x = x;
	        data.y = 0;
	        x += def.width + musicDataSep;
	        minHeight = Math.min(minHeight, def.height);
	      });
	
	      this.minWidth = x;
	      this.minHeight = minHeight;
	    }
	
	    /**
	     * Draw box of the cell.
	     * @return {Element} The box SVG rect element.
	     */
	
	  }, {
	    key: 'drawBox',
	    value: function drawBox() {
	      this._boxEl = this.el.rect(0, -this.height, this.width, this.height).addClass('bbox');
	      return this._boxEl;
	    }
	
	    /**
	     * Clear the box SVG element.
	     */
	
	  }, {
	    key: 'clearBox',
	    value: function clearBox() {
	      this._boxEl.remove();
	      this._boxEl = undefined;
	    }
	
	    /**
	     * Convert cell to string.
	     * @return {string} Converted cell in musje source code.
	     */
	
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return this.data.map(function (musicData) {
	        return musicData.toString();
	      }).join(' ');
	    }
	  }, {
	    key: 'score',
	    get: function get() {
	      return this._score;
	    }
	
	    /**
	     * Music data
	     * @type {Array.<MusicDataMixin>}
	     */
	
	  }, {
	    key: 'data',
	    get: function get() {
	      return this._data || (this._data = []);
	    },
	    set: function set(data) {
	      var _this = this;
	
	      this.length = 0;
	      data.forEach(function (datum) {
	        _this.append(datum);
	      });
	    }
	
	    /**
	     * Reference to the parent measures.
	     * @type {TimewiseMeasures}
	     * @readonly
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this.score.measures;
	    }
	
	    /**
	     * Reference to the parent measure.
	     * @type {TimewiseMeasure}
	     * @readonly
	     */
	
	  }, {
	    key: 'measure',
	    get: function get() {
	      return this.measures[this._mIndex];
	    }
	
	    /**
	     * Reference to the parent parts.
	     * @type {PartwiseParts}
	     * @readonly
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this.score.parts;
	    }
	
	    /**
	     * Reference to the parent part.
	     * @type {PartwisePart}
	     * @readonly
	     */
	
	  }, {
	    key: 'part',
	    get: function get() {
	      return this.parts[this._pIndex];
	    }
	
	    /**
	     * Previous cell in the part.
	     * @type {Cell|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prev',
	    get: function get() {
	      return this.part.measures[this._mIndex - 1];
	    }
	
	    /**
	     * Next cell in the part.
	     * @type {Cell|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'next',
	    get: function get() {
	      return this.part.measures[this._mIndex + 1];
	    }
	
	    /**
	     * The first music data in the cell.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'firstData',
	    get: function get() {
	      return this.data[0];
	    }
	
	    /**
	     * The last music data in the cell.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'lastData',
	    get: function get() {
	      return this.data[this.data.length - 1];
	    }
	
	    /**
	     * The left bar of this cell.
	     * @type {Bar|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeft',
	    get: function get() {
	      var firstData = this.firstData;
	
	      if (firstData && firstData.$type === 'bar') return firstData;
	
	      // Take from the previous measure.
	      var prevCell = this.prev;
	      if (prevCell) return prevCell.barRight;
	    }
	
	    /**
	     * The right bar of this cell.
	     * @type {Bar|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRight',
	    get: function get() {
	      var lastData = this.lastData;
	
	      if (lastData && lastData.$type === 'bar') return lastData;
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	      reflow(this);
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      return this.layout.options.partHeight;
	    }
	
	    /**
	     * The x position of the cell in parent timewise measure.
	     * - Set the x value will cause the cell element translate.
	     * @type {number}
	     */
	
	  }, {
	    key: 'x',
	    get: function get() {
	      return this._x;
	    },
	    set: function set(x) {
	      this._x = x;
	      this.el.transform((0, _snapsvg.matrix)().translate(x, this.y2));
	    }
	
	    /**
	     * The y2 position of the cell in parent timewise measure.
	     * - Set the y2 value will cause the cell element translate.
	     * @type {number}
	     */
	
	  }, {
	    key: 'y2',
	    get: function get() {
	      var _layout$options = this.layout.options;
	      var partHeight = _layout$options.partHeight;
	      var partSep = _layout$options.partSep;
	
	      var p = this._pIndex;
	
	      return p ? (p + 1) * partHeight + p * partSep : partHeight;
	    }
	
	    /**
	     * The left bar of this cell.
	     * - barLeft at first measure of a system:
	     * ```
	     * |]  -> |
	     * :|  -> |
	     * :|: -> |:
	     * ```
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeftInSystem',
	    get: function get() {
	      var bar = this.barLeft;
	      if (!bar) return { width: 0, height: 0 };
	
	      // First measure in the system.
	      if (this.measure.inSystemBegin) {
	        if (bar.value === 'end' || bar.value === 'repeat-end') {
	          bar = new Bar('single');
	        } else if (bar.value === 'repeat-both') {
	          bar = new Bar('repeat-begin');
	        }
	      }
	      bar.def = this.layout.defs.get(bar);
	      return bar;
	    }
	
	    /**
	     * The right bar of this cell.
	     * - barRight at last measure of a system:
	     * ```
	     *  |: ->  |
	     * :|: -> :|
	     * ```
	     * @type {musje.Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRightInSystem',
	    get: function get() {
	      var system = this.measure.system;
	
	      var bar = this.barRight;
	
	      if (!bar) return { width: 0, height: 0 };
	
	      // Last measure in the system.
	      if (system && this.measure.inSystemEnd) {
	        if (bar.value === 'repeat-begin') {
	          bar = new Bar('single');
	        } else if (bar.value === 'repeat-both') {
	          bar = new Bar('repeat-end');
	        }
	      }
	      bar.def = this.layout.defs.get(bar);
	      return bar;
	    }
	  }]);
	
	  return Cell;
	}();
	
	// Reflow the cell.
	
	
	function reflow(that) {
	  that.data.forEach(function (data) {
	    data.x *= that.width / that.minWidth;
	  });
	}
	
	/**
	 * Make beams automatically in group by the groupDur.
	 * @param {number} groupDur - Duration of a beam group in quarter.
	 */
	function makeBeams(that, groupDur) {
	
	  getBeamGroups(that, groupDur).forEach(function (group) {
	    var beamLevel = {}; // it starts from 0, while underbar starts from 1
	
	    var nextHasSameBeamlevel = function nextHasSameBeamlevel(index, level) {
	      var next = group[index + 1];
	      return next && next.duration.underbar > level;
	    };
	
	    group.forEach(function (data, i) {
	      var underbar = data.duration.underbar;
	
	
	      for (var level = 0; level < underbar; level++) {
	        if (nextHasSameBeamlevel(i, level)) {
	
	          /**
	           * Beams of the note.
	           * - Produced by the {@link Cell#makeBeams} method.
	           * - The above method is call in {@link Score#prepareCells}.
	           * @memberof Note#
	           * @alias beams
	           * @type {Array.<Beam>}
	           */
	          data.beams = data.beams || [];
	
	          if (beamLevel[level]) {
	            data.beams[level] = new _Beam2.default('continue', level, data);
	          } else {
	            beamLevel[level] = true;
	            data.beams[level] = new _Beam2.default('begin', level, data);
	          }
	        } else {
	          if (beamLevel[level]) {
	            data.beams = data.beams || [];
	            data.beams[level] = new _Beam2.default('end', level, data);
	            delete beamLevel[level];
	          }
	        }
	      }
	    });
	  });
	}
	
	function getBeamGroups(that, groupDur) {
	  var groups = [];
	  var group = [];
	  var counter = 0;
	
	  var inGroup = function inGroup() {
	    return counter < groupDur && !(0, _util.near)(counter, groupDur);
	  };
	  var putGroup = function putGroup() {
	    if (group.length > 1) groups.push(group);
	    group = [];
	  };
	
	  that.data.forEach(function (musicData) {
	    if (musicData.$type !== 'note' && musicData.$type !== 'rest') return;
	
	    var duration = musicData.duration;
	
	    var dur = duration.quarter;
	
	    counter += dur;
	
	    if (inGroup()) {
	      if (duration.underbar) group.push(musicData);
	    } else if ((0, _util.near)(counter, groupDur)) {
	      group.push(musicData);
	      putGroup();
	      counter = 0;
	    } else {
	      putGroup();
	      counter %= groupDur;
	    }
	  });
	
	  putGroup();
	
	  return groups;
	}
	
	exports.default = Cell;

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Time signature.
	 * @class
	 * @param time {Object}
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	
	var Time = function (_MusicData) {
	  _inherits(Time, _MusicData);
	
	  function Time(time) {
	    _classCallCheck(this, Time);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Time).call(this));
	
	    _this.$type = 'time';
	    _this.beats = 4;
	    _this.beatType = 4;
	    _this.toJSON = (0, _util.makeToJSON)({
	      beats: 4,
	      beatType: 4
	    }, 'time');
	
	    (0, _util.extend)(_this, time);
	    return _this;
	  }
	
	  /**
	   * Type of time.
	   * @constant
	   * @default time
	   */
	
	
	  /**
	   * How many beats per measure.
	   * @type {number}
	   * @default
	   */
	
	
	  /**
	   * Beat type
	   * @type {number}
	   * @default
	   */
	
	
	  _createClass(Time, [{
	    key: 'toString',
	
	
	    /**
	     * Convert to musje source code.
	     * @return {string} Musje source code.
	     */
	    value: function toString() {
	      return this.beats + '/' + this.beatType;
	    }
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * id := 't' beats '-' beatType
	     * ```
	     * E.g. `t3-4`
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      return 't' + this.beats + '-' + this.beatType;
	    }
	  }]);
	
	  return Time;
	}(_MusicData3.default);
	
	exports.default = Time;

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var MusicData = function () {
	  function MusicData() {
	    _classCallCheck(this, MusicData);
	  }
	
	  _createClass(MusicData, [{
	    key: 'cell',
	
	
	    /**
	     * Reference to the parent cell.
	     * @type {Cell}
	     */
	    get: function get() {
	      return this._cell;
	    }
	
	    /**
	     * The ascendant system of the music data.
	     * @type {SystemLayout}
	     * @readonly
	     */
	
	  }, {
	    key: 'system',
	    get: function get() {
	      return this.cell.measure.system;
	    }
	
	    /**
	     * Previous music data.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prev',
	    get: function get() {
	      return this.cell.data[this._index - 1];
	    }
	
	    /**
	     * Next music data.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'next',
	    get: function get() {
	      return this.cell.data[this._index + 1];
	    }
	
	    /**
	     * Previous music data in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevInPart',
	    get: function get() {
	      var prev = this.prev;
	      var cell = this.cell;
	
	      while (!prev && cell.prev) {
	        if (!prev) {
	          cell = cell.prev;
	          prev = cell.lastData;
	        }
	      }
	      return prev;
	    }
	
	    /**
	     * Next music data in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextInPart',
	    get: function get() {
	      var next = this.next;
	      var cell = this.cell;
	
	      while (!next && cell.next) {
	        if (!next) {
	          cell = cell.next;
	          next = cell.firstData;
	        }
	      }
	      return next;
	    }
	
	    /**
	     * Previous music data which has a duration.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevDurable',
	    get: function get() {
	      var prev = this.prev;
	
	      while (prev && !prev.duration) {
	        prev = prev.prev;
	      }return prev;
	    }
	
	    /**
	     * Next music data which has a duration.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextDurable',
	    get: function get() {
	      var next = this.next;
	
	      while (next && !next.duration) {
	        next = next.next;
	      }return next;
	    }
	
	    /**
	     * Previous music data which has a duration in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevDurableInPart',
	    get: function get() {
	      var prev = this.prevInPart;
	      while (prev && !prev.duration) {
	        prev = prev.prevInPart;
	      }return prev;
	    }
	
	    /**
	     * Next music data which has a duration in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextDurableInPart',
	    get: function get() {
	      var next = this.nextInPart;
	      while (next && !next.duration) {
	        next = next.nextInPart;
	      }return next;
	    }
	
	    /**
	     * The x position of the music data in the cell.
	     * @type {number}
	     */
	
	  }, {
	    key: 'x',
	    get: function get() {
	      return this._x;
	    },
	    set: function set(x) {
	      this._x = x;
	      if (this.el) this.el.attr('x', x);
	    }
	
	    /**
	     * The y position of the music data in the cell.
	     * @type {number}
	     */
	
	  }, {
	    key: 'y',
	    get: function get() {
	      return this._y;
	    },
	    set: function set(y) {
	      this._y = y;
	      if (this.el) this.el.attr('y', y);
	    }
	
	    /**
	     * The x position of the music data in the system.
	     * @type {number}
	     */
	
	  }, {
	    key: 'systemX',
	    get: function get() {
	      return this.x + this.cell.x + this.cell.measure.x;
	    }
	
	    /**
	     * The width of the music data.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this.def.width;
	    }
	  }]);
	
	  return MusicData;
	}();
	
	exports.default = MusicData;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var BAR_TO_STRING = {
	  single: '|', double: '||', end: '|]',
	  'repeat-begin': '|:', 'repeat-end': ':|', 'repeat-both': ':|:'
	};
	var BAR_TO_ID = {
	  single: 'bs', double: 'bd', end: 'be',
	  'repeat-begin': 'brb', 'repeat-end': 'bre', 'repeat-both': 'brbe'
	};
	
	/**
	 * @param {string} bar - The bar value, which can be either of
	 * - 'single' - `|`
	 * - 'double' - `||`
	 * - 'end' - `|]`
	 * - 'repeat-begin' - `|:`
	 * - 'repeat-end' - `:|`
	 * - 'repeat-both' - `:|:`
	 */
	
	var Bar = function (_MusicData) {
	  _inherits(Bar, _MusicData);
	
	  function Bar(bar) {
	    _classCallCheck(this, Bar);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Bar).call(this));
	
	    _this.$type = 'bar';
	
	    _this._value = bar;
	    return _this;
	  }
	
	  /**
	   * Type of bar.
	   * @constant
	   * @readonly
	   * @default bar
	   */
	
	
	  _createClass(Bar, [{
	    key: 'toString',
	
	
	    /**
	     * Convert bar to string.
	     * @return {string} Converted string of the barline in musje source code.
	     */
	    value: function toString() {
	      return BAR_TO_STRING[this.value];
	    }
	
	    /**
	     * [toJSON description]
	     * @return {Object} { bar: value }
	     */
	
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return { bar: this.value };
	    }
	  }, {
	    key: 'value',
	
	
	    /**
	     * Value of the bar, which is the same as the bar parameter in the constructor.
	     * @type {string}
	     * @default single
	     * @readonly
	     */
	    get: function get() {
	      return this._value || (this._value = 'single');
	    }
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * defId    Bar value
	     * ----------------------
	     * 'bs'   - single
	     * 'bd'   - double
	     * 'be'   - repeat-end
	     * 'brb'  - repeat-begin
	     * 'bre'  - repeat-end
	     * 'brbe' - repeat-both
	     * ```
	     * @type {string}
	     * @readonly
	     */
	
	  }, {
	    key: 'defId',
	    get: function get() {
	      return BAR_TO_ID[this.value];
	    }
	  }]);
	
	  return Bar;
	}(_MusicData3.default);
	
	exports.default = Bar;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	var _Pitch = __webpack_require__(13);
	
	var _Pitch2 = _interopRequireDefault(_Pitch);
	
	var _Duration = __webpack_require__(14);
	
	var _Duration2 = _interopRequireDefault(_Duration);
	
	var _Tie = __webpack_require__(15);
	
	var _Tie2 = _interopRequireDefault(_Tie);
	
	var _Slur = __webpack_require__(16);
	
	var _Slur2 = _interopRequireDefault(_Slur);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {Object} note
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	
	var Note = function (_MusicData) {
	  _inherits(Note, _MusicData);
	
	  function Note(note) {
	    _classCallCheck(this, Note);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Note).call(this));
	
	    _this.$type = 'note';
	    _this.toJSON = (0, _util.makeToJSON)({
	      pitch: undefined,
	      duration: undefined,
	      tie: undefined,
	      slur: undefined
	    }, 'note');
	
	    (0, _util.extend)(_this, note);
	    return _this;
	  }
	
	  /**
	   * Type of note.
	   * @constant
	   * @default note
	   */
	
	
	  _createClass(Note, [{
	    key: 'toString',
	
	
	    /** @method */
	    value: function toString() {
	      return this.slur.begin + this.pitch + this.duration + this.slur.end + this.tie.value;
	    }
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Unique def id of the note used in the SVG <defs> element.
	     * ```
	     * defId := 'n' accidental step octave type dot
	     * ```
	     * E.g.
	     * ```
	     * Note     defId
	     * ------------------
	     * 1        n1040
	     * b3-      nb3020
	     * #5'_.    ns5181
	     * 6,,      n6-2
	     * ```
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      var _pitch = this.pitch;
	      var accidental = _pitch.accidental;
	      var step = _pitch.step;
	      var octave = _pitch.octave;
	      var _duration = this.duration;
	      var type = _duration.type;
	      var dot = _duration.dot;
	
	      return 'n' + accidental.replace(/#/g, 's') + step + octave + type + dot;
	    }
	
	    /**
	     * Pitch of the note.
	     * @type {musje.Pitch}
	     */
	
	  }, {
	    key: 'pitch',
	    get: function get() {
	      return this._pitch || (this._pitch = new _Pitch2.default(this));
	    },
	    set: function set(pitch) {
	      this._pitch = new _Pitch2.default(this, pitch);
	    }
	
	    /**
	     * Duration of the note.
	     * @type {musje.Duration}
	     */
	
	  }, {
	    key: 'duration',
	    get: function get() {
	      return this._duration || (this._duration = new _Duration2.default());
	    },
	    set: function set(duration) {
	      this._duration = new _Duration2.default(duration);
	    }
	  }, {
	    key: 'beams',
	    get: function get() {
	      return this._beams || (this._beams = []);
	    },
	    set: function set(beams) {
	      this._beams = beams;
	    }
	
	    /**
	     * Tie
	     * @type {musje.Tie}
	     */
	
	  }, {
	    key: 'tie',
	    get: function get() {
	      return this._tie || (this._tie = new _Tie2.default(this));
	    },
	    set: function set(tie) {
	      /**
	       * Value of the tie.
	       * @memberof Tie#
	       * @alias value
	       * @type {boolean}
	       */
	      this.tie.value = tie;
	    }
	
	    /**
	     * Slur
	     * @type {Slur}
	     */
	
	  }, {
	    key: 'slur',
	    get: function get() {
	      return this._slur || (this._slur = new _Slur2.default(this));
	    },
	    set: function set(slur) {
	      (0, _util.extend)(this.slur, slur);
	    }
	  }]);
	
	  return Note;
	}(_MusicData3.default);
	
	exports.default = Note;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var A4_FREQUENCY = 440;
	var A4_MIDI_NUMBER = 69;
	var STEP_TO_MIDI_NUMBER = [undefined, 0, 2, 4, 5, 7, 9, 11];
	var ACCIDENTAL_TO_ALTER = { '#': 1, '##': 2, n: 0, b: -1, bb: -2 };
	
	var chars = function chars(ch, num) {
	  return new Array(num + 1).join(ch);
	};
	var octaveString = function octaveString(octave) {
	  return octave > 0 ? chars('\'', octave) : octave < 0 ? chars(',', -octave) : '';
	};
	
	// /**
	//  * Step is a value of `1`, `2`, `3`, `4`, `5`, `6`, or `7`.
	//  * @type {number}
	//  * @default
	//  */
	// step = 1
	
	// /**
	//  * Octave is an integer value from `-5` to `5` inclusive.
	//  * @type {number}
	//  * @default
	//  */
	// octave = 0
	
	// /**
	//  * Accidental is either of
	//  * - `'#'` - sharp
	//  * - `'##'` - double sharp
	//  * - `'b'` - flat
	//  * - `'bb'` - double flat
	//  * - `'n'` - natural
	//  * - `''` - (none)
	//  * @type {string}
	//  */
	// accidental = ''
	
	/**
	 * @class
	 * @param parent {Note|Chord}
	 * @param pitch {Object}
	 */
	
	var Pitch = function () {
	  function Pitch(parent, _ref) {
	    var _ref$step = _ref.step;
	    var step = _ref$step === undefined ? 1 : _ref$step;
	    var _ref$octave = _ref.octave;
	    var octave = _ref$octave === undefined ? 0 : _ref$octave;
	    var _ref$accidental = _ref.accidental;
	    var accidental = _ref$accidental === undefined ? '' : _ref$accidental;
	
	    _classCallCheck(this, Pitch);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      step: 1,
	      octave: 0,
	      accidental: ''
	    });
	
	    this._parent = parent;
	    (0, _util.extend)(this, { step: step, octave: octave, accidental: accidental });
	  }
	
	  /**
	   * Reference to the parent parent.
	   * @type {Note|Chord}
	   * @readonly
	   */
	
	
	  _createClass(Pitch, [{
	    key: 'toString',
	
	
	    /**
	     * Convert to musje source code string.
	     * @return {string} Converted musje source code string.
	     */
	    value: function toString() {
	      return this.accidental + this.step + octaveString(this.octave);
	    }
	  }, {
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * defId := 'p' accidental step octave
	     * ```
	     * @type {string}
	     * @readonly
	     */
	
	  }, {
	    key: 'defId',
	    get: function get() {
	      return 'p' + this.accidental.replace(/#/g, 's') + this.step + this.octave;
	    }
	
	    /**
	     * Alter (from -2 to 2 inclusive).
	     *
	     * If no accidental in this pitch, it might be affected by a previous note in the same cell (the same part and the same measure).
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'alter',
	    get: function get() {
	      if (this.accidental) return ACCIDENTAL_TO_ALTER[this.accidental];
	      var alterLink = this.alterLink;
	
	      return alterLink ? alterLink.alter : 0;
	    }
	
	    /**
	     * Pitch linked that will affect the alter in this pitch.
	     * @type {Pitch|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'alterLink',
	    get: function get() {
	      var prevData = this.parent.prev;
	
	      while (prevData) {
	        if (prevData.$type === 'note' && prevData.pitch.step === this.step && prevData.pitch.accidental) {
	          return prevData.pitch;
	        }
	        prevData = prevData.prev;
	      }
	    }
	
	    /**
	     * The MIDI note number of the pitch
	     * @type {number}
	     */
	
	  }, {
	    key: 'midiNumber',
	    get: function get() {
	      return (this.octave + 5) * 12 + STEP_TO_MIDI_NUMBER[this.step] + this.alter;
	    }
	
	    /**
	     * Frequency of the pitch
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'frequency',
	    get: function get() {
	      return A4_FREQUENCY * Math.pow(2, (this.midiNumber - A4_MIDI_NUMBER) / 12);
	    }
	  }]);
	
	  return Pitch;
	}();
	
	exports.default = Pitch;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var TYPE_TO_STRING = {
	  1: ' - - - ', 2: ' - ', 4: '', 8: '_', 16: '=', 32: '=_',
	  64: '==', 128: '==_', 256: '===', 512: '===_', 1024: '===='
	};
	var TYPE_TO_UNDERBAR = {
	  1: 0, 2: 0, 4: 0, 8: 1, 16: 2, 32: 3,
	  64: 4, 128: 5, 256: 6, 512: 7, 1024: 8
	};
	var DOT_TO_STRING = ['', '.', '..'];
	
	// /**
	//  * Beat type
	//  * @type {number}
	//  * @default
	//  */
	// type = 4
	
	// *
	//  * Dot with value of 0, 1, or 2.
	//  * @type {number}
	//  * @default
	
	// dot = 0
	
	var Duration = function () {
	  function Duration() {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var _ref$type = _ref.type;
	    var type = _ref$type === undefined ? 4 : _ref$type;
	    var _ref$dot = _ref.dot;
	    var dot = _ref$dot === undefined ? 0 : _ref$dot;
	
	    _classCallCheck(this, Duration);
	
	    this.$type = 'duration';
	    this.toJSON = (0, _util.makeToJSON)({
	      type: 4,
	      dot: 0
	    });
	
	    (0, _util.extend)(this, { type: type, dot: dot });
	  }
	
	  /**
	   * Type of duration.
	   * @constant
	   * @default duration
	   */
	
	
	  _createClass(Duration, [{
	    key: 'toString',
	
	
	    /**
	     * @return {string}
	     */
	    value: function toString() {
	      return TYPE_TO_STRING[this.type] + DOT_TO_STRING[this.dot];
	    }
	
	    /**
	     * [toJSON description]
	     * @return {Object}
	     */
	
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * defId := 'd' type dot
	     * ```
	     * *E.g.*
	     * ```
	     * Note     defId
	     * ----------------
	     * 1.       d41
	     * 1_       d80
	     * 1=       d160
	     * 1-..     d22
	     * ```
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      return 'd' + this.type + this.dot;
	    }
	
	    /**
	     * `(Getter)` Duration measured in quarter note.
	     * @type {number}
	     */
	
	  }, {
	    key: 'quarter',
	    get: function get() {
	      var d = 4 / this.type;
	      return this.dot === 0 ? d : this.dot === 1 ? d * 1.5 : d * 1.75;
	    }
	
	    /**
	     * `(Getter)` Duration in second
	     * Affected by the tempo.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'second',
	    get: function get() {
	      return this.quarter * 60 / 80; // / TEMPO;
	    }
	
	    /**
	     * `(Getter)` Number of underbars in the beam.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'underbar',
	    get: function get() {
	      return TYPE_TO_UNDERBAR[this.type] || 0;
	    }
	  }]);
	
	  return Duration;
	}();
	
	exports.default = Duration;

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Tie of the note.
	 * @param parent {Note|Chord}
	 */
	
	var Tie = function () {
	  function Tie(parent) {
	    _classCallCheck(this, Tie);
	
	    this.value = '';
	
	    this._parent = parent;
	  }
	
	  _createClass(Tie, [{
	    key: 'toJSON',
	    value: function toJSON() {
	      return this.value;
	    }
	  }, {
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	  }, {
	    key: 'begin',
	    get: function get() {
	      return this.value;
	    }
	  }, {
	    key: 'end',
	    get: function get() {
	      return this.prevParent;
	    }
	
	    /**
	     * The previous durable music data in part, if it is a tie begin.
	     * @type {Durable|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevParent',
	    get: function get() {
	      var prev = this.parent.prevDurableInPart;
	      return prev && prev.tie && prev.tie.value && prev;
	    }
	
	    /**
	     * The next durable music data in part.
	     * @type {Durable|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextParent',
	    get: function get() {
	      return this.value && this.parent.nextDurableInPart;
	    }
	
	    /**
	     * If previous durable music data in part has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevHasError',
	    get: function get() {
	      var prev = this.prevParent;
	      if (!prev || !prev.pitch) return true;
	      return prev.pitch && prev.pitch.midiNumber !== this.parent.pitch.midiNumber;
	    }
	
	    /**
	     * If next durable music data in part has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextHasError',
	    get: function get() {
	      var next = this.nextParent;
	      if (!next || !next.pitch) return true;
	      return next.pitch.midiNumber !== this.parent.pitch.midiNumber;
	    }
	  }]);
	
	  return Tie;
	}();
	
	exports.default = Tie;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Slur
	 * @class
	 * @param parent {Note|Chord}
	 */
	
	var Slur = function () {
	  function Slur(parent) {
	    _classCallCheck(this, Slur);
	
	    this.begin = '';
	    this.end = '';
	    this.toJSON = (0, _util.makeToJSON)({
	      begin: undefined,
	      end: undefined
	    });
	
	    this._parent = parent;
	  }
	
	  _createClass(Slur, [{
	    key: 'parent',
	
	
	    /**
	     * Parent music data.
	     * @type {Note|Chord}
	     * @readonly
	     */
	    get: function get() {
	      return this._parent;
	    }
	
	    /**
	     * Previous slurred parent.
	     * @type {Note|Chord}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevParent',
	    get: function get() {
	      if (!this.end) return;
	
	      var prev = this.parent.prevInPart;
	      while (prev) {
	        if (prev.slur && !prev.slur.isEmpty) return prev;
	        prev = prev.prevInPart;
	      }
	    }
	
	    /**
	     * Next Slurred parent.
	     * @type {Note|Chord}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextParent',
	    get: function get() {
	      if (!this.begin) return;
	
	      var next = this.parent.nextInPart;
	      while (next) {
	        if (next.slur && !next.slur.isEmpty) return next;
	        next = next.nextInPart;
	      }
	    }
	
	    /**
	     * @todo Nested tie in slur.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevCrossTie',
	    get: function get() {}
	
	    /**
	     * @todo Nested tie in slur.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextCrossTie',
	    get: function get() {}
	
	    /**
	     * If the previous slur has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevHasError',
	    get: function get() {
	      var prevParent = this.prevParent;
	
	      return !prevParent || !prevParent.slur.begin;
	    }
	
	    /**
	     * If the next slur has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextHasError',
	    get: function get() {
	      var nextParent = this.nextParent;
	
	      return !nextParent || !nextParent.slur.end;
	    }
	
	    /**
	     * If the slur is empty.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'isEmpty',
	    get: function get() {
	      return !(this.begin || this.end);
	    }
	
	    /**
	     * Convert the slur to JSON object.
	     * @method
	     * @return {Object} JSON object.
	     */
	
	  }]);
	
	  return Slur;
	}();
	
	exports.default = Slur;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	var _Duration = __webpack_require__(14);
	
	var _Duration2 = _interopRequireDefault(_Duration);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {rest} rest
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	
	var Rest = function (_MusicData) {
	  _inherits(Rest, _MusicData);
	
	  function Rest(rest) {
	    _classCallCheck(this, Rest);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Rest).call(this));
	
	    _this.$type = 'rest';
	    _this.toJSON = (0, _util.makeToJSON)({
	      duration: undefined
	    }, 'rest');
	
	    (0, _util.extend)(_this, rest);
	    return _this;
	  }
	
	  /**
	   * Type of rest.
	   * @constant
	   * @default rest
	   */
	
	
	  _createClass(Rest, [{
	    key: 'toString',
	
	
	    /**
	     * Convert the rest to musje source code string.
	     * @return {string} Converted musje source code.
	     */
	    value: function toString() {
	      return '0' + this.duration;
	    }
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Unique def id of the rest used in the SVG <defs> element.
	     * ```
	     * defId := 'r' type dot
	     * ```
	     * E.g.
	     * ```
	     * Rest     defId
	     * ----------------
	     * 0        r40
	     * 0 -      r20
	     * 0=.      r161
	     * ```
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      var _duration = this.duration;
	      var type = _duration.type;
	      var dot = _duration.dot;
	
	      return 'r' + type + dot;
	    }
	
	    /**
	     * Duration of the rest.
	     * @type {Duration}
	     */
	
	  }, {
	    key: 'duration',
	    get: function get() {
	      return this._duration || (this._duration = new _Duration2.default());
	    },
	    set: function set(duration) {
	      this._duration = new _Duration2.default(duration);
	    }
	  }, {
	    key: 'beams',
	    get: function get() {
	      return this._beams || (this._beams = []);
	    },
	    set: function set(beams) {
	      this._beams = beams;
	    }
	  }]);
	
	  return Rest;
	}(_MusicData3.default);
	
	exports.default = Rest;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	var _Pitch = __webpack_require__(13);
	
	var _Pitch2 = _interopRequireDefault(_Pitch);
	
	var _Duration = __webpack_require__(14);
	
	var _Duration2 = _interopRequireDefault(_Duration);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {Object} chord
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	
	var Chord = function (_MusicData) {
	  _inherits(Chord, _MusicData);
	
	  function Chord(chord) {
	    _classCallCheck(this, Chord);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Chord).call(this));
	
	    _this.$type = 'chord';
	    _this.toJSON = (0, _util.makeToJSON)({
	      pitches: undefined,
	      duration: undefined
	    }, 'chord');
	
	    (0, _util.extend)(_this, chord);
	    return _this;
	  }
	
	  /**
	   * Type of chord.
	   * @constant
	   * @default chord
	   */
	
	
	  _createClass(Chord, [{
	    key: 'toString',
	
	
	    /**
	     * Convert chord to the musje source code string.
	     * @return {string} Converted musje source code of the chord.
	     */
	    value: function toString() {
	      return '<' + this.pitches.map(function (pitch) {
	        return pitch.toString();
	      }).join('') + '>' + this.duration;
	    }
	  }, {
	    key: 'pitches',
	
	
	    /**
	     * Pitches in the chord.
	     * @type {Array.<Pitch>}
	     */
	    get: function get() {
	      return this._pitches || (this._pitches = []);
	    },
	    set: function set(pitches) {
	      this._pitches = pitches.map(function (pitch) {
	        return new _Pitch2.default(pitch);
	      });
	    }
	
	    /**
	     * Duration of the chord.
	     * @type {Duration}
	     */
	
	  }, {
	    key: 'duration',
	    get: function get() {
	      return this._duration || (this._duration = new _Duration2.default());
	    },
	    set: function set(duration) {
	      this._duration = new _Duration2.default(duration);
	    }
	  }]);
	
	  return Chord;
	}(_MusicData3.default);
	
	exports.default = Chord;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {Object} voice
	 */
	
	var Voice = function (_MusicData) {
	  _inherits(Voice, _MusicData);
	
	  function Voice(voice) {
	    _classCallCheck(this, Voice);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Voice).call(this));
	
	    _this.$type = 'voice';
	
	    (0, _util.extend)(_this, voice);
	    return _this;
	  }
	
	  /**
	   * Type of voice.
	   * @constant
	   * @default voice
	   */
	
	
	  _createClass(Voice, [{
	    key: 'toString',
	
	
	    /**
	     * Convert the voice to musje source code string.
	     * @return {string} Converted musje source code string.
	     */
	    value: function toString() {}
	  }]);
	
	  return Voice;
	}(_MusicData3.default);
	
	exports.default = Voice;

/***/ },
/* 20 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * A [beam][wiki] is a horizontal or diagonal line used to connect multiple consecutive notes (and occasionally rests) in order to indicate rhythmic grouping. Only eighth notes (quavers) or shorter can be beamed.
	 *
	 * [wiki]: https://en.wikipedia.org/wiki/Beam_(music)
	 *
	 * Beam is created by {@link Cell#makeBeams} and
	 * attached to {@link Durable} in {@link Durable#beams}[level]
	 * @class
	 * @param {string} value - Beam value: `'begin'`, `'continue'` or `'end'`.
	 * @param {number} level - Beam level starting from 0 to up.
	 * @param {Durable} parent - The parent durable music data.
	 */
	
	var Beam = function () {
	  function Beam(value, level, parent) {
	    _classCallCheck(this, Beam);
	
	    this._value = value;
	    this._level = level;
	    this._parent = parent;
	  }
	
	  /**
	   * Parent
	   * @type {Note|Rest|Chord}
	   * @readonly
	   */
	
	
	  _createClass(Beam, [{
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	
	    /**
	     * Beam value: `'begin'`, `'continue'` or `'end'`.
	     * @type {string}
	     * @readonly
	     */
	
	  }, {
	    key: 'value',
	    get: function get() {
	      return this._value;
	    }
	
	    /**
	     * Beam level starting from 0 to up.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'level',
	    get: function get() {
	      return this._level;
	    }
	
	    /**
	     * The end parent music data of the beam group.
	     * @type {MusicDataMixin}
	     */
	
	  }, {
	    key: 'endDurable',
	    get: function get() {
	      var nextData = this.parent.next;
	      while (nextData && nextData.beams[this.level].value !== 'end') {
	        nextData = nextData.next;
	      }
	      return nextData;
	    }
	  }]);
	
	  return Beam;
	}();
	
	exports.default = Beam;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _TimewiseMeasure = __webpack_require__(22);
	
	var _TimewiseMeasure2 = _interopRequireDefault(_TimewiseMeasure);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _extendableBuiltin(cls) {
	  function ExtendableBuiltin() {
	    cls.apply(this, arguments);
	  }
	
	  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
	    constructor: {
	      value: cls,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	
	  if (Object.setPrototypeOf) {
	    Object.setPrototypeOf(ExtendableBuiltin, cls);
	  } else {
	    ExtendableBuiltin.__proto__ = cls;
	  }
	
	  return ExtendableBuiltin;
	}
	
	/**
	 * Construct timewise score measures.
	 * @class
	 * @classdesc Timewise score measures.
	 * @param score {Score}
	 * @augments {Array}
	 */
	
	var TimewiseMeasures = function (_extendableBuiltin2) {
	  _inherits(TimewiseMeasures, _extendableBuiltin2);
	
	  function TimewiseMeasures(score) {
	    _classCallCheck(this, TimewiseMeasures);
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TimewiseMeasures).call(this));
	
	    _this._score = score;
	    return _this;
	  }
	
	  /**
	   * Reference to the parent score.
	   * @type {Score}
	   * @readonly
	   */
	
	
	  _createClass(TimewiseMeasures, [{
	    key: 'fromPartwise',
	
	
	    /**
	     * Make timewise score measures from the partwise parts.
	     */
	    value: function fromPartwise() {
	      var _this2 = this;
	
	      this.removeAll();
	      this.score.walkCells(function (cell, m) {
	        if (m === _this2.length && !_this2[m]) _this2.push(new _TimewiseMeasure2.default(m, _this2));
	        _this2[m].parts.push(cell);
	      });
	    }
	
	    /**
	     * Remove all measures.
	     */
	
	  }, {
	    key: 'removeAll',
	    value: function removeAll() {
	      this.length = 0;
	    }
	  }, {
	    key: 'score',
	    get: function get() {
	      return this._score;
	    }
	  }]);
	
	  return TimewiseMeasures;
	}(_extendableBuiltin(Array));
	
	exports.default = TimewiseMeasures;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param measure {Object}
	 * @mixes TimewiseMeasureLayoutMixin
	 */
	
	var TimewiseMeasure = function () {
	  function TimewiseMeasure(index, measures) {
	    _classCallCheck(this, TimewiseMeasure);
	
	    // this._index = index
	    this._measures = measures;
	  }
	
	  /**
	   * Reference to the parent measures instance.
	   * @member {TimewiseMeasures}
	   */
	
	
	  _createClass(TimewiseMeasure, [{
	    key: 'flow',
	
	
	    /**
	     * Flow the measure.
	     */
	    value: function flow() {
	      var _this = this;
	
	      this.parts.forEach(function (cell) {
	
	        /**
	         * Cell SVG group element.
	         * @memberof CellLayout#
	         * @alias el
	         * @type {Snap.Element}
	         * @readonly
	         */
	        cell.el = _this.el.g().addClass('mus-cell');
	
	        cell.x = _this.outerWidthLeft;
	
	        // cell.drawBox()
	      });
	    }
	
	    /**
	     * Draw box of the cell.
	     * @return {Snap.Element} The box SVG rect element.
	     */
	
	  }, {
	    key: 'drawBox',
	    value: function drawBox() {
	      this._boxEl = this.el.rect(0, 0, this.width, this.height).attr({ stroke: 'green', fill: 'none' });
	    }
	
	    /**
	     * Clear the box SVG element.
	     */
	
	  }, {
	    key: 'clearBox',
	    value: function clearBox() {
	      this._boxEl.remove();
	      this._boxEl = undefined;
	    }
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures;
	    }
	
	    /**
	     * Parts in timewise measure.
	     * @type {Array.<Cell>}
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this._parts || (this._parts = []);
	    },
	    set: function set(parts) {
	      this._parts = parts;
	    }
	
	    /**
	     * Left bar of the measure.
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeft',
	    get: function get() {
	      return this.parts[0].barLeft;
	    }
	
	    /**
	     * Right bar of the measure.
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRight',
	    get: function get() {
	      return this.parts[0].barRight;
	    }
	
	    /**
	     * Measure SVG group element.
	     * @type {Snap.Element}
	     * @readonly
	     */
	
	  }, {
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Minimun width of the measure.
	     * @type {number}
	     */
	
	  }, {
	    key: 'minWidth',
	    get: function get() {
	      var minWidth = 0;
	      this.parts.forEach(function (cell) {
	        minWidth = Math.max(minWidth, cell.minWidth);
	      });
	      return minWidth + this.padding;
	    }
	
	    /**
	     * Reference to the parent system of this measure.
	     * - (Getter)
	     * - (Setter) The measure el will be created, and the height of the measure will be set.
	     * @type {SystemLayout}
	     */
	
	  }, {
	    key: 'system',
	    get: function get() {
	      return this._s;
	    },
	    set: function set(system) {
	      this._s = system;
	      this._el = system.el.g().addClass('mus-measure');
	    }
	  }, {
	    key: 'padding',
	    get: function get() {
	      var lo = this.layout.options;
	      return lo.measurePaddingRight + lo.measurePaddingLeft;
	    }
	  }, {
	    key: 'outerWidth',
	    get: function get() {
	      return this.outerWidthLeft + this.outerWidthRight;
	    }
	  }, {
	    key: 'outerWidthLeft',
	    get: function get() {
	      return this.layout.options.measurePaddingLeft + this.barLeftInSystem.width / 2;
	    }
	  }, {
	    key: 'outerWidthRight',
	    get: function get() {
	      return this.layout.options.measurePaddingRight + this.barRightInSystem.width / 2;
	    }
	
	    /**
	     * Width of the measure.
	     * @type {number}
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w || (this._w = this.minWidth);
	    },
	    set: function set(w) {
	      var _this2 = this;
	
	      this._w = w;
	      this.parts.forEach(function (cell) {
	        cell.width = w - _this2.outerWidth;
	      });
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      return this.system.height;
	    }
	  }, {
	    key: 'minHeight',
	    get: function get() {
	      var partSep = this.layout.options.partSep;
	
	      var minHeight = 0;
	
	      this.parts.forEach(function (cell) {
	        minHeight += cell.height + partSep;
	      });
	      return minHeight ? minHeight - partSep : 0;
	    }
	
	    /**
	     * The x position of the measure in the system.
	     * - (Getter)
	     * - (Setter) Set x cause the measure element to translate.
	     * @type {number}
	     */
	
	  }, {
	    key: 'x',
	    get: function get() {
	      return this._x;
	    },
	    set: function set(x) {
	      this._x = x;
	      this.el.transform(Snap.matrix().translate(x, 0));
	    }
	
	    /**
	     * If the measure in the beginning of the system.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'inSystemBegin',
	    get: function get() {
	      return this._sIndex === 0;
	    }
	
	    /**
	     * If the measure in the end of the system.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'inSystemEnd',
	    get: function get() {
	      return this._sIndex === this.system.measures.length - 1;
	    }
	
	    /**
	     * Left bar of the measure in system.
	     * @type {musje.Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeftInSystem',
	    get: function get() {
	      return this.parts[0].barLeftInSystem;
	    }
	
	    /**
	     * Right bar of the measure in system.
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRightInSystem',
	    get: function get() {
	      return this.parts[0].barRightInSystem;
	    }
	  }]);
	
	  return TimewiseMeasure;
	}();
	
	exports.default = TimewiseMeasure;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _util = __webpack_require__(2);
	
	var _Layout = __webpack_require__(24);
	
	var _Layout2 = _interopRequireDefault(_Layout);
	
	var _renderBar = __webpack_require__(38);
	
	var _renderBar2 = _interopRequireDefault(_renderBar);
	
	var _renderDuration = __webpack_require__(39);
	
	var _renderDuration2 = _interopRequireDefault(_renderDuration);
	
	var _renderCurve = __webpack_require__(40);
	
	var _renderCurve2 = _interopRequireDefault(_renderCurve);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Renderer = function () {
	  function Renderer(svg, lo) {
	    _classCallCheck(this, Renderer);
	
	    this._lo = (0, _util.extend)(_Layout2.default.options, lo);
	    this.layout = new _Layout2.default(svg, this._lo);
	  }
	
	  _createClass(Renderer, [{
	    key: 'render',
	    value: function render(score) {
	      this._score = score;
	      this.layout.flow(score);
	      this.renderHeader();
	      this.renderContent();
	    }
	  }, {
	    key: 'renderHeader',
	    value: function renderHeader() {
	      var lo = this._lo;
	      var header = this.layout.header;
	      var el = header.el;
	      var width = header.width;
	
	
	      el.text(width / 2, lo.titleFontSize, this._score.head.title).attr({
	        fontSize: lo.titleFontSize,
	        fontWeight: lo.titleFontWeight,
	        textAnchor: 'middle'
	      });
	
	      el.text(width, lo.titleFontSize * 1.5, this._score.head.composer).attr({
	        fontSize: lo.composerFontSize,
	        fontWeight: lo.composerFontWeight,
	        textAnchor: 'end'
	      });
	
	      header.height = el.getBBox().height;
	    }
	  }, {
	    key: 'renderContent',
	    value: function renderContent() {
	      var lo = this._lo;
	
	      this.layout.content.systems.forEach(function (system) {
	        var measures = system.measures;
	
	        measures.forEach(function (measure) {
	          (0, _renderBar2.default)(measure, lo);
	          measure.parts.forEach(function (cell) {
	            renderCell(cell, lo);
	          });
	        });
	      });
	    }
	  }]);
	
	  return Renderer;
	}();
	
	function renderNote(note, cell, lo) {
	  note.el = cell.el.g().transform((0, _snapsvg.matrix)().translate(note.x, note.y));
	  note.el.use(note.def.pitchDef.el);
	  (0, _renderDuration2.default)(note, lo);
	}
	
	function renderCell(cell, lo) {
	  cell.data.forEach(function (data) {
	    switch (data.$type) {
	      case 'rest':
	        renderNote(data, cell, lo);
	        break;
	      case 'note':
	        renderNote(data, cell, lo);
	        (0, _renderCurve2.default)('tie', data);
	        (0, _renderCurve2.default)('slur', data);
	        break;
	      case 'time':
	        data.el = cell.el.use(data.def.el).attr({ x: data.x, y: data.y });
	        break;
	      default:
	    }
	  });
	}
	
	exports.default = Renderer;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _layoutOptions = __webpack_require__(25);
	
	var _layoutOptions2 = _interopRequireDefault(_layoutOptions);
	
	var _Defs = __webpack_require__(26);
	
	var _Defs2 = _interopRequireDefault(_Defs);
	
	var _SvgLayout = __webpack_require__(33);
	
	var _SvgLayout2 = _interopRequireDefault(_SvgLayout);
	
	var _BodyLayout = __webpack_require__(34);
	
	var _BodyLayout2 = _interopRequireDefault(_BodyLayout);
	
	var _HeaderLayout = __webpack_require__(35);
	
	var _HeaderLayout2 = _interopRequireDefault(_HeaderLayout);
	
	var _ContentLayout = __webpack_require__(36);
	
	var _ContentLayout2 = _interopRequireDefault(_ContentLayout);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param svg {string}
	 * @param options {Object} Layout options
	 */
	
	var Layout = function () {
	  function Layout(svg, options) {
	    _classCallCheck(this, Layout);
	
	    this.options = options;
	    this.svg = svg;
	
	    this.svg = new _SvgLayout2.default(this);
	    this.body = new _BodyLayout2.default(this);
	    this.header = new _HeaderLayout2.default(this);
	    this.content = new _ContentLayout2.default(this);
	
	    this.defs = new _Defs2.default(this);
	  }
	
	  /**
	   * @param  {Score} score
	   */
	
	
	  _createClass(Layout, [{
	    key: 'flow',
	    value: function flow(score) {
	      init(this, score);
	      this.content.flow(score.measures);
	    }
	  }]);
	
	  return Layout;
	}();
	
	Layout.options = _layoutOptions2.default;
	
	function init(that, score) {
	  var measures = score.measures;
	
	  measures.forEach(function (measure, m) {
	    measure = measures[m];
	    measure.layout = that;
	    measure.parts.forEach(function (cell) {
	      cell.layout = that;
	      cell.flow();
	    });
	  });
	}
	
	exports.default = Layout;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _util = __webpack_require__(2);
	
	var layoutOptions = {
	  mode: 'block', // inline | block | paper
	  // width: 650,
	  // height: 600,
	  marginTop: 25,
	  marginRight: 30,
	  marginBottom: 25,
	  marginLeft: 30,
	
	  fontSize: 20,
	  fontFamily: 'Helvetica, Arial, Sans Serif',
	
	  titleFontSize: '110%',
	  // titleFontFamily
	  titleFontWeight: 'bold',
	  composerFontSize: '90%',
	  // composerFontFamily:
	  composerFontWeight: 'bold',
	  // composerFontStyle,
	  timeFontSize: '95%',
	  timeFontWeight: 'bold',
	
	  headerSep: '100%',
	  systemSep: '180%',
	  musicDataSep: '20%',
	
	  partHeight: '120%',
	  partSep: '80%',
	
	  measurePaddingLeft: '50%',
	  measurePaddingRight: '50%',
	
	  barlineHeight: '120%',
	  thinBarlineWidth: '4%',
	  thickBarlineWidth: '16%',
	  barlineSep: '18%',
	  barlineDotRadius: '7.5%',
	  barlineDotSep: '22%',
	
	  accidentalFontSize: '95%',
	  accidentalShift: '10%',
	
	  octaveRadius: '6.6%',
	  octaveOffset: '0%',
	  octaveSep: '23%',
	
	  stepBaselineShift: '12%', // for step without lower octave and underline
	
	  typeStrokeWidth: '5%',
	  typebarOffset: '30%', // 1 - - -
	  typebarLength: '55%', // off len sep len sep len (dot) ext
	  typebarSep: '45%', // 1 -
	  typebarExt: '20%', // off len (dot) ext
	  underbarSep: '17%',
	
	  dotOffset: '60%', // for type = 2
	  dotRadius: '6.6%', // 1 - . .
	  dotSep: '60%', // off len dotOff . dotSep . ext
	  t4DotOffset: '30%',
	  t4DotSep: '50%',
	  t4DotExt: '25%',
	  t4DotBaselineShift: '20%'
	};
	
	var fontSize = layoutOptions.fontSize;
	
	
	(0, _util.objEach)(layoutOptions, function (value, key) {
	  if (typeof value !== 'string') return;
	
	  var unit = value.replace(/[\d\.]+/, '');
	  value = +value.replace(/[^\d\.]+/, '');
	
	  switch (unit) {
	    case '%':
	      layoutOptions[key] = fontSize * value / 100;
	      break;
	    case '':
	    // fall through
	    case 'px':
	      layoutOptions[key] = value;
	      break;
	    case 'others to be implemented':
	      break;
	    default:
	  }
	});
	
	exports.default = layoutOptions;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _AccidentalDef = __webpack_require__(27);
	
	var _AccidentalDef2 = _interopRequireDefault(_AccidentalDef);
	
	var _BarDef = __webpack_require__(29);
	
	var _BarDef2 = _interopRequireDefault(_BarDef);
	
	var _DurationDef = __webpack_require__(30);
	
	var _DurationDef2 = _interopRequireDefault(_DurationDef);
	
	var _PitchDef = __webpack_require__(31);
	
	var _PitchDef2 = _interopRequireDefault(_PitchDef);
	
	var _TimeDef = __webpack_require__(32);
	
	var _TimeDef2 = _interopRequireDefault(_TimeDef);
	
	var _Note = __webpack_require__(12);
	
	var _Note2 = _interopRequireDefault(_Note);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param {Layout} layout
	 */
	
	var Defs = function () {
	  function Defs(layout) {
	    _classCallCheck(this, Defs);
	
	    this._layout = layout;
	  }
	
	  /**
	   * Get the svg def of the music data.
	   * @param  musicData {MusicDataMixin} music data
	   * @return {Def}
	   */
	
	
	  _createClass(Defs, [{
	    key: 'get',
	    value: function get(musicData) {
	      var id = musicData.defId;
	      return this[id] || (this[id] = makeDef(id, musicData, this));
	    }
	  }, {
	    key: 'getAccidental',
	    value: function getAccidental(accidental) {
	      var id = 'a' + accidental.replace(/#/g, 's');
	      return this[id] || (this[id] = new _AccidentalDef2.default(id, accidental, this._layout));
	    }
	  }, {
	    key: '_getPitch',
	    value: function _getPitch(id, pitch, underbar) {
	      return this[id] || (this[id] = new _PitchDef2.default(id, pitch, underbar, this));
	    }
	  }]);
	
	  return Defs;
	}();
	
	function makeDef(id, musicData, defs) {
	  switch (musicData.$type) {
	    case 'bar':
	      return new _BarDef2.default(id, musicData, defs._layout);
	    case 'time':
	      return new _TimeDef2.default(id, musicData, defs._layout);
	    case 'note':
	      return makeNoteDef(musicData, defs);
	    case 'rest':
	      return makeRestDef(musicData, defs);
	    case 'duration':
	      return new _DurationDef2.default(id, musicData, defs._layout);
	    default:
	      return { width: 0, height: 0 };
	  }
	}
	
	function makeNoteDef(note, defs) {
	  var underbar = note.duration.underbar;
	  var pitchId = note.pitch.defId + underbar;
	  var pitchDef = defs._getPitch(pitchId, note.pitch, underbar);
	  var durationDef = defs.get(note.duration);
	  return {
	    pitchDef: pitchDef,
	    durationDef: durationDef,
	    height: pitchDef.height,
	    width: pitchDef.width + durationDef.width * (underbar ? pitchDef.scale.x : 1)
	  };
	}
	
	function makeRestDef(rest, defs) {
	  var restNote = new _Note2.default({ pitch: { step: 0 }, duration: rest.duration });
	  return makeNoteDef(restNote, defs);
	}
	
	exports.default = Defs;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	var _svgPaths = __webpack_require__(28);
	
	var _svgPaths2 = _interopRequireDefault(_svgPaths);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * SVG definition for accidental.
	 * @class
	 * @param {string} id         [description]
	 * @param {string} accidental [description]
	 * @param {Layout} layout     [description]
	 */
	function AccidentalDef(id, accidental, layout) {
	  var _layout$options = layout.options;
	  var accidentalShift = _layout$options.accidentalShift;
	  var accidentalFontSize = _layout$options.accidentalFontSize;
	
	  var el = this.el = layout.svg.el.g().attr('id', id);
	  var accKey = accidental.replace(/bb/, 'b'); // double flat to be synthesized
	  var pathData = _svgPaths2.default[accKey];
	  var ratio = _svgPaths2.default.ACCIDENTAL_RATIOS[accKey];
	  var shift = _svgPaths2.default.ACCIDENTAL_SHIFTS[accKey];
	  var path = el.path(pathData);
	  var bb = el.getBBox();
	
	  path.transform(_snapsvg2.default.matrix().translate(0.1 * accidentalShift, -accidentalShift).scale(ratio * accidentalFontSize).translate(-bb.x, shift - bb.y2));
	
	  // Combine two flat to be double flat.
	  if (accidental === 'bb') {
	    el.use(path).attr('x', accidentalFontSize * 0.24);
	    el.transform('scale(0.9,1)');
	  }
	
	  bb = el.getBBox();
	  this.width = bb.width * 1.2;
	
	  el.toDefs();
	}
	
	exports.default = AccidentalDef;

/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var svgPaths = {
	  // https://upload.wikimedia.org/wikipedia/commons/a/a6/Sharp.svg
	  '#': 'M6.102,7.457V2.753L8.102,2.201V6.881L6.102,7.457zM10.04,6.319L8.665,6.713V2.033L10.04,1.649V-0.295L8.665,0.089V-4.69277H8.102V0.234L6.102,0.809V-3.84077H5.571V0.986L4.196,1.371V3.319L5.571,2.935V7.606L4.196,7.989V9.929L5.571,9.545V14.299L6.102,14.29977V9.375L8.102,8.825V13.45077H8.665V8.651L10.04,8.266V6.319z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/3/3a/DoubleSharp.svg
	  '##': 'M5.009,8.30721C4.27443,8.19192 3.52769,8.19209 2.7858,8.19294C2.77007,7.65011 2.85674,7.0729 2.6415,6.56343C2.49821,6.22426 2.22532,5.95665 1.98269,5.68155C1.59552,6.0278 1.27751,6.48475 1.24704,7.01638C1.21706,7.40767 1.23902,7.80085 1.2322,8.19294C0.4904,8.20416-0.25918,8.16828-0.991,8.314C-0.84988,7.5863-0.88195,6.84171-0.86917,6.1048C-0.3043,6.08953 0.30023,6.17101 0.82484,5.92526C1.13441,5.78023 1.39653,5.55295 1.6591,5.33676C1.3173,4.94965 0.87346,4.60861 0.33665,4.57651C-0.06427,4.54485-0.46734,4.56793-0.86917,4.56097C-0.89434,3.82949-0.80895,3.08855-0.96079,2.3663C-0.23733,2.49697 0.50065,2.46343 1.2322,2.47284C1.24306,2.99383 1.18483,3.53381 1.33191,4.0355C1.44414,4.41838 1.74978,4.71293 2.0051,5.01521C2.36553,4.70111 2.69057,4.30706 2.75011,3.81412C2.804,3.36793 2.76123,2.91977 2.7858,2.47284C3.52263,2.45348 4.28215,2.54713 4.99535,2.314C4.88891,3.05711 4.87889,3.81152 4.88717,4.56097C4.36127,4.57582 3.80954,4.51747 3.30955,4.69457C2.92975,4.8291 2.63114,5.12341 2.32869,5.38325C2.65661,5.71867 3.0516,6.02802 3.5403,6.07368C3.98834,6.11554 4.43829,6.09658 4.88717,6.1048C4.89828,6.83958 4.86193,7.5825 5.009,8.30721z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/b/ba/Flat.svg
	  b: 'M8.166,3.657C8.166,4.232 7.950425,4.78273 7.359,5.52188C6.732435,6.30494 6.205,6.75313 5.51,7.28013V3.848C5.668,3.449 5.901,3.126 6.21,2.878C6.518,2.631 6.83,2.507 7.146,2.507C7.668,2.507 7.999,2.803 8.142,3.393C8.158,3.441 8.166,3.529 8.166,3.657zM8.091,1.257C7.66,1.257 7.222,1.376 6.776,1.615C6.33,1.853 5.908,2.172 5.51,2.569V-4.70267H4.947 V7.75213C4.947,8.10413 5.043,8.28013 5.235,8.28013C5.346,8.28013 5.483913,8.18713 5.69,8.06413C6.27334,7.71598 6.636935,7.48332 7.032,7.23788C7.482617,6.95792 7.99,6.631 8.661,5.991C9.124,5.526 9.459,5.057 9.667,4.585C9.874,4.112 9.978,3.644 9.978,3.179C9.978,2.491 9.795,2.002 9.429,1.713C9.015,1.409 8.568,1.257 8.091,1.257z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/f/f4/Music-natural.svg
	  n: 'M 0,14.112V41.52h-1.248V31.248l-6.672,1.728V5.232h1.2v10.704l6.72,-1.824zm-6.72,6.432v7.536l5.472,-1.44v-7.536l-5.472,1.44z',
	
	  ACCIDENTAL_RATIOS: { '#': 0.043, 'n': 0.023, '##': 0.062, b: 0.057 },
	  ACCIDENTAL_SHIFTS: { '#': 1, 'n': 2, '##': -4, b: 0 }
	};
	
	exports.default = svgPaths;

/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * SVG definition for barline.
	 * @class
	 * @param {string} id     [description]
	 * @param {Bar} bar    [description]
	 * @param {Layout} layout [description]
	 */
	function BarDef(id, bar, layout) {
	  var _layout$options = layout.options;
	  var thinBarlineWidth = _layout$options.thinBarlineWidth;
	  var thickBarlineWidth = _layout$options.thickBarlineWidth;
	  var barlineSep = _layout$options.barlineSep;
	  var barlineDotSep = _layout$options.barlineDotSep;
	  var barlineDotRadius = _layout$options.barlineDotRadius;
	
	  var x = 0;
	  var lineWidth = void 0;
	  this.el = layout.svg.el.g().attr('id', id).toDefs();
	
	  switch (bar.value) {
	    case 'single':
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'double':
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'end':
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'repeat-begin':
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineDotSep + barlineDotRadius;
	      break;
	    case 'repeat-end':
	      x = barlineDotSep + barlineDotRadius;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'repeat-both':
	      x = barlineDotSep + barlineDotRadius;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineDotSep + barlineDotRadius;
	      break;
	    default:
	  }
	  this.width = x;
	}
	
	function addBarline(that, x, width) {
	  that.el.rect(x, 0, width, 1);
	}
	
	exports.default = BarDef;

/***/ },
/* 30 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * SVG definition for duration.
	 * @class
	 * @param {string} id       [description]
	 * @param {Duration} duration [description]
	 * @param {Layout} layout   [description]
	 */
	function DurationDef(id, duration, layout) {
	  this._id = id;
	  this._layout = layout;
	
	  // only make def el for:
	  // id = d10, d11, d12, d20, d21, d20, d41, d40
	  switch (duration.type) {
	    case 1:
	      // whole note
	      makeEl(this);
	      makeType1(this, id, duration.dot);
	      break;
	    case 2:
	      // half note
	      makeEl(this);
	      makeType2(this, id, duration.dot);
	      break;
	    default:
	      // other note types type quarter note def
	      if (duration.dot === 0) {
	        this.width = 0;
	      } else {
	        makeEl(this);
	        makeType4(this, id, duration.dot);
	      }
	  }
	}
	
	function makeType1(that, id, dot) {
	  var _that$_layout$options = that._layout.options;
	  var typebarLength = _that$_layout$options.typebarLength;
	  var typebarSep = _that$_layout$options.typebarSep;
	  var typebarOffset = _that$_layout$options.typebarOffset;
	
	  var x = typebarOffset;
	
	  addLine(that, x);
	  x += typebarLength + typebarSep;
	  addLine(that, x);
	  x += typebarLength + typebarSep;
	  addLine(that, x);
	  x += typebarLength;
	
	  that.width = addDot(that, x, dot, 1);
	}
	
	function makeType2(that, id, dot) {
	  var _that$_layout$options2 = that._layout.options;
	  var typebarOffset = _that$_layout$options2.typebarOffset;
	  var typebarLength = _that$_layout$options2.typebarLength;
	
	  var x = typebarOffset;
	
	  addLine(that, typebarOffset);
	  x += typebarLength;
	  that.width = addDot(that, x, dot, 2);
	}
	
	function makeType4(that, id, dot) {
	  var _that$_layout$options3 = that._layout.options;
	  var t4DotOffset = _that$_layout$options3.t4DotOffset;
	  var t4DotBaselineShift = _that$_layout$options3.t4DotBaselineShift;
	  var t4DotSep = _that$_layout$options3.t4DotSep;
	  var t4DotExt = _that$_layout$options3.t4DotExt;
	  var dotRadius = _that$_layout$options3.dotRadius;
	
	  var x = t4DotOffset;
	
	  that.el.circle(x, -t4DotBaselineShift, dotRadius);
	
	  if (dot > 1) {
	    x += t4DotSep;
	    that.el.circle(x, -t4DotBaselineShift, dotRadius);
	  }
	  that.width = x + t4DotExt;
	}
	
	function makeEl(that) {
	  that.el = that._layout.svg.el.g().attr('id', that._id).toDefs();
	}
	
	function addLine(that, x) {
	  var _that$_layout$options4 = that._layout.options;
	  var typeStrokeWidth = _that$_layout$options4.typeStrokeWidth;
	  var typebarLength = _that$_layout$options4.typebarLength;
	
	  that.el.rect(x, -typeStrokeWidth, typebarLength, typeStrokeWidth);
	}
	
	// Add dot for type 1 (whole) or type 2 (half) note.
	function addDot(that, x, dot, type) {
	  var _that$_layout$options5 = that._layout.options;
	  var dotOffset = _that$_layout$options5.dotOffset;
	  var dotSep = _that$_layout$options5.dotSep;
	  var dotRadius = _that$_layout$options5.dotRadius;
	  var typebarExt = _that$_layout$options5.typebarExt;
	
	
	  if (dot > 0) {
	    x += dotOffset * (type === 1 ? 1.2 : 1);
	    that.el.circle(x, 0, dotRadius);
	  }
	  if (dot > 1) {
	    x += dotSep * (type === 1 ? 1.2 : 1);
	    that.el.circle(x, 0, dotRadius);
	  }
	  return x + typebarExt;
	}
	
	exports.default = DurationDef;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	var _util = __webpack_require__(2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * SVG definition for pitch.
	 * The `PitchDef` is defined by properties: a s o u
	 * accidental step octave underbar
	 * @class
	 * @param id {string}     [description]
	 * @param pitch {Pitch}   [description]
	 * @param layout {Layout} [description]
	 */
	function PitchDef(id, pitch, underbar, defs) {
	  var layout = this._layout = defs._layout;
	  var accidental = pitch.accidental;
	  var octave = pitch.octave;
	
	  var scale = getScale(accidental, octave, underbar);
	  var el = this.el = layout.svg.el.g().attr({
	    id: id,
	    stroke: 'black',
	    strokeWidth: 2 - (scale.x + scale.y)
	  });
	  var matrix = void 0,
	      sbbox = void 0,
	      pbbox = void 0;
	
	  this._defs = defs;
	  addAccidental(this, accidental);
	  addStep(this, pitch.step);
	  addOctave(this, octave);
	
	  matrix = getMatrix(this, scale, octave, underbar);
	  el.transform(matrix);
	
	  sbbox = this._sbbox;
	  sbbox = getBBoxAfterTransform(this.el, sbbox, matrix);
	
	  pbbox = el.getBBox();
	  el.toDefs();
	
	  (0, _util.extend)(this, {
	    scale: scale,
	    matrix: matrix,
	    width: pbbox.width,
	    height: -pbbox.y,
	    stepCx: sbbox.cx,
	    stepY: sbbox.y,
	    stepCy: sbbox.cy,
	    stepY2: sbbox.y2,
	    stepTop: octave > 0 ? pbbox.y : sbbox.y + layout.options.fontSize * 0.2
	  });
	}
	
	function addAccidental(that, accidental) {
	  if (!accidental) {
	    that._accidentalX2 = 0;
	    return;
	  }
	  var accDef = that._defs.getAccidental(accidental);
	  that.el.use(accDef.el).attr('y', -that._layout.options.accidentalShift);
	  that._accidentalX2 = accDef.width;
	}
	
	function addStep(that, step) {
	  that._sbbox = that.el.text(that._accidentalX2, 0, '' + step).attr('font-size', that._layout.options.fontSize).getBBox();
	}
	
	function addOctave(that, octave) {
	  if (!octave) return;
	
	  var _that$_layout$options = that._layout.options;
	  var octaveRadius = _that$_layout$options.octaveRadius;
	  var octaveOffset = _that$_layout$options.octaveOffset;
	  var octaveSep = _that$_layout$options.octaveSep;
	
	  var octaveEl = that.el.g();
	
	  if (octave > 0) {
	    for (var i = 0; i < octave; i++) {
	      octaveEl.circle(that._sbbox.cx, that._sbbox.y + octaveOffset - octaveSep * i, octaveRadius);
	    }
	  } else {
	    for (var _i = 0; _i > octave; _i--) {
	      octaveEl.circle(that._sbbox.cx, that._sbbox.y2 - octaveOffset - octaveSep * _i, octaveRadius);
	    }
	  }
	  that.el.add(octaveEl);
	}
	
	// Transform the pitch to be in a good baseline position and
	// scale it to be more square.
	function getMatrix(that, scale, octave, underbar) {
	  var _that$_layout$options2 = that._layout.options;
	  var stepBaselineShift = _that$_layout$options2.stepBaselineShift;
	  var underbarSep = _that$_layout$options2.underbarSep;
	
	  var pbbox = that.el.getBBox();
	  var dy = (octave >= 0 && underbar === 0 ? -stepBaselineShift : 0) - underbar * underbarSep;
	  return _snapsvg2.default.matrix().translate(-pbbox.x, dy).scale(scale.x, scale.y).translate(0, (0, _util.near)(pbbox.y2, that._sbbox.y2) ? 0 : -pbbox.y2);
	}
	
	function getBBoxAfterTransform(container, bbox, matrix) {
	  var rect = container.rect(bbox.x, bbox.y, bbox.width, bbox.height);
	  var g = container.g(rect);
	  rect.transform(matrix);
	  bbox = g.getBBox();
	  g.remove();
	  return bbox;
	}
	
	function getScale(hasAccidental, octave, underbar) {
	  var absOctave = Math.abs(octave);
	  return {
	    x: Math.pow(0.97, absOctave + underbar + (hasAccidental ? 2 : 0)),
	    y: Math.pow(0.95, absOctave + underbar + (hasAccidental ? 1 : 0))
	  };
	}
	
	exports.default = PitchDef;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * SVG definition for time signature.
	 * @class
	 * @param {string} id     [description]
	 * @param {Time} time   [description]
	 * @param {Layout} layout [description]
	 */
	function TimeDef(id, time, layout) {
	  var _layout$options = layout.options;
	  var fontSize = _layout$options.timeFontSize;
	  var fontWeight = _layout$options.timeFontWeight;
	
	  var lineExtend = fontSize * 0.1;
	  var el = this.el = layout.svg.el.g().attr({
	    id: id,
	    fontSize: fontSize,
	    fontWeight: fontWeight,
	    textAnchor: 'middle'
	  });
	  var lineY = -0.85 * fontSize;
	  var bb = void 0;
	
	  el.text(0, -1 * fontSize, time.beats);
	  el.text(0, 0, time.beatType); // baseline y = 0
	  bb = el.getBBox();
	  el.line(bb.x - lineExtend, lineY, bb.x2 + lineExtend, lineY);
	  el.transform(_snapsvg2.default.matrix().scale(1, 0.8).translate(lineExtend - bb.x, 0));
	
	  bb = el.getBBox();
	  el.toDefs();
	
	  this.width = bb.width;
	  this.height = -bb.y;
	}
	
	exports.default = TimeDef;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param layout {Layout}
	 */
	
	var SvgLayout = function () {
	  function SvgLayout(layout) {
	    _classCallCheck(this, SvgLayout);
	
	    this._layout = layout;
	    var _layout$options = layout.options;
	    var fontFamily = _layout$options.fontFamily;
	    var width = _layout$options.width;
	
	    this._el = (0, _snapsvg2.default)(layout.svg).attr({ fontFamily: fontFamily }).addClass('musje');
	    this.el.clear();
	    this.width = width;
	  }
	
	  _createClass(SvgLayout, [{
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Width of the svg.
	     * @type {number}
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	      this.el.attr('width', w);
	      var body = this._layout.body;
	
	      if (body) body.width = w;
	    }
	
	    /**
	     * Height of the svg.
	     * @type {number}
	     */
	
	  }, {
	    key: 'height',
	    get: function get() {
	      return this._h;
	    },
	    set: function set(h) {
	      this._h = h;
	      this.el.attr('height', h);
	    }
	  }]);
	
	  return SvgLayout;
	}();
	
	exports.default = SvgLayout;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Body
	 * @class
	 * @param {Layout} layout
	 */
	
	var BodyLayout = function () {
	  function BodyLayout(layout) {
	    _classCallCheck(this, BodyLayout);
	
	    this._layout = layout;
	    var svg = layout.svg;
	    var options = layout.options;
	    var marginTop = options.marginTop;
	    var marginRight = options.marginRight;
	    var marginLeft = options.marginLeft;
	    var width = options.width;
	
	    this._el = svg.el.g().transform((0, _snapsvg.matrix)().translate(marginLeft, marginTop)).addClass('mus-body');
	    this.width = width - marginLeft - marginRight;
	  }
	
	  _createClass(BodyLayout, [{
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Width of the body.
	     * - (Getter) Get the body width.
	     * - (Setter) Set the body width and this also induces setting the
	     * header and content width if one exists.
	     * @type {number}
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	      var layout = this._layout;
	      if (layout.header) layout.header.width = w;
	      if (layout.content) layout.content.width = w;
	    }
	
	    /**
	     * Height of the body.
	     * - (Getter) Get the body height.
	     * - (Setter) Set the body height and this will also cause the height of svg to vary.
	     * @type {number}
	     */
	
	  }, {
	    key: 'height',
	    get: function get() {
	      return this._h;
	    },
	    set: function set(h) {
	      var layout = this._layout;
	      var _layout$options = layout.options;
	      var marginTop = _layout$options.marginTop;
	      var marginBottom = _layout$options.marginBottom;
	
	      layout.svg.height = h + marginTop + marginBottom;
	      this._h = h;
	    }
	  }]);
	
	  return BodyLayout;
	}();
	
	exports.default = BodyLayout;

/***/ },
/* 35 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Header layout.
	 * @param {Layout} layout
	 */
	
	var HeaderLayout = function () {
	  function HeaderLayout(layout) {
	    _classCallCheck(this, HeaderLayout);
	
	    this._layout = layout;
	    this.el = layout.body.el.g().addClass('mus-header');
	    this.width = layout.body.width;
	  }
	
	  /**
	   * Width of the header.
	   * @type {number}
	   */
	
	
	  _createClass(HeaderLayout, [{
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	    }
	
	    /**
	     * Height of the header.
	     * @type {number}
	     */
	
	  }, {
	    key: 'height',
	    get: function get() {
	      return this._h;
	    },
	    set: function set(h) {
	      this._h = h;
	      var _layout = this._layout;
	      var content = _layout.content;
	      var options = _layout.options;
	
	      content.y = h ? h + options.headerSep : 0;
	    }
	  }]);
	
	  return HeaderLayout;
	}();
	
	exports.default = HeaderLayout;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _SystemLayout = __webpack_require__(37);
	
	var _SystemLayout2 = _interopRequireDefault(_SystemLayout);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param {Object} layout - Reference to the parent layout instance.
	 */
	
	var ContentLayout = function () {
	  function ContentLayout(layout) {
	    _classCallCheck(this, ContentLayout);
	
	    this.layout = layout;
	    this.el = layout.body.el.g().addClass('mus-content');
	    this.width = layout.body.width;
	  }
	
	  _createClass(ContentLayout, [{
	    key: 'flow',
	
	
	    /**
	     * @param scoreMeasure {musje.TimewiseMeasures} The timewise score measure.
	     */
	    value: function flow(scoreMeasures) {
	      makeSystems(this, scoreMeasures);
	      balanceSystems(this);
	      this.systems.forEach(function (system) {
	        system.flow();
	      });
	    }
	  }, {
	    key: 'y',
	    get: function get() {
	      return this._y;
	    },
	    set: function set(y) {
	      this._y = y;
	      this.el.transform((0, _snapsvg.matrix)().translate(0, y));
	      resizeBody(this);
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      var last = this.systems[this.systems.length - 1];
	      return last ? last.y + last.height : 0;
	    }
	  }]);
	
	  return ContentLayout;
	}();
	
	function resizeBody(that) {
	  var layout = that.layout;
	  var hHeight = layout.header.height;
	
	  layout.body.height = that.height + (hHeight ? hHeight + layout.options.headerSep : 0);
	}
	
	/**
	 * Divide measures in timewise score into the systems.
	 * @param scoreMeasure {musje.TimewiseMeasures} The timewise score measure.
	 */
	function makeSystems(that, scoreMeasures) {
	  var layout = that.layout;
	  var _layout$options = layout.options;
	  var measurePaddingRight = _layout$options.measurePaddingRight;
	  var measurePaddingLeft = _layout$options.measurePaddingLeft;
	
	  var measurePadding = measurePaddingLeft + measurePaddingRight;
	  var systems = that.systems = [];
	  var system = new _SystemLayout2.default(layout, 0);
	  systems.push(system);
	
	  scoreMeasures.forEach(function (measure) {
	    var minWidth = measure.minWidth + measurePadding + (measure.barLeftInSystem.width + measure.barRightInSystem.width) / 2;
	
	    // Continue put this measure in the system.
	    if (system.minWidth + minWidth < that.width) {
	      system.measures.push(measure);
	
	      // New system
	    } else {
	      system = new _SystemLayout2.default(layout, systems.length);
	      systems.push(system);
	      system.measures.push(measure);
	    }
	  });
	}
	
	function getMaxLengthSystem(that) {
	  var maxLength = 0;
	  var system = void 0;
	
	  that.systems.forEach(function (system) {
	    maxLength = Math.max(maxLength, system.measures.length);
	  });
	
	  // Find the first max length system backward.
	  for (var i = that.systems.length - 1; i >= 0; i--) {
	    system = that.systems[i];
	    if (system.measures.length === maxLength) return system;
	  }
	}
	
	function isNotBalancable(that) {
	  var systems = that.systems;
	  var width = that.width;
	  var length = systems.length;
	
	  return length === 1 || // only 1 system
	  length === 2 && systems[1].minWidth < width * 0.4; // 1 2/5 systems
	}
	
	function balanceSystems(that) {
	  if (isNotBalancable(that)) return;
	
	  var systems = that.systems;
	
	  var last = systems[systems.length - 1];
	  var system = getMaxLengthSystem(that);
	  var next = void 0,
	      prev = void 0;
	
	  // Move measures down to balance the last system.
	  while (last.measures.length < system.measures.length - 1) {
	
	    // Move a measure tail-to-head downward to the last measure.
	    while (true) {
	      next = system.next;
	      if (!next) break;
	      next.measures.unshift(system.measures.pop());
	      system = next;
	    }
	    system = getMaxLengthSystem(that);
	  }
	
	  // Move back measures if the system exceeds the content width.
	  system = last;
	  while (system) {
	    prev = system.prev;
	    while (system.minWidth > that.width) {
	      prev.measures.push(system.measures.shift());
	    }
	    system = prev;
	  }
	}
	
	exports.default = ContentLayout;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param {number} index
	 * @param {Layout} layout
	 */
	
	var SystemLayout = function () {
	  function SystemLayout(layout, index) {
	    _classCallCheck(this, SystemLayout);
	
	    this._index = index;
	    this._layout = layout;
	    this._el = layout.content.el.g().addClass('mus-system');
	  }
	
	  _createClass(SystemLayout, [{
	    key: 'flow',
	    value: function flow() {
	      var _this = this;
	
	      var minHeight = 0;
	      var x = 0;
	
	      tuneMeasuresWidths(this);
	
	      this.measures.forEach(function (measure, m) {
	        measure.system = _this;
	        measure._sIndex = m;
	        measure.flow();
	        measure.x = x;
	        x += measure.width;
	        minHeight = Math.max(minHeight, measure.minHeight);
	      });
	
	      var prev = this.prev;
	
	      this.y = prev ? prev.y + prev.height + this._layout.options.systemSep : 0;
	      this.height = minHeight;
	    }
	  }, {
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Measures in a system.
	     * @type {Array.<TimewiseMeasure>}
	     * @readonly
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures || (this._measures = []);
	    }
	
	    /**
	     * Previous system.
	     * @type {SystemLayout}
	     */
	
	  }, {
	    key: 'prev',
	    get: function get() {
	      return this._layout.content.systems[this._index - 1];
	    }
	
	    /**
	     * Next system.
	     * @type {SystemLayout}
	     */
	
	  }, {
	    key: 'next',
	    get: function get() {
	      return this._layout.content.systems[this._index + 1];
	    }
	  }, {
	    key: 'y',
	    get: function get() {
	      return this._y;
	    },
	    set: function set(y) {
	      this._y = y;
	      this.el.transform((0, _snapsvg.matrix)().translate(0, y));
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._layout.content.width;
	    }
	  }, {
	    key: 'minWidth',
	    get: function get() {
	      var min = 0;
	      this.measures.forEach(function (measure) {
	        min += measure.minWidth;
	      });
	      return min;
	    }
	  }, {
	    key: 'content',
	    get: function get() {
	      return this._layout.content;
	    }
	  }, {
	    key: 'systems',
	    get: function get() {
	      return this.content.systems;
	    }
	  }]);
	
	  return SystemLayout;
	}();
	
	function tuneMeasuresWidths(that) {
	  if (!isTunable(that)) return;
	
	  var pairs = getPairs(that.measures);
	  var length = pairs.length;
	  var widthLeft = that.width;
	  var itemLeft = length;
	  var i = 0; // i + itemLeft === length
	  var width;
	
	  while (i < length) {
	    if (widthLeft >= pairs[i].width * itemLeft) {
	      width = widthLeft / itemLeft;
	      do {
	        pairs[i].measure.width = width;
	        i++;
	      } while (i < length);
	      break;
	    } else {
	      width = pairs[i].width;
	      pairs[i].measure.width = width;
	      widthLeft -= width;
	      i++;
	      itemLeft--;
	    }
	  }
	}
	
	function isTunable(that) {
	  var ctWidth = that.content.width;
	  var s = that._index;
	  var ssLen = that.systems.length;
	  return ssLen > 2 || ssLen === 1 && that.minWidth > ctWidth * 0.7 || ssLen === 2 && (s === 0 || s === 1 && that.minWidth > ctWidth * 0.4);
	}
	
	var descendingSort = function descendingSort(a, b) {
	  return b.width - a.width;
	};
	
	var getPairs = function getPairs(measures) {
	  return measures.map(function (measure) {
	    return {
	      width: measure.minWidth,
	      measure: measure
	    };
	  }).sort(descendingSort);
	};
	
	exports.default = SystemLayout;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = renderBar;
	
	var _snapsvg = __webpack_require__(8);
	
	function renderDots(el, x, radius, measureHeight) {
	  var cy = measureHeight / 2;
	  var dy = measureHeight * 0.15;
	
	  el.circle(x, cy - dy, radius);
	  el.circle(x, cy + dy, radius);
	}
	
	function render(bar, measure, lo) {
	  var barlineDotRadius = lo.barlineDotRadius;
	  var height = measure.height;
	
	  var el = measure.el.g().addClass('mus-barline');
	  el.use(bar.def.el).transform((0, _snapsvg.matrix)().scale(1, height));
	
	  switch (bar.value) {
	    case 'repeat-begin':
	      renderDots(el, bar.width - barlineDotRadius, barlineDotRadius, height);
	      break;
	    case 'repeat-end':
	      renderDots(el, barlineDotRadius, barlineDotRadius, height);
	      break;
	    case 'repeat-both':
	      renderDots(el, bar.width - barlineDotRadius, barlineDotRadius, height);
	      renderDots(el, barlineDotRadius, barlineDotRadius, height);
	      break;
	    default:
	  }
	
	  return el;
	}
	
	var translate = function translate(el, x) {
	  el.transform((0, _snapsvg.matrix)().translate(x, 0));
	};
	
	// @param m {number} Measure index in measures.
	// @param len {number} Length of measures.
	function renderBar(measure, lo) {
	  var bar = measure.barRightInSystem;
	  var el = void 0;
	
	  if (bar.def) {
	    el = render(bar, measure, lo);
	
	    // Align end in system end.
	    if (measure.inSystemEnd) translate(el, measure.width - bar.width);
	    // Others align middle.
	    else translate(el, measure.width - bar.width / 2);
	  }
	
	  // Render right bar and align begin in system begin.
	  if (measure.inSystemBegin) {
	    bar = measure.barLeftInSystem;
	    if (bar.def) render(bar, measure, lo);
	  }
	}

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	function renderDuration(note, lo) {
	  var _note$def = note.def;
	  var durationDef = _note$def.durationDef;
	  var pitchDef = _note$def.pitchDef;
	  var underbar = note.duration.underbar;
	
	  var y = 0;
	
	  // Whole and half notes
	  if (note.duration.type < 4) {
	    note.el.use(durationDef.el).attr({
	      x: pitchDef.width,
	      y: pitchDef.stepCy
	    });
	
	    // Quarter or shorter notes
	  } else {
	
	    // Add dots
	    if (note.duration.dot) {
	      note.el.g().transform((0, _snapsvg.matrix)().translate(pitchDef.width, 0)).use(durationDef.el).transform(pitchDef.matrix);
	    }
	
	    // Add underbars for eigth or shorter notes
	    if (underbar) {
	      for (var i = 0; i < underbar; i++) {
	
	        // Only render beam for the begin one.
	        if (note.beams[i]) {
	          if (note.beams[i].value === 'begin') {
	            renderUnderbar(note, note.beams[i].endDurable, y, lo);
	          }
	
	          // Unbeamed underbar
	        } else {
	          renderUnderbar(note, note, y, lo);
	        }
	        y -= lo.underbarSep;
	      }
	    }
	  }
	}
	
	function renderUnderbar(note1, note2, y, lo) {
	  note1.el.line(0, y, note2.x - note1.x + note2.width, y).attr('stroke-width', lo.typeStrokeWidth);
	}
	
	exports.default = renderDuration;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = renderCurve;
	
	var _snapsvg = __webpack_require__(8);
	
	function getCurvePath(x1, y1, x2, y2) {
	  var dx = x2 - x1;
	  var dy = y2 - y1;
	  var c1x = 0; //-0.1 * dx
	  var c1y = 0; //-0.1 * dy
	  var c2x = dx; //1.1 * dx
	  var c2y = dy; //1.1 * dy
	
	  return (0, _snapsvg.format)('M{x1},{y1}c{c1x},{c1y} {c2x},{c2y} {dx},{dy}c{c3x},{c3y} {c4x},{c4y} {negDx},{negDy}', {
	    x1: x1,
	    y1: y1,
	    c1x: c1x,
	    c1y: c1y - 8,
	    c2x: c2x,
	    c2y: c2y - 8,
	    dx: dx,
	    dy: dy,
	    c3x: -c1x,
	    c3y: -c1y - 10,
	    c4x: -c2x,
	    c4y: -c2y - 10,
	    negDx: -dx,
	    negDy: -dy
	  });
	}
	
	function renderEndCurve(note, error) {
	  var _note$def$pitchDef = note.def.pitchDef;
	  var x1 = _note$def$pitchDef.stepCx;
	  var y1 = _note$def$pitchDef.stepTop;
	
	  var x2 = -note.systemX - 3;
	  var el = note.el.path(getCurvePath(x1, y1, x2, y1 - 3));
	
	  if (error) el.addClass('mus-error');
	  return el;
	}
	
	function renderBeginCurve(note, error) {
	  var _note$def$pitchDef2 = note.def.pitchDef;
	  var x1 = _note$def$pitchDef2.stepCx;
	  var y1 = _note$def$pitchDef2.stepTop;
	
	  var x2 = note.system.width - note.systemX + 3;
	  var el = note.el.path(getCurvePath(x1, y1, x2, y1 - 3));
	
	  if (error) el.addClass('mus-error');
	  return el;
	}
	
	function renderCompleteCurve(note1, note2, error) {
	  var _note1$def$pitchDef = note1.def.pitchDef;
	  var x1 = _note1$def$pitchDef.stepCx;
	  var y1 = _note1$def$pitchDef.stepTop;
	  var _note2$def$pitchDef = note2.def.pitchDef;
	  var x2 = _note2$def$pitchDef.stepCx;
	  var y2 = _note2$def$pitchDef.stepTop;
	
	  var noteDx = note2.systemX - note1.systemX;
	  var el = note1.el.path(getCurvePath(x1, y1, noteDx + x2, y2));
	
	  if (error) el.addClass('mus-error');
	  return el;
	}
	
	function renderCurve(type, note) {
	  if (note[type].end) {
	    var prev = note[type].prevParent;
	    var prevHasError = note[type].prevHasError;
	
	
	    if (!prev || prev.system !== note.system) renderEndCurve(note, prevHasError);else if (prevHasError) renderCompleteCurve(note, prev, prevHasError);
	  }
	
	  if (note[type].begin) {
	    var next = note[type].nextParent;
	    var nextHasError = note[type].nextHasError;
	
	
	    if (!next || next.system !== note.system) renderBeginCurve(note, nextHasError);else renderCompleteCurve(note, next, nextHasError);
	  }
	}

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _MIDI = __webpack_require__(42);
	
	var _MIDI2 = _interopRequireDefault(_MIDI);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var timeouts = [];
	
	var PlayerMixin = {
	
	  /**
	   * Start playing the song.
	   */
	
	  play: function play() {
	    var measures = this.parts[0].measures;
	
	    var time = 0; //audioCtx.currentTime
	
	    measures.forEach(function (cell) {
	      cell.data.forEach(function (data) {
	        switch (data.$type) {
	          case 'note':
	            // playNote(time, dur, freq)
	            timeouts.push(midiPlayNote(data, time));
	            time += data.duration.second;
	            break;
	          case 'rest':
	            time += data.duration.second;
	            break;
	          default:
	        }
	      });
	    });
	  },
	
	
	  /**
	   * Stop playing the song.
	   */
	  stop: function stop() {
	    timeouts.forEach(function (timeout) {
	      clearTimeout(timeout);
	    });
	    timeouts.length = 0;
	  }
	};
	
	// if (window.AudioContext) {
	//   var audioCtx = new window.AudioContext()
	//   var gainNode = audioCtx.createGain()
	//   gainNode.connect(audioCtx.destination)
	//   gainNode.gain.value = 0.5  // set the volume
	// }
	
	// // var oscillator = audioCtx.createOscillator()
	// // oscillator.connect(gainNode)
	// // oscillator.type = 'square' // sine | square | sawtooth | triangle | custom
	
	// function playNote(time, dur, freq) {
	//   if (!audioCtx) { return }
	
	//   var oscillator = audioCtx.createOscillator()
	//   oscillator.type = 'sine'
	//   oscillator.connect(audioCtx.destination)
	//   oscillator.frequency.value = freq
	//   oscillator.start(time)
	//   oscillator.stop(time + dur - 0.05)
	// }
	
	function midiPlayNote(note, time) {
	  var midiNumber = note.pitch.midiNumber;
	
	  var dur = note.duration.second;
	
	  function play() {
	    if (!note.tie.prevParent || note.tie.prevHasError) {
	      _MIDI2.default.noteOn(0, midiNumber, 100, 0);
	    }
	    if (!note.tie.nextParent || note.tie.nextHasError) {
	      _MIDI2.default.noteOff(0, midiNumber, dur);
	    }
	    note.el.addClass('mus-playing');
	    setTimeout(function () {
	      note.el.removeClass('mus-playing');
	    }, dur * 800 + 100);
	    console.log('Play: ' + note, time, dur, midiNumber);
	  }
	
	  return setTimeout(play, time * 800);
	}
	
	exports.default = PlayerMixin;

/***/ },
/* 42 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_42__;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBkYjRlMTZmOTczY2YzODNmYTcxOCIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFyc2VyL3BhcnNlci5qaXNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvU2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1Njb3JlSGVhZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUGFydHdpc2VQYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUGFydHdpc2VQYXJ0LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9DZWxsLmpzIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJyb290XCI6XCJTbmFwXCIsXCJjb21tb25qczJcIjpcInNuYXBzdmdcIixcImNvbW1vbmpzXCI6XCJzbmFwc3ZnXCIsXCJhbWRcIjpcInNuYXBzdmdcIn0iLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1RpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL011c2ljRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvQmFyLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9Ob3RlLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9QaXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1RpZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvU2x1ci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvQ2hvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1ZvaWNlLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9CZWFtLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmVzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvTGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvbGF5b3V0T3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9EZWZzLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9kZWZzL0FjY2lkZW50YWxEZWYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL3N2Z1BhdGhzLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9kZWZzL0JhckRlZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9EdXJhdGlvbkRlZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9QaXRjaERlZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9UaW1lRGVmLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvU3ZnTGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvQm9keUxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0hlYWRlckxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0NvbnRlbnRMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL0xheW91dC9TeXN0ZW1MYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL3JlbmRlckJhci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvUmVuZGVyZXIvcmVuZGVyRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL3JlbmRlckN1cnZlLmpzIiwid2VicGFjazovLy8uL3NyYy9wbGF5ZXIvUGxheWVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiTUlESVwiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFTQSxpQkFBTSxTQUFOLENBQWdCLE1BQWhCLEdBQXlCLFVBQVUsR0FBVixFQUFlLEVBQWYsRUFBbUI7QUFDMUMsMEJBQWEsR0FBYixFQUFrQixFQUFsQixFQUFzQixNQUF0QixDQUE2QixJQUE3QjtBQUNELEVBRkQ7O0FBSUEsNkJBQWlCLGdCQUFNLFNBQXZCOzs7Ozs7O0FBT08sS0FBTSx3QkFBUSxTQUFSLEtBQVEsQ0FBQyxLQUFELEVBQVc7QUFDOUIsVUFBTyxpQkFBTyxLQUFQLENBQWEsS0FBYixDQUFQOzs7QUFHRCxFQUpNOztTQU1FLEs7Ozs7OztBQzlCVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsZ0JBQWUsa0NBQWtDO0FBQ2pELGtCQUFpQixrQ0FBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLElBQUk7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FB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dkQsRUFBeUQsTUFBTSxHQUFOLEdBQVksR0FBckU7QUFDQSxhQUFRLEdBQVIsQ0FBWSxXQUFXLElBQXZCLEVBQTZCLElBQTdCLEVBQW1DLEdBQW5DLEVBQXdDLFVBQXhDO0FBQ0Q7O0FBRUQsVUFBTyxXQUFXLElBQVgsRUFBaUIsT0FBTyxHQUF4QixDQUFQO0FBQ0Q7O21CQUVjLFc7Ozs7OztBQ2hGZixpRCIsImZpbGUiOiJtdXNqZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInNuYXBzdmdcIiksIHJlcXVpcmUoXCJNSURJXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInNuYXBzdmdcIiwgXCJNSURJXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIm11c2plXCJdID0gZmFjdG9yeShyZXF1aXJlKFwic25hcHN2Z1wiKSwgcmVxdWlyZShcIk1JRElcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIm11c2plXCJdID0gZmFjdG9yeShyb290W1wiU25hcFwiXSwgcm9vdFtcIk1JRElcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV84X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNDJfXykge1xucmV0dXJuIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvblxuICoqLyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgZGI0ZTE2Zjk3M2NmMzgzZmE3MThcbiAqKi8iLCJpbXBvcnQgcGFyc2VyIGZyb20gJy4vcGFyc2VyL3BhcnNlci5qaXNvbidcclxuaW1wb3J0IFNjb3JlIGZyb20gJy4vbW9kZWwvU2NvcmUnXHJcbmltcG9ydCBSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyL1JlbmRlcmVyL1JlbmRlcmVyJ1xyXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSAnLi91dGlsJ1xyXG5pbXBvcnQgUGxheWVyTWl4aW4gZnJvbSAnLi9wbGF5ZXIvUGxheWVyTWl4aW4nXHJcblxyXG4vKipcclxuICogUmVuZGVyIHRoZSBzY29yZSBpbiBqaWFucHUgKG51bWJlcmVkIG11c2ljYWwgbm90YXRpb24pLlxyXG4gKiBAbWVtYmVyXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3ZnXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsbyAtIExheW91dCBvcHRpb25zLlxyXG4gKi9cclxuU2NvcmUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzdmcsIGxvKSB7XHJcbiAgbmV3IFJlbmRlcmVyKHN2ZywgbG8pLnJlbmRlcih0aGlzKVxyXG59XHJcblxyXG5kZWZpbmVQcm9wZXJ0aWVzKFNjb3JlLnByb3RvdHlwZSwgUGxheWVyTWl4aW4pXHJcblxyXG4vKipcclxuICogUGFyc2Ugc291cmNlIG11c2plIHN0cmluZyB0byBiZSBhIFNjb3JlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBJbnB1dCBvZiB0aGUgbXVzamUgc291cmNlIGNvZGUuXHJcbiAqIEByZXR1cm4ge1Njb3JlfSAtIEEgYFNjb3JlYCBpbnN0YW5jZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBwYXJzZSA9IChpbnB1dCkgPT4ge1xyXG4gIHJldHVybiBwYXJzZXIucGFyc2UoaW5wdXQpXHJcbiAgLy8gdmFyIHBsYWluU2NvcmUgPSBwYXJzZXIucGFyc2UoaW5wdXQpO1xyXG4gIC8vIHJldHVybiBuZXcgU2NvcmUocGxhaW5TY29yZSk7XHJcbn1cclxuXHJcbmV4cG9ydCB7IFNjb3JlIH1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbWFpbi5qc1xuICoqLyIsIi8qIHBhcnNlciBnZW5lcmF0ZWQgYnkgamlzb24gMC40LjE3ICovXG4vKlxuICBSZXR1cm5zIGEgUGFyc2VyIG9iamVjdCBvZiB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcblxuICBQYXJzZXI6IHtcbiAgICB5eToge31cbiAgfVxuXG4gIFBhcnNlci5wcm90b3R5cGU6IHtcbiAgICB5eToge30sXG4gICAgdHJhY2U6IGZ1bmN0aW9uKCksXG4gICAgc3ltYm9sc186IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBudW1iZXJ9LFxuICAgIHRlcm1pbmFsc186IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IG5hbWV9LFxuICAgIHByb2R1Y3Rpb25zXzogWy4uLl0sXG4gICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUsICQkLCBfJCksXG4gICAgdGFibGU6IFsuLi5dLFxuICAgIGRlZmF1bHRBY3Rpb25zOiB7Li4ufSxcbiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLFxuICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCksXG5cbiAgICBsZXhlcjoge1xuICAgICAgICBFT0Y6IDEsXG4gICAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgICAgIHNldElucHV0OiBmdW5jdGlvbihpbnB1dCksXG4gICAgICAgIGlucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAgICAgICAgbW9yZTogZnVuY3Rpb24oKSxcbiAgICAgICAgbGVzczogZnVuY3Rpb24obiksXG4gICAgICAgIHBhc3RJbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpLFxuICAgICAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbihyZWdleF9tYXRjaF9hcnJheSwgcnVsZV9pbmRleCksXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIGxleDogZnVuY3Rpb24oKSxcbiAgICAgICAgYmVnaW46IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gICAgICAgIHBvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbigpLFxuICAgICAgICB0b3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAgICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbihjb25kaXRpb24pLFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHJhbmdlczogYm9vbGVhbiAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiB0b2tlbiBsb2NhdGlvbiBpbmZvIHdpbGwgaW5jbHVkZSBhIC5yYW5nZVtdIG1lbWJlcilcbiAgICAgICAgICAgIGZsZXg6IGJvb2xlYW4gICAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZCBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaClcbiAgICAgICAgICAgIGJhY2t0cmFja19sZXhlcjogYm9vbGVhbiAgKG9wdGlvbmFsOiB0cnVlID09PiBsZXhlciByZWdleGVzIGFyZSB0ZXN0ZWQgaW4gb3JkZXIgYW5kIGZvciBlYWNoIG1hdGNoaW5nIHJlZ2V4IHRoZSBhY3Rpb24gY29kZSBpcyBpbnZva2VkOyB0aGUgbGV4ZXIgdGVybWluYXRlcyB0aGUgc2NhbiB3aGVuIGEgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbiBjb2RlKVxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJUKSxcbiAgICAgICAgcnVsZXM6IFsuLi5dLFxuICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAgICB9XG4gIH1cblxuXG4gIHRva2VuIGxvY2F0aW9uIGluZm8gKEAkLCBfJCwgZXRjLik6IHtcbiAgICBmaXJzdF9saW5lOiBuLFxuICAgIGxhc3RfbGluZTogbixcbiAgICBmaXJzdF9jb2x1bW46IG4sXG4gICAgbGFzdF9jb2x1bW46IG4sXG4gICAgcmFuZ2U6IFtzdGFydF9udW1iZXIsIGVuZF9udW1iZXJdICAgICAgICh3aGVyZSB0aGUgbnVtYmVycyBhcmUgaW5kZXhlcyBpbnRvIHRoZSBpbnB1dCBzdHJpbmcsIHJlZ3VsYXIgemVyby1iYXNlZClcbiAgfVxuXG5cbiAgdGhlIHBhcnNlRXJyb3IgZnVuY3Rpb24gcmVjZWl2ZXMgYSAnaGFzaCcgb2JqZWN0IHdpdGggdGhlc2UgbWVtYmVycyBmb3IgbGV4ZXIgYW5kIHBhcnNlciBlcnJvcnM6IHtcbiAgICB0ZXh0OiAgICAgICAgKG1hdGNoZWQgdGV4dClcbiAgICB0b2tlbjogICAgICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiwgaWYgYW55KVxuICAgIGxpbmU6ICAgICAgICAoeXlsaW5lbm8pXG4gIH1cbiAgd2hpbGUgcGFyc2VyIChncmFtbWFyKSBlcnJvcnMgd2lsbCBhbHNvIHByb3ZpZGUgdGhlc2UgbWVtYmVycywgaS5lLiBwYXJzZXIgZXJyb3JzIGRlbGl2ZXIgYSBzdXBlcnNldCBvZiBhdHRyaWJ1dGVzOiB7XG4gICAgbG9jOiAgICAgICAgICh5eWxsb2MpXG4gICAgZXhwZWN0ZWQ6ICAgIChzdHJpbmcgZGVzY3JpYmluZyB0aGUgc2V0IG9mIGV4cGVjdGVkIHRva2VucylcbiAgICByZWNvdmVyYWJsZTogKGJvb2xlYW46IFRSVUUgd2hlbiB0aGUgcGFyc2VyIGhhcyBhIGVycm9yIHJlY292ZXJ5IHJ1bGUgYXZhaWxhYmxlIGZvciB0aGlzIHBhcnRpY3VsYXIgZXJyb3IpXG4gIH1cbiovXG52YXIgcGFyc2VyID0gKGZ1bmN0aW9uKCl7XG52YXIgbz1mdW5jdGlvbihrLHYsbyxsKXtmb3Iobz1vfHx7fSxsPWsubGVuZ3RoO2wtLTtvW2tbbF1dPXYpO3JldHVybiBvfSwkVjA9WzEsMTFdLCRWMT1bMSwxNV0sJFYyPVsxLDE2XSwkVjM9WzEsMTddLCRWND1bMSwxOF0sJFY1PVsxLDE5XSwkVjY9WzEsMjBdLCRWNz1bMSwyM10sJFY4PVsxLDI3XSwkVjk9WzEsMzRdLCRWYT1bMSwzNV0sJFZiPVsxLDMzXSwkVmM9WzEsMjhdLCRWZD1bMSwyOV0sJFZlPVs1LDksMTAsMTQsMjEsMjIsMjMsMjQsMjUsMjYsMjksMzQsMzksNDEsNDgsNTEsNThdLCRWZj1bMiw4XSwkVmc9WzUsOSwxMCwyMSwyMiwyMywyNCwyNSwyNiwyOSwzNCwzOSw0MSw0OCw1MSw1OF0sJFZoPVs1LDIxLDIyLDIzLDI0LDI1LDI2XSwkVmk9WzIsNDddLCRWaj1bMSw0OF0sJFZrPVsxLDQ5XSwkVmw9WzEsNTBdLCRWbT1bMSw1MV0sJFZuPVsxLDUyXSwkVm89WzUsOSwxMCwyMSwyMiwyMywyNCwyNSwyNiwyOCwyOSwzNCwzNSwzOSw0MSw0OCw1MSw1Myw1OF0sJFZwPVs1LDksMTAsMjEsMjIsMjMsMjQsMjUsMjYsMjgsMjksMzQsMzUsMzksNDEsNDMsNDQsNDUsNDYsNDcsNDgsNTEsNTMsNThdLCRWcT1bNSw5LDEwLDIxLDIyLDIzLDI0LDI1LDI2LDI4LDI5LDM0LDM1LDM5LDQxLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDUwLDUxLDUzLDU4XSwkVnI9WzEsNjNdLCRWcz1bMSw2NF0sJFZ0PVs1LDIxLDIyLDIzLDI0LDI1LDI2LDI5LDM0LDM5LDQxLDQ4LDUxLDU4XSwkVnU9WzUsOSwxMCwyMSwyMiwyMywyNCwyNSwyNiwyOCwyOSwzNCwzNSwzOSw0MSw0Myw0OCw1MSw1Myw1OF0sJFZ2PVs1LDksMTAsMjEsMjIsMjMsMjQsMjUsMjYsMjgsMjksMzQsMzksNDEsNDgsNTEsNTMsNThdLCRWdz1bMzksNDEsNTBdO1xudmFyIHBhcnNlciA9IHt0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7IH0sXG55eToge30sXG5zeW1ib2xzXzoge1wiMFwiOjI5LFwiZXJyb3JcIjoyLFwiZVwiOjMsXCJtYXliZV9tdXNqZVwiOjQsXCJFT0ZcIjo1LFwic3BhY2VcIjo2LFwibWF5YmVfc3BhY2VcIjo3LFwibXVzamVcIjo4LFwiU1wiOjksXCJOTFwiOjEwLFwic2NvcmVfaGVhZFwiOjExLFwicGFydF9saXN0XCI6MTIsXCJ0aXRsZVwiOjEzLFwiVElUTEVcIjoxNCxcIkNPTVBPU0VSXCI6MTUsXCJwYXJ0XCI6MTYsXCJtZWFzdXJlX2xpc3RcIjoxNyxcImJhclwiOjE4LFwibWVhc3VyZVwiOjE5LFwibXVzaWNfZGF0YVwiOjIwLFwifFwiOjIxLFwifHxcIjoyMixcInxdXCI6MjMsXCJ8OlwiOjI0LFwiOnxcIjoyNSxcIjp8OlwiOjI2LFwic2x1cmFibGVcIjoyNyxcIlRJRVwiOjI4LFwibWF5YmVfZHVyYXRpb25cIjozMCxcInZvaWNlXCI6MzEsXCJ0aW1lX3NpZ25hdHVyZVwiOjMyLFwicGl0Y2hmdWxcIjozMyxcIihcIjozNCxcIilcIjozNSxcIm5vdGVcIjozNixcImNob3JkXCI6MzcsXCJwaXRjaFwiOjM4LFwiU1RFUFwiOjM5LFwiT0NUQVZFXCI6NDAsXCJBQ0NJREVOVEFMXCI6NDEsXCJ0eXBlX21vZGlmaWVyXCI6NDIsXCJET1RcIjo0MyxcIl9cIjo0NCxcIj1cIjo0NSxcIkhBTEZcIjo0NixcIldIT0xFXCI6NDcsXCI8XCI6NDgsXCJwaXRjaF9saXN0XCI6NDksXCI+XCI6NTAsXCJ7XCI6NTEsXCJ2b2ljZV9saXN0XCI6NTIsXCJ9XCI6NTMsXCJ2b2ljZV9kYXRhX2xpc3RcIjo1NCxcIjpcIjo1NSxcInZvaWNlX2RhdGFcIjo1NixcInJlc3RzbHVyYWJsZV9saXN0XCI6NTcsXCJCRUFUU1wiOjU4LFwiQkVBVF9UWVBFXCI6NTksXCIkYWNjZXB0XCI6MCxcIiRlbmRcIjoxfSxcbnRlcm1pbmFsc186IHsyOlwiZXJyb3JcIiw1OlwiRU9GXCIsOTpcIlNcIiwxMDpcIk5MXCIsMTQ6XCJUSVRMRVwiLDE1OlwiQ09NUE9TRVJcIiwyMTpcInxcIiwyMjpcInx8XCIsMjM6XCJ8XVwiLDI0OlwifDpcIiwyNTpcIjp8XCIsMjY6XCI6fDpcIiwyODpcIlRJRVwiLDI5OlwiMFwiLDM0OlwiKFwiLDM1OlwiKVwiLDM5OlwiU1RFUFwiLDQwOlwiT0NUQVZFXCIsNDE6XCJBQ0NJREVOVEFMXCIsNDM6XCJET1RcIiw0NDpcIl9cIiw0NTpcIj1cIiw0NjpcIkhBTEZcIiw0NzpcIldIT0xFXCIsNDg6XCI8XCIsNTA6XCI+XCIsNTE6XCJ7XCIsNTM6XCJ9XCIsNTQ6XCJ2b2ljZV9kYXRhX2xpc3RcIiw1NTpcIjpcIiw1NzpcInJlc3RzbHVyYWJsZV9saXN0XCIsNTg6XCJCRUFUU1wiLDU5OlwiQkVBVF9UWVBFXCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywyXSxbNCwwXSxbNCwyXSxbNCwzXSxbNCwxXSxbNiwxXSxbNiwxXSxbNywwXSxbNywyXSxbNywyXSxbOCwxXSxbOCwxXSxbOCwyXSxbMTEsMl0sWzEzLDFdLFsxMywyXSxbMTIsMV0sWzE2LDFdLFsxNiwzXSxbMTcsMV0sWzE3LDRdLFsxNywzXSxbMTksMl0sWzE5LDNdLFsxOCwxXSxbMTgsMV0sWzE4LDFdLFsxOCwxXSxbMTgsMV0sWzE4LDFdLFsyMCwxXSxbMjAsMl0sWzIwLDJdLFsyMCwxXSxbMjAsMV0sWzI3LDJdLFsyNywzXSxbMjcsM10sWzI3LDRdLFszMywxXSxbMzMsMV0sWzM2LDFdLFszOCwxXSxbMzgsMl0sWzM4LDJdLFszOCwzXSxbMzAsMF0sWzMwLDFdLFszMCwxXSxbMzAsMl0sWzQyLDFdLFs0MiwxXSxbNDIsMl0sWzQyLDJdLFs0MiwzXSxbNDIsM10sWzQyLDFdLFs0MiwxXSxbMzcsM10sWzQ5LDFdLFs0OSwyXSxbMzEsM10sWzUyLDFdLFs1MiwzXSxbNTYsMV0sWzU2LDJdLFszMiwyXV0sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sICQkIC8qIHZzdGFjayAqLywgXyQgLyogbHN0YWNrICovKSB7XG4vKiB0aGlzID09IHl5dmFsICovXG5cbnZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XG5zd2l0Y2ggKHl5c3RhdGUpIHtcbmNhc2UgMTpcbiByZXR1cm4gJCRbJDAtMV07IFxuYnJlYWs7XG5jYXNlIDI6IGNhc2UgMzpcbiB0aGlzLiQgPSBudWxsOyBcbmJyZWFrO1xuY2FzZSA0OiBjYXNlIDU6XG4gdGhpcy4kID0gJCRbJDBdOyByZW1vdmVMYXN0RW1wdHlNZWFzdXJlKCQkWyQwXSk7IFxuYnJlYWs7XG5jYXNlIDEwOlxuIHRoaXMuJCA9ICQkWyQwLTFdID8gJCRbJDAtMV0gKyAxIDogMTsgXG5icmVhaztcbmNhc2UgMTE6XG50aGlzLiQgPSB7IGhlYWQ6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDEyOlxudGhpcy4kID0geyBwYXJ0czogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgMTM6XG50aGlzLiQgPSB7IGhlYWQ6ICQkWyQwLTFdLCBwYXJ0czogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgMTU6XG4gdGhpcy4kID0geyB0aXRsZTogJCRbJDBdIH0gXG5icmVhaztcbmNhc2UgMTY6XG4gdGhpcy4kID0gIHsgdGl0bGU6ICQkWyQwLTFdLCBjb21wb3NlcjogJCRbJDBdIH0gXG5icmVhaztcbmNhc2UgMTc6IGNhc2UgNjA6IGNhc2UgNjM6XG50aGlzLiQgPSBbJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAxODpcbnRoaXMuJCA9IHsgbWVhc3VyZXM6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDE5OlxuIHRoaXMuJCA9IHsgbWVhc3VyZXM6ICQkWyQwXX07ICQkWyQwXVswXS5kYXRhLnVuc2hpZnQoeyBiYXI6ICQkWyQwLTJdIH0pOyBcbmJyZWFrO1xuY2FzZSAyMDpcbiB0aGlzLiQgPSBbJCRbJDBdXTsgXG5icmVhaztcbmNhc2UgMjE6XG4gdGhpcy4kID0gJCRbJDAtM107IGxhc3RJdGVtKCQkWyQwLTNdKS5kYXRhLnB1c2goeyBiYXI6ICQkWyQwLTJdIH0pOyAkJFskMC0zXS5wdXNoKCQkWyQwXSkgXG5icmVhaztcbmNhc2UgMjI6XG4gdGhpcy4kID0gJCRbJDAtMl07IGxhc3RJdGVtKCQkWyQwLTJdKS5kYXRhLnB1c2goeyBiYXI6ICQkWyQwLTFdIH0pOyAkJFskMC0yXS5wdXNoKHsgZGF0YTogW10gfSkgXG5icmVhaztcbmNhc2UgMjM6XG50aGlzLiQgPSB7IGRhdGE6IFskJFskMC0xXV0gfTtcbmJyZWFrO1xuY2FzZSAyNDpcbiB0aGlzLiQgPSAkJFskMC0yXTsgJCRbJDAtMl0uZGF0YS5wdXNoKCQkWyQwLTFdKSBcbmJyZWFrO1xuY2FzZSAyNTpcbnRoaXMuJCA9ICdzaW5nbGUnO1xuYnJlYWs7XG5jYXNlIDI2OlxudGhpcy4kID0gJ2RvdWJsZSc7XG5icmVhaztcbmNhc2UgMjc6XG50aGlzLiQgPSAnZW5kJztcbmJyZWFrO1xuY2FzZSAyODpcbnRoaXMuJCA9ICdyZXBlYXQtYmVnaW4nO1xuYnJlYWs7XG5jYXNlIDI5OlxudGhpcy4kID0gJ3JlcGVhdC1lbmQnO1xuYnJlYWs7XG5jYXNlIDMwOlxudGhpcy4kID0gJ3JlcGVhdC1ib3RoJztcbmJyZWFrO1xuY2FzZSAzMjpcbiB0aGlzLiQgPSAkJFskMC0xXTsgb25seVByb3BlcnR5KCQkWyQwLTFdKS50aWUgPSAnficgXG5icmVhaztcbmNhc2UgMzM6XG50aGlzLiQgPSB7IHJlc3Q6IHsgZHVyYXRpb246ICQkWyQwXSB9IH07XG5icmVhaztcbmNhc2UgMzQ6XG50aGlzLiQgPSB7IHZvaWNlOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAzNjpcbiB0aGlzLiQgPSAkJFskMC0xXTsgb25seVByb3BlcnR5KCQkWyQwLTFdKS5kdXJhdGlvbiA9ICQkWyQwXSBcbmJyZWFrO1xuY2FzZSAzNzpcblxuICAgICAgdGhpcy4kID0gJCRbJDAtMV07XG4gICAgICBleHRlbmQob25seVByb3BlcnR5KCQkWyQwLTFdKSwge1xuICAgICAgICBkdXJhdGlvbjogJCRbJDBdLFxuICAgICAgICBzbHVyOiB7IGJlZ2luOiAnc29saWQnIH1cbiAgICAgIH0pXG4gICAgXG5icmVhaztcbmNhc2UgMzg6XG5cbiAgICAgIHRoaXMuJCA9ICQkWyQwLTJdXG4gICAgICBleHRlbmQob25seVByb3BlcnR5KCQkWyQwLTJdKSwge1xuICAgICAgICBkdXJhdGlvbjogJCRbJDAtMV0sXG4gICAgICAgIHNsdXI6IHsgZW5kOiAnc29saWQnIH1cbiAgICAgIH0pXG4gICAgXG5icmVhaztcbmNhc2UgMzk6XG5cbiAgICAgIHRoaXMuJCA9ICQkWyQwLTJdXG4gICAgICBleHRlbmQob25seVByb3BlcnR5KCQkWyQwLTJdKSwge1xuICAgICAgICBkdXJhdGlvbjogJCRbJDAtMV0sXG4gICAgICAgIHNsdXI6IHsgYmVnaW46ICdzb2xpZCcsIGVuZDogJ3NvbGlkJyB9XG4gICAgICB9KVxuICAgIFxuYnJlYWs7XG5jYXNlIDQwOlxudGhpcy4kID0geyBub3RlOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0MTpcbnRoaXMuJCA9IHsgY2hvcmQ6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDQyOlxudGhpcy4kID0geyBwaXRjaDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgNDM6XG50aGlzLiQgPSB7IHN0ZXA6ICskJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0NDpcbnRoaXMuJCA9IHsgc3RlcDogKyQkWyQwLTFdLCBvY3RhdmU6IG9jdGF2ZSgkJFskMF0pIH07XG5icmVhaztcbmNhc2UgNDU6XG50aGlzLiQgPSB7IGFjY2lkZW50YWw6ICQkWyQwLTFdLCBzdGVwOiArJCRbJDBdIH07XG5icmVhaztcbmNhc2UgNDY6XG50aGlzLiQgPSB7IGFjY2lkZW50YWw6ICQkWyQwLTJdLCBzdGVwOiArJCRbJDAtMV0sIG9jdGF2ZTogb2N0YXZlKCQkWyQwXSkgfTtcbmJyZWFrO1xuY2FzZSA0ODpcbnRoaXMuJCA9IHsgdHlwZTogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgNDk6XG50aGlzLiQgPSB7IHR5cGU6IDQsIGRvdDogJCRbJDBdLmxlbmd0aCB9O1xuYnJlYWs7XG5jYXNlIDUwOlxudGhpcy4kID0geyB0eXBlOiAkJFskMC0xXSwgZG90OiAkJFskMF0ubGVuZ3RoIH07XG5icmVhaztcbmNhc2UgNTE6XG50aGlzLiQgPSA4O1xuYnJlYWs7XG5jYXNlIDUyOlxudGhpcy4kID0gMTY7XG5icmVhaztcbmNhc2UgNTM6XG50aGlzLiQgPSAzMjtcbmJyZWFrO1xuY2FzZSA1NDpcbnRoaXMuJCA9IDY0O1xuYnJlYWs7XG5jYXNlIDU1OlxudGhpcy4kID0gMTI4O1xuYnJlYWs7XG5jYXNlIDU2OlxudGhpcy4kID0gMjU2O1xuYnJlYWs7XG5jYXNlIDU3OlxudGhpcy4kID0gMjtcbmJyZWFrO1xuY2FzZSA1ODpcbnRoaXMuJCA9IDE7XG5icmVhaztcbmNhc2UgNTk6XG50aGlzLiQgPSB7IHBpdGNoZXM6ICQkWyQwLTFdIH07XG5icmVhaztcbmNhc2UgNjE6IGNhc2UgNjY6XG4gdGhpcy4kID0gJCRbJDAtMV07ICQkWyQwLTFdLnB1c2goJCRbJDBdKSBcbmJyZWFrO1xuY2FzZSA2MjpcbnRoaXMuJCA9ICQkWyQwLTFdO1xuYnJlYWs7XG5jYXNlIDY0OlxuIHRoaXMuJCA9ICQkWyQwLTJdOyAkJFskMC0yXS5wdXNoKCQkWyQwLTFdKSBcbmJyZWFrO1xuY2FzZSA2NzpcbnRoaXMuJCA9IHsgdGltZTogeyBiZWF0czogKyQkWyQwLTFdLCBiZWF0VHlwZTogKyQkWyQwXSB9IH07XG5icmVhaztcbn1cbn0sXG50YWJsZTogW3szOjEsNDoyLDU6WzIsMl0sNjozLDg6NCw5OlsxLDVdLDEwOlsxLDZdLDExOjcsMTI6OCwxMzo5LDE0OiRWMCwxNjoxMCwxNzoxMiwxODoxMywxOToxNCwyMDoyMSwyMTokVjEsMjI6JFYyLDIzOiRWMywyNDokVjQsMjU6JFY1LDI2OiRWNiwyNzoyMiwyOTokVjcsMzE6MjQsMzI6MjUsMzM6MjYsMzQ6JFY4LDM2OjMwLDM3OjMxLDM4OjMyLDM5OiRWOSw0MTokVmEsNDg6JFZiLDUxOiRWYyw1ODokVmR9LHsxOlszXX0sezU6WzEsMzZdfSxvKCRWZSwkVmYsezc6Mzd9KSx7NTpbMiw1XX0sbygkVmUsWzIsNl0pLG8oJFZlLFsyLDddKSx7NTpbMiwxMV0sMTI6MzgsMTY6MTAsMTc6MTIsMTg6MTMsMTk6MTQsMjA6MjEsMjE6JFYxLDIyOiRWMiwyMzokVjMsMjQ6JFY0LDI1OiRWNSwyNjokVjYsMjc6MjIsMjk6JFY3LDMxOjI0LDMyOjI1LDMzOjI2LDM0OiRWOCwzNjozMCwzNzozMSwzODozMiwzOTokVjksNDE6JFZhLDQ4OiRWYiw1MTokVmMsNTg6JFZkfSx7NTpbMiwxMl19LG8oJFZnLCRWZix7NzozOX0pLHs1OlsyLDE3XX0sbygkVmcsWzIsMTVdLHsxNTpbMSw0MF19KSx7NTpbMiwxOF0sMTg6NDEsMjE6JFYxLDIyOiRWMiwyMzokVjMsMjQ6JFY0LDI1OiRWNSwyNjokVjZ9LG8oWzksMTAsMjksMzQsMzksNDEsNDgsNTEsNThdLCRWZix7Nzo0Mn0pLG8oJFZoLFsyLDIwXSx7Mjc6MjIsMzE6MjQsMzI6MjUsMzM6MjYsMzY6MzAsMzc6MzEsMzg6MzIsMjA6NDMsMjk6JFY3LDM0OiRWOCwzOTokVjksNDE6JFZhLDQ4OiRWYiw1MTokVmMsNTg6JFZkfSksbygkVmcsWzIsMjVdKSxvKCRWZyxbMiwyNl0pLG8oJFZnLFsyLDI3XSksbygkVmcsWzIsMjhdKSxvKCRWZyxbMiwyOV0pLG8oJFZnLFsyLDMwXSksbygkVmcsJFZmLHs3OjQ0fSksbygkVmcsWzIsMzFdLHsyODpbMSw0NV19KSxvKCRWZywkVmksezMwOjQ2LDQyOjQ3LDQzOiRWaiw0NDokVmssNDU6JFZsLDQ2OiRWbSw0NzokVm59KSxvKCRWZyxbMiwzNF0pLG8oJFZnLFsyLDM1XSksbygkVm8sJFZpLHs0Mjo0NywzMDo1Myw0MzokVmosNDQ6JFZrLDQ1OiRWbCw0NjokVm0sNDc6JFZufSksezMzOjU0LDM2OjMwLDM3OjMxLDM4OjMyLDM5OiRWOSw0MTokVmEsNDg6JFZifSx7NTI6NTUsNTQ6WzEsNTZdfSx7NTk6WzEsNTddfSxvKCRWcCxbMiw0MF0pLG8oJFZwLFsyLDQxXSksbygkVnAsWzIsNDJdKSx7Mzg6NTksMzk6JFY5LDQxOiRWYSw0OTo1OH0sbygkVnEsWzIsNDNdLHs0MDpbMSw2MF19KSx7Mzk6WzEsNjFdfSx7MTpbMiwxXX0sezU6WzIsM10sODo2Miw5OiRWciwxMDokVnMsMTE6NywxMjo4LDEzOjksMTQ6JFYwLDE2OjEwLDE3OjEyLDE4OjEzLDE5OjE0LDIwOjIxLDIxOiRWMSwyMjokVjIsMjM6JFYzLDI0OiRWNCwyNTokVjUsMjY6JFY2LDI3OjIyLDI5OiRWNywzMToyNCwzMjoyNSwzMzoyNiwzNDokVjgsMzY6MzAsMzc6MzEsMzg6MzIsMzk6JFY5LDQxOiRWYSw0ODokVmIsNTE6JFZjLDU4OiRWZH0sezU6WzIsMTNdfSxvKCRWdCxbMiwxNF0sezk6JFZyLDEwOiRWc30pLG8oJFZnLFsyLDE2XSksbygkVmcsJFZmLHs3OjY1fSksezk6JFZyLDEwOiRWcywxNzo2NiwxOToxNCwyMDoyMSwyNzoyMiwyOTokVjcsMzE6MjQsMzI6MjUsMzM6MjYsMzQ6JFY4LDM2OjMwLDM3OjMxLDM4OjMyLDM5OiRWOSw0MTokVmEsNDg6JFZiLDUxOiRWYyw1ODokVmR9LG8oJFZnLCRWZix7Nzo2N30pLG8oJFZ0LFsyLDIzXSx7OTokVnIsMTA6JFZzfSksbygkVmcsWzIsMzJdKSxvKCRWZyxbMiwzM10pLG8oJFZvLFsyLDQ4XSx7NDM6WzEsNjhdfSksbygkVm8sWzIsNDldKSxvKCRWdSxbMiw1MV0pLG8oJFZ1LFsyLDUyXSx7NDQ6WzEsNjldLDQ1OlsxLDcwXX0pLG8oJFZ1LFsyLDU3XSksbygkVnUsWzIsNThdKSxvKCRWdixbMiwzNl0sezM1OlsxLDcxXX0pLG8oJFZvLCRWaSx7NDI6NDcsMzA6NzIsNDM6JFZqLDQ0OiRWayw0NTokVmwsNDY6JFZtLDQ3OiRWbn0pLHs1MzpbMSw3M119LHs1MzpbMiw2M10sNTU6WzEsNzRdfSxvKCRWZyxbMiw2N10pLHszODo3NiwzOTokVjksNDE6JFZhLDUwOlsxLDc1XX0sbygkVncsWzIsNjBdKSxvKCRWcSxbMiw0NF0pLG8oJFZxLFsyLDQ1XSx7NDA6WzEsNzddfSksezU6WzIsNF19LG8oJFZlLFsyLDldKSxvKCRWZSxbMiwxMF0pLG8oJFZoLFsyLDIyXSx7MjA6MjEsMjc6MjIsMzE6MjQsMzI6MjUsMzM6MjYsMzY6MzAsMzc6MzEsMzg6MzIsMTk6NzgsOTokVnIsMTA6JFZzLDI5OiRWNywzNDokVjgsMzk6JFY5LDQxOiRWYSw0ODokVmIsNTE6JFZjLDU4OiRWZH0pLHs1OlsyLDE5XSwxODo0MSwyMTokVjEsMjI6JFYyLDIzOiRWMywyNDokVjQsMjU6JFY1LDI2OiRWNn0sbygkVnQsWzIsMjRdLHs5OiRWciwxMDokVnN9KSxvKCRWbyxbMiw1MF0pLG8oJFZ1LFsyLDUzXSksbygkVnUsWzIsNTRdLHs0NDpbMSw3OV0sNDU6WzEsODBdfSksbygkVnYsWzIsMzhdKSxvKCRWdixbMiwzN10sezM1OlsxLDgxXX0pLG8oJFZnLFsyLDYyXSksezI3OjgzLDMzOjI2LDM0OiRWOCwzNjozMCwzNzozMSwzODozMiwzOTokVjksNDE6JFZhLDQ4OiRWYiw1Njo4Miw1NzpbMSw4NF19LG8oJFZwLFsyLDU5XSksbygkVncsWzIsNjFdKSxvKCRWcSxbMiw0Nl0pLG8oJFZoLFsyLDIxXSx7Mjc6MjIsMzE6MjQsMzI6MjUsMzM6MjYsMzY6MzAsMzc6MzEsMzg6MzIsMjA6NDMsMjk6JFY3LDM0OiRWOCwzOTokVjksNDE6JFZhLDQ4OiRWYiw1MTokVmMsNTg6JFZkfSksbygkVnUsWzIsNTVdKSxvKCRWdSxbMiw1Nl0pLG8oJFZ2LFsyLDM5XSksezUzOlsyLDY0XX0sezUzOlsyLDY1XX0sezI3Ojg1LDMzOjI2LDM0OiRWOCwzNjozMCwzNzozMSwzODozMiwzOTokVjksNDE6JFZhLDQ4OiRWYn0sezUzOlsyLDY2XX1dLFxuZGVmYXVsdEFjdGlvbnM6IHs0OlsyLDVdLDg6WzIsMTJdLDEwOlsyLDE3XSwzNjpbMiwxXSwzODpbMiwxM10sNjI6WzIsNF0sODI6WzIsNjRdLDgzOlsyLDY1XSw4NTpbMiw2Nl19LFxucGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICBpZiAoaGFzaC5yZWNvdmVyYWJsZSkge1xuICAgICAgICB0aGlzLnRyYWNlKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZnVuY3Rpb24gX3BhcnNlRXJyb3IgKG1zZywgaGFzaCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICAgICAgICAgICAgdGhpcy5oYXNoID0gaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBfcGFyc2VFcnJvci5wcm90b3R5cGUgPSBFcnJvcjtcblxuICAgICAgICB0aHJvdyBuZXcgX3BhcnNlRXJyb3Ioc3RyLCBoYXNoKTtcbiAgICB9XG59LFxucGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBzdGFjayA9IFswXSwgdHN0YWNrID0gW10sIHZzdGFjayA9IFtudWxsXSwgbHN0YWNrID0gW10sIHRhYmxlID0gdGhpcy50YWJsZSwgeXl0ZXh0ID0gJycsIHl5bGluZW5vID0gMCwgeXlsZW5nID0gMCwgcmVjb3ZlcmluZyA9IDAsIFRFUlJPUiA9IDIsIEVPRiA9IDE7XG4gICAgdmFyIGFyZ3MgPSBsc3RhY2suc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBsZXhlciA9IE9iamVjdC5jcmVhdGUodGhpcy5sZXhlcik7XG4gICAgdmFyIHNoYXJlZFN0YXRlID0geyB5eToge30gfTtcbiAgICBmb3IgKHZhciBrIGluIHRoaXMueXkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnl5LCBrKSkge1xuICAgICAgICAgICAgc2hhcmVkU3RhdGUueXlba10gPSB0aGlzLnl5W2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxleGVyLnNldElucHV0KGlucHV0LCBzaGFyZWRTdGF0ZS55eSk7XG4gICAgc2hhcmVkU3RhdGUueXkubGV4ZXIgPSBsZXhlcjtcbiAgICBzaGFyZWRTdGF0ZS55eS5wYXJzZXIgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgbGV4ZXIueXlsbG9jID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxleGVyLnl5bGxvYyA9IHt9O1xuICAgIH1cbiAgICB2YXIgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgbHN0YWNrLnB1c2goeXlsb2MpO1xuICAgIHZhciByYW5nZXMgPSBsZXhlci5vcHRpb25zICYmIGxleGVyLm9wdGlvbnMucmFuZ2VzO1xuICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5wYXJzZUVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BTdGFjayhuKSB7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDIgKiBuO1xuICAgICAgICB2c3RhY2subGVuZ3RoID0gdnN0YWNrLmxlbmd0aCAtIG47XG4gICAgICAgIGxzdGFjay5sZW5ndGggPSBsc3RhY2subGVuZ3RoIC0gbjtcbiAgICB9XG4gICAgX3Rva2VuX3N0YWNrOlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5sZXgoKSB8fCBFT0Y7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRva2VuID0gc2VsZi5zeW1ib2xzX1t0b2tlbl0gfHwgdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH07XG4gICAgdmFyIHN5bWJvbCwgcHJlRXJyb3JTeW1ib2wsIHN0YXRlLCBhY3Rpb24sIGEsIHIsIHl5dmFsID0ge30sIHAsIGxlbiwgbmV3U3RhdGUsIGV4cGVjdGVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xuICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXTtcbiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJTdHIgPSAnJztcbiAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gVEVSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKCdcXCcnICsgdGhpcy50ZXJtaW5hbHNfW3BdICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzpcXG4nICsgbGV4ZXIuc2hvd1Bvc2l0aW9uKCkgKyAnXFxuRXhwZWN0aW5nICcgKyBleHBlY3RlZC5qb2luKCcsICcpICsgJywgZ290IFxcJycgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArICdcXCcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6IFVuZXhwZWN0ZWQgJyArIChzeW1ib2wgPT0gRU9GID8gJ2VuZCBvZiBpbnB1dCcgOiAnXFwnJyArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoZXJyU3RyLCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBsZXhlci55eWxpbmVubyxcbiAgICAgICAgICAgICAgICAgICAgbG9jOiB5eWxvYyxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogJyArIHN0YXRlICsgJywgdG9rZW46ICcgKyBzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgIHZzdGFjay5wdXNoKGxleGVyLnl5dGV4dCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaChsZXhlci55eWxsb2MpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pO1xuICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghcHJlRXJyb3JTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICB5eWxlbmcgPSBsZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgIHl5bGluZW5vID0gbGV4ZXIueXlsaW5lbm87XG4gICAgICAgICAgICAgICAgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgICAgICAgICAgICAgaWYgKHJlY292ZXJpbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY292ZXJpbmctLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHByZUVycm9yU3ltYm9sO1xuICAgICAgICAgICAgICAgIHByZUVycm9yU3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xuICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoIC0gbGVuXTtcbiAgICAgICAgICAgIHl5dmFsLl8kID0ge1xuICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9jb2x1bW5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgeXl2YWwuXyQucmFuZ2UgPSBbXG4gICAgICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0ucmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ucmFuZ2VbMV1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbi5hcHBseSh5eXZhbCwgW1xuICAgICAgICAgICAgICAgIHl5dGV4dCxcbiAgICAgICAgICAgICAgICB5eWxlbmcsXG4gICAgICAgICAgICAgICAgeXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgc2hhcmVkU3RhdGUueXksXG4gICAgICAgICAgICAgICAgYWN0aW9uWzFdLFxuICAgICAgICAgICAgICAgIHZzdGFjayxcbiAgICAgICAgICAgICAgICBsc3RhY2tcbiAgICAgICAgICAgIF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIC0xICogbGVuICogMik7XG4gICAgICAgICAgICAgICAgdnN0YWNrID0gdnN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgICAgICBsc3RhY2sgPSBsc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzBdKTtcbiAgICAgICAgICAgIHZzdGFjay5wdXNoKHl5dmFsLiQpO1xuICAgICAgICAgICAgbHN0YWNrLnB1c2goeXl2YWwuXyQpO1xuICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzdGFja1tzdGFjay5sZW5ndGggLSAyXV1bc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1dO1xuICAgICAgICAgICAgc3RhY2sucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59fTtcblxuXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCcuLi91dGlsJykuZXh0ZW5kXG5cbmNvbnN0IGxhc3RJdGVtID0gYXJyID0+IGFyclthcnIubGVuZ3RoIC0gMV1cblxuY29uc3Qgb25seVByb3BlcnR5ID0gb2JqID0+IG9ialtPYmplY3Qua2V5cyhvYmopWzBdXVxuXG5jb25zdCBvY3RhdmUgPSBzdHIgPT4ge1xuICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoXG4gIHJldHVybiBzdHIuY2hhckF0KDApID09PSAnLCcgPyAtbGVuIDogbGVuXG59XG5cbmNvbnN0IHJlbW92ZUxhc3RFbXB0eU1lYXN1cmUgPSBzY29yZSA9PiB7XG4gIGNvbnN0IHBhcnRzID0gc2NvcmUucGFydHNcbiAgaWYgKCFwYXJ0cykgcmV0dXJuXG5cbiAgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICBjb25zdCBsYXN0TWVhc3VyZSA9IGxhc3RJdGVtKHBhcnQubWVhc3VyZXMpXG4gICAgaWYgKGxhc3RNZWFzdXJlLmRhdGEubGVuZ3RoID09PSAwKSBwYXJ0Lm1lYXN1cmVzLnBvcCgpXG4gIH0pXG59XG5cbi8qIGdlbmVyYXRlZCBieSBqaXNvbi1sZXggMC4zLjQgKi9cbnZhciBsZXhlciA9IChmdW5jdGlvbigpe1xudmFyIGxleGVyID0gKHtcblxuRU9GOjEsXG5cbnBhcnNlRXJyb3I6ZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICAgICAgaWYgKHRoaXMueXkucGFyc2VyKSB7XG4gICAgICAgICAgICB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJlc2V0cyB0aGUgbGV4ZXIsIHNldHMgbmV3IGlucHV0XG5zZXRJbnB1dDpmdW5jdGlvbiAoaW5wdXQsIHl5KSB7XG4gICAgICAgIHRoaXMueXkgPSB5eSB8fCB0aGlzLnl5IHx8IHt9O1xuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9tb3JlID0gdGhpcy5fYmFja3RyYWNrID0gdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMueXlsaW5lbm8gPSB0aGlzLnl5bGVuZyA9IDA7XG4gICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrID0gWydJTklUSUFMJ107XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogMCxcbiAgICAgICAgICAgIGxhc3RfbGluZTogMSxcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFswLDBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gY29uc3VtZXMgYW5kIHJldHVybnMgb25lIGNoYXIgZnJvbSB0aGUgaW5wdXRcbmlucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbMF07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IGNoO1xuICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICB0aGlzLm1hdGNoICs9IGNoO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gY2g7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcbiAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vKys7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSxcblxuLy8gdW5zaGlmdHMgb25lIGNoYXIgKG9yIGEgc3RyaW5nKSBpbnRvIHRoZSBpbnB1dFxudW5wdXQ6ZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGggLSBsZW4pO1xuICAgICAgICAvL3RoaXMueXlsZW5nIC09IGxlbjtcbiAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgICB2YXIgb2xkTGluZXMgPSB0aGlzLm1hdGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSAxKTtcblxuICAgICAgICBpZiAobGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gdGhpcy55eWxsb2MucmFuZ2U7XG5cbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID9cbiAgICAgICAgICAgICAgICAobGluZXMubGVuZ3RoID09PSBvbGRMaW5lcy5sZW5ndGggPyB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gOiAwKVxuICAgICAgICAgICAgICAgICArIG9sZExpbmVzW29sZExpbmVzLmxlbmd0aCAtIGxpbmVzLmxlbmd0aF0ubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoIDpcbiAgICAgICAgICAgICAgdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIC0gbGVuXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3JbMF0sIHJbMF0gKyB0aGlzLnl5bGVuZyAtIGxlbl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBjYWNoZXMgbWF0Y2hlZCB0ZXh0IGFuZCBhcHBlbmRzIGl0IG9uIG5leHQgYWN0aW9uXG5tb3JlOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBzaWduYWxzIHRoZSBsZXhlciB0aGF0IHRoaXMgcnVsZSBmYWlscyB0byBtYXRjaCB0aGUgaW5wdXQsIHNvIHRoZSBuZXh0IG1hdGNoaW5nIHJ1bGUgKHJlZ2V4KSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG5yZWplY3Q6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKSArICcuIFlvdSBjYW4gb25seSBpbnZva2UgcmVqZWN0KCkgaW4gdGhlIGxleGVyIHdoZW4gdGhlIGxleGVyIGlzIG9mIHRoZSBiYWNrdHJhY2tpbmcgcGVyc3Vhc2lvbiAob3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIgPSB0cnVlKS5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyByZXRhaW4gZmlyc3QgbiBjaGFyYWN0ZXJzIG9mIHRoZSBtYXRjaFxubGVzczpmdW5jdGlvbiAobikge1xuICAgICAgICB0aGlzLnVucHV0KHRoaXMubWF0Y2guc2xpY2UobikpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIGFscmVhZHkgbWF0Y2hlZCBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnBhc3RJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXN0ID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gdGhpcy5tYXRjaC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHBhc3QubGVuZ3RoID4gMjAgPyAnLi4uJzonJykgKyBwYXN0LnN1YnN0cigtMjApLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyB1cGNvbWluZyBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnVwY29taW5nSW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XG4gICAgICAgIGlmIChuZXh0Lmxlbmd0aCA8IDIwKSB7XG4gICAgICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cigwLCAyMC1uZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuZXh0LnN1YnN0cigwLDIwKSArIChuZXh0Lmxlbmd0aCA+IDIwID8gJy4uLicgOiAnJykpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRoZSBsZXhpbmcgZXJyb3Igb2NjdXJyZWQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG5zaG93UG9zaXRpb246ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJlID0gdGhpcy5wYXN0SW5wdXQoKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oXCItXCIpO1xuICAgICAgICByZXR1cm4gcHJlICsgdGhpcy51cGNvbWluZ0lucHV0KCkgKyBcIlxcblwiICsgYyArIFwiXlwiO1xuICAgIH0sXG5cbi8vIHRlc3QgdGhlIGxleGVkIHRva2VuOiByZXR1cm4gRkFMU0Ugd2hlbiBub3QgYSBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiB0b2tlblxudGVzdF9tYXRjaDpmdW5jdGlvbiAobWF0Y2gsIGluZGV4ZWRfcnVsZSkge1xuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICAgIGJhY2t1cDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgLy8gc2F2ZSBjb250ZXh0XG4gICAgICAgICAgICBiYWNrdXAgPSB7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm86IHRoaXMueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgeXlsbG9jOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogdGhpcy5tYXRjaGVzLFxuICAgICAgICAgICAgICAgIG1hdGNoZWQ6IHRoaXMubWF0Y2hlZCxcbiAgICAgICAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgX21vcmU6IHRoaXMuX21vcmUsXG4gICAgICAgICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCxcbiAgICAgICAgICAgICAgICB5eTogdGhpcy55eSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb25TdGFjazogdGhpcy5jb25kaXRpb25TdGFjay5zbGljZSgwKSxcbiAgICAgICAgICAgICAgICBkb25lOiB0aGlzLmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgICAgIGJhY2t1cC55eWxsb2MucmFuZ2UgPSB0aGlzLnl5bGxvYy5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3RoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArPSB0aGlzLnl5bGVuZ107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgaW5kZXhlZF9ydWxlLCB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgIC8vIHJlY292ZXIgY29udGV4dFxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gYmFja3VwW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgdGhlIG5leHQgcnVsZSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbi8vIHJldHVybiBuZXh0IG1hdGNoIGluIGlucHV0XG5uZXh0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHRlbXBNYXRjaCxcbiAgICAgICAgICAgIGluZGV4O1xuICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMucnVsZXNbcnVsZXNbaV1dKTtcbiAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaCh0ZW1wTWF0Y2gsIHJ1bGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgYSBydWxlIE1JU21hdGNoLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2gobWF0Y2gsIHJ1bGVzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmV0dXJuIG5leHQgbWF0Y2ggdGhhdCBoYXMgYSB0b2tlblxubGV4OmZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV4KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBhY3RpdmF0ZXMgYSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIChwdXNoZXMgdGhlIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgb250byB0aGUgY29uZGl0aW9uIHN0YWNrKVxuYmVnaW46ZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xuICAgIH0sXG5cbi8vIHBvcCB0aGUgcHJldmlvdXNseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9mZiB0aGUgY29uZGl0aW9uIHN0YWNrXG5wb3BTdGF0ZTpmdW5jdGlvbiBwb3BTdGF0ZSgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1swXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHByb2R1Y2UgdGhlIGxleGVyIHJ1bGUgc2V0IHdoaWNoIGlzIGFjdGl2ZSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlXG5fY3VycmVudFJ1bGVzOmZ1bmN0aW9uIF9jdXJyZW50UnVsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAmJiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdXS5ydWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbXCJJTklUSUFMXCJdLnJ1bGVzO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmV0dXJuIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZTsgd2hlbiBhbiBpbmRleCBhcmd1bWVudCBpcyBwcm92aWRlZCBpdCBwcm9kdWNlcyB0aGUgTi10aCBwcmV2aW91cyBjb25kaXRpb24gc3RhdGUsIGlmIGF2YWlsYWJsZVxudG9wU3RhdGU6ZnVuY3Rpb24gdG9wU3RhdGUobikge1xuICAgICAgICBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxIC0gTWF0aC5hYnMobiB8fCAwKTtcbiAgICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJTklUSUFMXCI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBhbGlhcyBmb3IgYmVnaW4oY29uZGl0aW9uKVxucHVzaFN0YXRlOmZ1bmN0aW9uIHB1c2hTdGF0ZShjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5iZWdpbihjb25kaXRpb24pO1xuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgbnVtYmVyIG9mIHN0YXRlcyBjdXJyZW50bHkgb24gdGhlIHN0YWNrXG5zdGF0ZVN0YWNrU2l6ZTpmdW5jdGlvbiBzdGF0ZVN0YWNrU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoO1xuICAgIH0sXG5vcHRpb25zOiB7fSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eSx5eV8sJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucyxZWV9TVEFSVCkge1xudmFyIFlZU1RBVEU9WVlfU1RBUlQ7XG5zd2l0Y2goJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucykge1xuY2FzZSAwOnJldHVybiA5XG5icmVhaztcbmNhc2UgMTpyZXR1cm4gOVxuYnJlYWs7XG5jYXNlIDI6cmV0dXJuIDlcbmJyZWFrO1xuY2FzZSAzOiB0aGlzLmJlZ2luKCd0aXRsZScpIFxuYnJlYWs7XG5jYXNlIDQ6IHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cigwLCB5eV8ueXlsZW5nIC0gMikudHJpbSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNCBcbmJyZWFrO1xuY2FzZSA1OiB0aGlzLmJlZ2luKCdJTklUSUFMJykgXG5icmVhaztcbmNhc2UgNjogdGhpcy5iZWdpbignSU5JVElBTCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnRyaW0oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTUgXG5icmVhaztcbmNhc2UgNzogdGhpcy5iZWdpbigndGltZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cigwLCB5eV8ueXlsZW5nIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDU4IFxuYnJlYWs7XG5jYXNlIDg6IHRoaXMuYmVnaW4oJ0lOSVRJQUwnKTsgcmV0dXJuIDU5IFxuYnJlYWs7XG5jYXNlIDk6cmV0dXJuIDQxXG5icmVhaztcbmNhc2UgMTA6cmV0dXJuIDM5XG5icmVhaztcbmNhc2UgMTE6cmV0dXJuIDQwXG5icmVhaztcbmNhc2UgMTI6cmV0dXJuIDQzXG5icmVhaztcbmNhc2UgMTM6cmV0dXJuIDQ3XG5icmVhaztcbmNhc2UgMTQ6cmV0dXJuIDQ2XG5icmVhaztcbmNhc2UgMTU6cmV0dXJuIDI4XG5icmVhaztcbmNhc2UgMTY6cmV0dXJuIDQ0XG5icmVhaztcbmNhc2UgMTc6cmV0dXJuIDQ1XG5icmVhaztcbmNhc2UgMTg6cmV0dXJuICcuJ1xuYnJlYWs7XG5jYXNlIDE5OnJldHVybiAyOVxuYnJlYWs7XG5jYXNlIDIwOnJldHVybiA0OFxuYnJlYWs7XG5jYXNlIDIxOnJldHVybiA1MFxuYnJlYWs7XG5jYXNlIDIyOnJldHVybiAzNFxuYnJlYWs7XG5jYXNlIDIzOnJldHVybiAzNVxuYnJlYWs7XG5jYXNlIDI0OnJldHVybiAnLydcbmJyZWFrO1xuY2FzZSAyNTpyZXR1cm4gJ1xcXFwnXG5icmVhaztcbmNhc2UgMjY6cmV0dXJuIDIzXG5icmVhaztcbmNhc2UgMjc6cmV0dXJuIDIyXG5icmVhaztcbmNhc2UgMjg6cmV0dXJuICdbfCdcbmJyZWFrO1xuY2FzZSAyOTpyZXR1cm4gMjRcbmJyZWFrO1xuY2FzZSAzMDpyZXR1cm4gMjZcbmJyZWFrO1xuY2FzZSAzMTpyZXR1cm4gMjVcbmJyZWFrO1xuY2FzZSAzMjpyZXR1cm4gMjFcbmJyZWFrO1xuY2FzZSAzMzpyZXR1cm4gNTFcbmJyZWFrO1xuY2FzZSAzNDpyZXR1cm4gNTNcbmJyZWFrO1xuY2FzZSAzNTpyZXR1cm4gNTVcbmJyZWFrO1xuY2FzZSAzNjpyZXR1cm4gMTBcbmJyZWFrO1xuY2FzZSAzNzpyZXR1cm4gOVxuYnJlYWs7XG5jYXNlIDM4OnJldHVybiA1XG5icmVhaztcbmNhc2UgMzk6cmV0dXJuICdJTlZBTElEJ1xuYnJlYWs7XG59XG59LFxucnVsZXM6IFsvXig/OlxcL1xcL1teXFxuXSopLywvXig/OlxcL1xcKihbXFxzXFxTXSo/KVxcKlxcLykvLC9eKD86XFwvXFwqW1xcc1xcU10qKS8sL14oPzo8PCkvLC9eKD86Lio+PikvLC9eKD86KFsgXFx0XSkqKFtcXG5cXHJdKSkvLC9eKD86LiopLywvXig/OigoWzEtOV1cXGR7MCwyfSlcXC8pKS8sL14oPzooWzEtOV1cXGR7MCwyfSlbXlxcZF0pLywvXig/OigjezEsMn18bnxiezEsMn0pKS8sL14oPzpbMS03XSkvLC9eKD86LCt8JyspLywvXig/OlxcLispLywvXig/OiggKi0gKil7M30pLywvXig/OiggKi0gKikpLywvXig/OiAqfikvLC9eKD86W19dKS8sL14oPzo9KS8sL14oPzpcXC4pLywvXig/OlswXSkvLC9eKD86PCkvLC9eKD86PikvLC9eKD86XFwoKS8sL14oPzpcXCkpLywvXig/OlxcLykvLC9eKD86XFxcXCkvLC9eKD86XFx8XFxdKS8sL14oPzpcXHxcXHwpLywvXig/OlxcW1xcfCkvLC9eKD86XFx8OikvLC9eKD86OlxcfDopLywvXig/OjpcXHwpLywvXig/OlxcfCkvLC9eKD86XFx7KS8sL14oPzpcXH0pLywvXig/OjopLywvXig/OihbXFxuXFxyXSkpLywvXig/OihbIFxcdF0pKS8sL14oPzokKS8sL14oPzouKS9dLFxuY29uZGl0aW9uczoge1widGltZVwiOntcInJ1bGVzXCI6WzhdLFwiaW5jbHVzaXZlXCI6ZmFsc2V9LFwidGl0bGVcIjp7XCJydWxlc1wiOls0LDUsNl0sXCJpbmNsdXNpdmVcIjpmYWxzZX0sXCJJTklUSUFMXCI6e1wicnVsZXNcIjpbMCwxLDIsMyw3LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzldLFwiaW5jbHVzaXZlXCI6dHJ1ZX19XG59KTtcbnJldHVybiBsZXhlcjtcbn0pKCk7XG5wYXJzZXIubGV4ZXIgPSBsZXhlcjtcbmZ1bmN0aW9uIFBhcnNlciAoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcbnJldHVybiBuZXcgUGFyc2VyO1xufSkoKTtcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VyXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9wYXJzZXIvcGFyc2VyLmppc29uXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiY29uc3QgSVNfT0JKRUNUID0geyAnZnVudGlvbic6IHRydWUsICdvYmplY3QnOiB0cnVlIH1cclxuY29uc3QgaXNPYmplY3QgPSBvYmogPT4gSVNfT0JKRUNUW3R5cGVvZiBvYmpdICYmICEhb2JqXHJcblxyXG5leHBvcnQgY29uc3Qgb2JqRWFjaCA9IChvYmosIGNhbGxiYWNrKSA9PiB7XHJcbiAgaWYgKGlzT2JqZWN0KG9iaikpIHtcclxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4geyBjYWxsYmFjayhvYmpba2V5XSwga2V5KSB9KVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGV4dGVuZCA9IChvYmosIGV4dCkgPT4ge1xyXG4gIG9iakVhY2goZXh0LCAodmFsLCBrZXkpID0+IHsgb2JqW2tleV0gPSB2YWwgfSlcclxuICByZXR1cm4gb2JqXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBuZWFyID0gKGEsIGIpID0+IE1hdGguYWJzKGEgLSBiKSA8IDAuMDAwMDFcclxuXHJcbmNvbnN0IGlzQWNjZXNzb3JQcm9wZXJ0eSA9IHZhbHVlID0+IGlzT2JqZWN0KHZhbHVlKSAmJlxyXG4gICAgICAgICh0eXBlb2YgdmFsdWUuZ2V0ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZS5zZXQgPT09ICdmdW5jdGlvbicpXHJcblxyXG4vKipcclxuICogRGVmaW5lIEVTNSBnZXR0ZXIvc2V0dGVyIHByb3BlcnRpZXNcclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gYmUgZGVmaW5lZC5cclxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gRVM1IGdldHRlci9zZXR0ZXIgcHJvcGVydGllcy5cclxuICogRm9yIGV4YW1wbGU6XHJcbiAqIGBgYFxyXG4gKiB7XHJcbiAqICAgbmFtZToge1xyXG4gKiAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7Li4ufSxcclxuICogICAgIHNldDogZnVuY3Rpb24gKCkgey4uLn1cclxuICogICB9LFxyXG4gKiAgIGFnZToge1xyXG4gKiAgICAgIGdldDouLi5cclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGVmaW5lUHJvcGVydGllcyA9IChvYmosIHByb3BzKSA9PiB7XHJcbiAgb2JqRWFjaChwcm9wcywgKHZhbHVlLCBwcm9wKSA9PiB7XHJcbiAgICB2YXIgZGVzY3JpcHRvclxyXG4gICAgaWYgKGlzQWNjZXNzb3JQcm9wZXJ0eSh2YWx1ZSkpIHtcclxuICAgICAgZGVzY3JpcHRvciA9IHZhbHVlXHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBkZXNjcmlwdG9yID0geyB2YWx1ZTogdmFsdWUgfVxyXG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUuY29uc3RhbnQpIHtcclxuICAgICAgZGVzY3JpcHRvciA9IHsgdmFsdWU6IHZhbHVlLmNvbnN0YW50IH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRlc2NyaXB0b3IgPSB7XHJcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZGVzY3JpcHRvcilcclxuICB9KVxyXG59XHJcblxyXG5sZXQgdG9KU09OV2l0aERlZmF1bHQgPSB0cnVlXHJcblxyXG5leHBvcnQgY29uc3QgbWFrZVRvSlNPTiA9ICh2YWx1ZXMsIGVsTmFtZSkgPT4gZnVuY3Rpb24gKCkge1xyXG4gIGlmICh0aGlzLmlzRW1wdHkpIHJldHVyblxyXG5cclxuICBjb25zdCByZXN1bHQgPSB7fVxyXG5cclxuICBvYmpFYWNoKHZhbHVlcywgKGRlZmF1bHRWYWx1ZSwgcHJvcCkgPT4ge1xyXG4gICAgaWYgKHRvSlNPTldpdGhEZWZhdWx0IHx8IHRoaXNbcHJvcF0gIT09IGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICByZXN1bHRbcHJvcF0gPSB0aGlzW3Byb3BdXHJcbiAgICB9XHJcbiAgfSlcclxuICBpZiAoIWVsTmFtZSkgcmV0dXJuIHJlc3VsdFxyXG5cclxuICBjb25zdCByZXMgPSB7fVxyXG4gIHJlc1tlbE5hbWVdID0gcmVzdWx0XHJcbiAgcmV0dXJuIHJlc1xyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3V0aWwuanNcbiAqKi8iLCJpbXBvcnQgeyBtYWtlVG9KU09OLCBleHRlbmQgfSBmcm9tICcuLi91dGlsJ1xyXG5pbXBvcnQgU2NvcmVIZWFkIGZyb20gJy4vU2NvcmVIZWFkJ1xyXG5pbXBvcnQgUGFydHdpc2VQYXJ0cyBmcm9tICcuL1BhcnR3aXNlUGFydHMnXHJcbmltcG9ydCBUaW1ld2lzZU1lYXN1cmVzIGZyb20gJy4vVGltZXdpc2VNZWFzdXJlcydcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcmUgLSBwbGFpbiBzY29yZSBvYmplY3QuXHJcbiAqIEBtaXhlcyBQbGF5ZXJNaXhpblxyXG4gKi9cclxuY2xhc3MgU2NvcmUge1xyXG4gIGNvbnN0cnVjdG9yKHNjb3JlKSB7XHJcbiAgICBleHRlbmQodGhpcywgc2NvcmUpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIZWFkIG9mIHRoZSBzY29yZS5cclxuICAgKiBAdHlwZSB7U2NvcmVIZWFkfVxyXG4gICAqL1xyXG4gIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy5faGVhZCB8fCAodGhpcy5faGVhZCA9IG5ldyBTY29yZUhlYWQoKSkgfVxyXG4gIHNldCBoZWFkKGhlYWQpIHsgdGhpcy5faGVhZCA9IG5ldyBTY29yZUhlYWQoaGVhZCkgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXJ0d2lzZSBwYXJ0cy5cclxuICAgKiAtIChHZXR0ZXIpXHJcbiAgICogLSAoU2V0dGVyKVxyXG4gICAqIEB0eXBlIHtQYXJ0d2lzZVBhcnRzfVxyXG4gICAqL1xyXG4gIGdldCBwYXJ0cygpIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXJ0cyB8fCAodGhpcy5fcGFydHMgPSBuZXcgUGFydHdpc2VQYXJ0cyh0aGlzKSlcclxuICB9XHJcbiAgc2V0IHBhcnRzKHBhcnRzKSB7XHJcbiAgICB0aGlzLnBhcnRzLnJlbW92ZUFsbCgpXHJcbiAgICB0aGlzLnBhcnRzLmFkZFBhcnRzKHBhcnRzKVxyXG4gICAgdGhpcy5tZWFzdXJlcy5mcm9tUGFydHdpc2UoKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGltZXdpc2UgbWVhc3VyZXMsIGdlbmVyYXRlZCBieSB0aGUgaW5pdGlhbGl6ZSBmdW5jdGlvbi5cclxuICAgKiBAdHlwZSB7VGltZXdpc2VNZWFzdXJlc31cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWVhc3VyZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWVhc3VyZXMgfHwgKHRoaXMuX21lYXN1cmVzID0gbmV3IFRpbWV3aXNlTWVhc3VyZXModGhpcykpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIGNlbGwgaXMgaWRlbnRpY2FsbHkgYSBtZWFzdXJlIGluIGEgcGFydCBvciBhIHBhcnQgaW4gYSBtZWFzdXJlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259XHJcbiAgICovXHJcbiAgd2Fsa0NlbGxzKGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLnBhcnRzLmZvckVhY2goKHBhcnQsIHApID0+IHtcclxuICAgICAgcGFydC5tZWFzdXJlcy5mb3JFYWNoKChjZWxsLCBtKSA9PiB7IGNhbGxiYWNrKGNlbGwsIG0sIHApIH0pXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2FsayBlYWNoIG11c2ljIGRhdGEuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICB3YWxrTXVzaWNEYXRhKGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLndhbGtDZWxscygoY2VsbCwgbSwgcCkgPT4ge1xyXG4gICAgICBjZWxsLmRhdGEuZm9yRWFjaCgoZGF0YSwgZCkgPT4geyBjYWxsYmFjayhkYXRhLCBkLCBtLCBwKSB9KVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgc2NvcmUgdG8gc3RyaW5nLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTXVzamUgc291cmNlIGNvZGUuXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oZWFkICsgdGhpcy5wYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQudG9TdHJpbmcoKSkuam9pbignXFxuXFxuJylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEN1c3RvbSB0b0pTT04gbWV0aG9kLlxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgdG9KU09OID0gbWFrZVRvSlNPTih7XHJcbiAgICBoZWFkOiB1bmRlZmluZWQsXHJcbiAgICBwYXJ0czogdW5kZWZpbmVkXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2NvcmVcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kZWwvU2NvcmUuanNcbiAqKi8iLCJpbXBvcnQgeyBtYWtlVG9KU09OLCBleHRlbmQgfSBmcm9tICcuLi91dGlsJ1xuXG4vKipcbiAqIENvbnN0cnVjdCBoZWFkIG9mIHRoZSBzY29yZS5cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtPYmplY3R9IGhlYWRcbiAqL1xuY2xhc3MgU2NvcmVIZWFkIHtcbiAgY29uc3RydWN0b3IoaGVhZCkge1xuICAgIGV4dGVuZCh0aGlzLCBoZWFkKVxuICB9XG5cbiAgLyoqXG4gICAqIFRpdGxlIG9mIHRoZSBzY29yZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIHRpdGxlID0gJydcblxuICAvKipcbiAgICogU3VidGl0bGUgb2YgdGhlIHNjb3JlLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnJ1xuICAgKi9cbiAgc3VidGl0bGUgPSAnJ1xuXG4gIC8qKlxuICAgKiBTdWJzdWJ0aXRsZSBvZiB0aGUgc2NvcmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICcnXG4gICAqL1xuICBzdWJzdWJ0aXRsZSA9ICcnXG5cbiAgLyoqXG4gICAqIENvbXBvc2VyIG9mIHRoZSBzY29yZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGNvbXBvc2VyID0gdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIEFycmFuZ2VyIG9mIHRoZSBzY29yZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGFycmFuZ2VyID0gdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIEx5cmljaXN0IG9mIHRoZSBzY29yZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGx5cmljaXN0ID0gdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzY29yZSBoZWFkIGlzIGVtcHR5LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMudGl0bGUgJiYgIXRoaXMuc3VidGl0bGUgJiYgIXRoaXMuc3Vic3VidGl0bGUgJiZcbiAgICAgICAgICAgIXRoaXMuY29tcG9zZXIgJiYgIXRoaXMuYXJyYW5nZXIgJiYgIXRoaXMubHlyaWNpc3RcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHNjb3JlIGhlYWQgdG8gc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb252ZXJ0ZWQgbXVzamUgaGVhZCBzb3VyY2UgY29kZS5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZSA/IGA8PCR7dGhpcy50aXRsZX0+PmAgOiAnJ1xuICAgIHJldHVybiBgJHt0aXRsZX0gJHt0aGlzLmNvbXBvc2VyIHx8ICcnfVxcbmBcbiAgfVxuXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgc3VidGl0bGU6IHVuZGVmaW5lZCxcbiAgICBzdWJzdWJ0aXRsZTogdW5kZWZpbmVkLFxuICAgIGNvbXBvc2VyOiB1bmRlZmluZWQsXG4gICAgbHlyaWNpc3Q6IHVuZGVmaW5lZFxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBTY29yZUhlYWRcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZGVsL1Njb3JlSGVhZC5qc1xuICoqLyIsImltcG9ydCBQYXJ0d2lzZVBhcnQgZnJvbSAnLi9QYXJ0d2lzZVBhcnQnXHJcblxyXG5jbGFzcyBQYXJ0d2lzZVBhcnRzIGV4dGVuZHMgQXJyYXkge1xyXG4gIGNvbnN0cnVjdG9yKHNjb3JlKSB7XHJcbiAgICBzdXBlcigpXHJcbiAgICB0aGlzLl9zY29yZSA9IHNjb3JlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBzY29yZS5cclxuICAgKiBAdHlwZSB7U2NvcmV9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNjb3JlKCkgeyByZXR1cm4gdGhpcy5fc2NvcmUgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgcGFydHMuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9XHJcbiAgICovXHJcbiAgYWRkUGFydHMocGFydHMpIHsgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHsgdGhpcy5hcHBlbmQocGFydCkgfSkgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBlbmQgYSBwYXJ0d2lzZSBwYXJ0LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJ0IC0gUGxhaW4gcGFydHdpc2UgcGFydCBvYmplY3QuXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXHJcbiAgYXBwZW5kKHBhcnQpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5sZW5ndGhcclxuICAgIGNvbnN0IG11c2plUGFydCA9IG5ldyBQYXJ0d2lzZVBhcnQoaW5kZXgsIHRoaXMpXHJcbiAgICB0aGlzLnB1c2gobXVzamVQYXJ0KVxyXG4gICAgbXVzamVQYXJ0Lm1lYXN1cmVzID0gcGFydC5tZWFzdXJlc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFsbCBwYXJ0cy5cclxuICAgKi9cclxuICByZW1vdmVBbGwoKSB7IHRoaXMubGVuZ3RoID0gMCB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBhcnR3aXNlUGFydHNcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kZWwvUGFydHdpc2VQYXJ0cy5qc1xuICoqLyIsImltcG9ydCB7IG1ha2VUb0pTT04gfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IENlbGwgZnJvbSAnLi9DZWxsJ1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIHBhcnQge09iamVjdH1cbiAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSAtIEluZGV4IG9mIHRoaXMgcGFydCBpbiB0aGUgcGFydHMuXG4gKiBAcGFyYW0gcGFydHMge1BhcnR3aXNlUGFydHN9XG4gKi9cbmNsYXNzIFBhcnR3aXNlUGFydCB7XG4gIGNvbnN0cnVjdG9yKGluZGV4LCBwYXJ0cykge1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXhcbiAgICB0aGlzLl9wYXJ0cyA9IHBhcnRzXG4gIH1cblxuICAvLyBoZWFkOiB7ICRyZWY6ICcjL29iamVjdHMvUGFydEhlYWQnIH0sXG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHBhcnRzIGluc3RhbmNlLlxuICAgKiBAdHlwZSB7UGFydHdpc2VQYXJ0c31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGFydHMoKSB7IHJldHVybiB0aGlzLl9wYXJ0cyB9XG5cbiAgLyoqXG4gICAqIE1lYXN1cmUgaW4gYSBwYXJ0d2lzZSBwYXJ0IGlzIGNlbGxzLlxuICAgKiBAdHlwZSB7QXJyYXkuPENlbGw+fVxuICAgKi9cbiAgZ2V0IG1lYXN1cmVzKCkgeyByZXR1cm4gdGhpcy5fbWVhc3VyZXMgfHwgKHRoaXMuX21lYXN1cmVzID0gW10pIH1cbiAgc2V0IG1lYXN1cmVzKG1lYXN1cmVzKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX2luZGV4XG4gICAgY29uc3QgeyBzY29yZSB9ID0gdGhpcy5wYXJ0c1xuICAgIGNvbnN0IG1lYSA9IHRoaXMuX21lYXN1cmVzID0gW11cbiAgICBtZWFzdXJlcy5mb3JFYWNoKChjZWxsLCBtKSA9PiB7IG1lYS5wdXNoKG5ldyBDZWxsKGNlbGwsIG0sIHAsIHNjb3JlKSkgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgcGFydHdpc2UgcGFydCB0byBzdGluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNdXNqZSBwYXJ0d2lzZSBwYXJ0IHNvdXJjZSBjb2RlLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVhc3VyZXMubWFwKGNlbGwgPT4gY2VsbCkuam9pbignICcpXG4gIH1cblxuICAvKipcbiAgICogQ3VzdG9tIHRvSlNPTiBtZXRob2QuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIG1lYXN1cmVzOiB1bmRlZmluZWRcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFydHdpc2VQYXJ0XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2RlbC9QYXJ0d2lzZVBhcnQuanNcbiAqKi8iLCJpbXBvcnQgeyBtYXRyaXggfSBmcm9tICdzbmFwc3ZnJ1xuXG5pbXBvcnQgdGltZSBmcm9tICcuL1RpbWUnXG5pbXBvcnQgYmFyICBmcm9tICcuL0JhcidcbmltcG9ydCBub3RlIGZyb20gJy4vTm90ZSdcbmltcG9ydCByZXN0IGZyb20gJy4vUmVzdCdcbmltcG9ydCBjaG9yZCBmcm9tICcuL0Nob3JkJ1xuaW1wb3J0IHZvaWNlIGZyb20gJy4vVm9pY2UnXG5pbXBvcnQgQmVhbSBmcm9tICcuL0JlYW0nXG5cbmltcG9ydCB7IGV4dGVuZCwgbmVhciwgbWFrZVRvSlNPTiB9IGZyb20gJy4uL3V0aWwnXG5jb25zdCBDbGFzc2VzID0geyB0aW1lLCBiYXIsIG5vdGUsIHJlc3QsIGNob3JkLCB2b2ljZSB9XG5jb25zdCBCYXIgPSBiYXJcblxuLyoqXG4gKiBDZWxsIGlzIGVpdGhlciBhIG1lYXN1cmUgaW4gYSBwYXJ0d2lzZSBwYXJ0LCBvclxuICogYSBwYXJ0IGluIGEgdGltZXdpc2UgbWVhc3VyZS5cbiAqIEBwYXJhbSBjZWxsIHtPYmplY3R9XG4gKiBAcGFyYW0gbUluZGV4IHtudW1iZXJ9IC0gTWVhc3VyZSBpbmRleCBvZiB0aGlzIGNlbGwuXG4gKiBAcGFyYW0gcEluZGV4IHtudW1iZXJ9IC0gUGFydCBpbmRleCBvZiB0aGlzIGNlbGwuXG4gKi9cbmNsYXNzIENlbGwge1xuICBjb25zdHJ1Y3RvcihjZWxsLCBtSW5kZXgsIHBJbmRleCwgc2NvcmUpIHtcbiAgICB0aGlzLl9tSW5kZXggPSBtSW5kZXhcbiAgICB0aGlzLl9wSW5kZXggPSBwSW5kZXhcbiAgICB0aGlzLl9zY29yZSA9IHNjb3JlXG4gICAgZXh0ZW5kKHRoaXMsIGNlbGwpXG4gICAgbWFrZUJlYW1zKHRoaXMsIDEpXG4gIH1cblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSByb290IHNjb3JlIGluc3RhbmNlLlxuICAgKiBAdHlwZSB7U2NvcmV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjb3JlKCkgeyByZXR1cm4gdGhpcy5fc2NvcmUgfVxuXG4gIC8qKlxuICAgKiBNdXNpYyBkYXRhXG4gICAqIEB0eXBlIHtBcnJheS48TXVzaWNEYXRhTWl4aW4+fVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7IHJldHVybiB0aGlzLl9kYXRhIHx8ICh0aGlzLl9kYXRhID0gW10pIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMubGVuZ3RoID0gMFxuICAgIGRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHsgdGhpcy5hcHBlbmQoZGF0dW0pIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgbWVhc3VyZXMuXG4gICAqIEB0eXBlIHtUaW1ld2lzZU1lYXN1cmVzfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtZWFzdXJlcygpIHsgcmV0dXJuIHRoaXMuc2NvcmUubWVhc3VyZXMgfVxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBtZWFzdXJlLlxuICAgKiBAdHlwZSB7VGltZXdpc2VNZWFzdXJlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtZWFzdXJlKCkgeyByZXR1cm4gdGhpcy5tZWFzdXJlc1t0aGlzLl9tSW5kZXhdIH1cblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgcGFydHMuXG4gICAqIEB0eXBlIHtQYXJ0d2lzZVBhcnRzfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwYXJ0cygpIHsgcmV0dXJuIHRoaXMuc2NvcmUucGFydHMgfVxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBwYXJ0LlxuICAgKiBAdHlwZSB7UGFydHdpc2VQYXJ0fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwYXJ0KCkgeyByZXR1cm4gdGhpcy5wYXJ0c1t0aGlzLl9wSW5kZXhdIH1cblxuICAvKipcbiAgICogUHJldmlvdXMgY2VsbCBpbiB0aGUgcGFydC5cbiAgICogQHR5cGUge0NlbGx8dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmV2KCkgeyByZXR1cm4gdGhpcy5wYXJ0Lm1lYXN1cmVzW3RoaXMuX21JbmRleCAtIDFdIH1cblxuICAvKipcbiAgICogTmV4dCBjZWxsIGluIHRoZSBwYXJ0LlxuICAgKiBAdHlwZSB7Q2VsbHx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLnBhcnQubWVhc3VyZXNbdGhpcy5fbUluZGV4ICsgMV0gfVxuXG4gIC8qKlxuICAgKiBUaGUgZmlyc3QgbXVzaWMgZGF0YSBpbiB0aGUgY2VsbC5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZmlyc3REYXRhKCkgeyByZXR1cm4gdGhpcy5kYXRhWzBdIH1cblxuICAvKipcbiAgICogVGhlIGxhc3QgbXVzaWMgZGF0YSBpbiB0aGUgY2VsbC5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbGFzdERhdGEoKSB7IHJldHVybiB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdIH1cblxuICAvKipcbiAgICogVGhlIGxlZnQgYmFyIG9mIHRoaXMgY2VsbC5cbiAgICogQHR5cGUge0Jhcnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGJhckxlZnQoKSB7XG4gICAgY29uc3QgeyBmaXJzdERhdGEgfSA9IHRoaXNcbiAgICBpZiAoZmlyc3REYXRhICYmIGZpcnN0RGF0YS4kdHlwZSA9PT0gJ2JhcicpIHJldHVybiBmaXJzdERhdGFcblxuICAgIC8vIFRha2UgZnJvbSB0aGUgcHJldmlvdXMgbWVhc3VyZS5cbiAgICBjb25zdCBwcmV2Q2VsbCA9IHRoaXMucHJldlxuICAgIGlmIChwcmV2Q2VsbCkgcmV0dXJuIHByZXZDZWxsLmJhclJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJpZ2h0IGJhciBvZiB0aGlzIGNlbGwuXG4gICAqIEB0eXBlIHtCYXJ8dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBiYXJSaWdodCgpIHtcbiAgICBjb25zdCB7IGxhc3REYXRhIH0gPSB0aGlzXG4gICAgaWYgKGxhc3REYXRhICYmIGxhc3REYXRhLiR0eXBlID09PSAnYmFyJykgcmV0dXJuIGxhc3REYXRhXG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIGEgbXVzaWMgZGF0YSB0byB0aGUgY2VsbC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBtdXNpY0RhdGEgLSBNdXNpYyBkYXRhXG4gICAqL1xuICBhcHBlbmQobXVzaWNEYXRhKSB7XG4gICAgY29uc3QgdHlwZSA9IE9iamVjdC5rZXlzKG11c2ljRGF0YSlbMF0gLy8gbXVzaWNEYXRhIGhhcyBvbmx5IG9uZSBrZXlcbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBDbGFzc2VzW3R5cGVdKG11c2ljRGF0YVt0eXBlXSlcbiAgICBpbnN0YW5jZS5fY2VsbCA9IHRoaXNcbiAgICBpbnN0YW5jZS5faW5kZXggPSB0aGlzLmRhdGEubGVuZ3RoXG4gICAgdGhpcy5kYXRhLnB1c2goaW5zdGFuY2UpXG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaWR0aFxuICAgKiAtIChHZXR0ZXIpIEdldCB0aGUgY2VsbCB3aWR0aC5cbiAgICogLSAoU2V0dGVyKSBTZXQgdGhlIGNlbGwgd2lkdGgsIGFuZCB0aGlzIHdpbGwgY2F1c2UgdGhlIGNlbGwgdG8gcmVmbG93LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5fdyB9XG4gIHNldCB3aWR0aCh3KSB7XG4gICAgdGhpcy5fdyA9IHdcbiAgICByZWZsb3codGhpcylcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLmxheW91dC5vcHRpb25zLnBhcnRIZWlnaHQgfVxuXG4gIC8qKlxuICAgKiBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgY2VsbCBpbiBwYXJlbnQgdGltZXdpc2UgbWVhc3VyZS5cbiAgICogLSBTZXQgdGhlIHggdmFsdWUgd2lsbCBjYXVzZSB0aGUgY2VsbCBlbGVtZW50IHRyYW5zbGF0ZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB4KCkgeyByZXR1cm4gdGhpcy5feCB9XG4gIHNldCB4KHgpIHtcbiAgICB0aGlzLl94ID0geFxuICAgIHRoaXMuZWwudHJhbnNmb3JtKG1hdHJpeCgpLnRyYW5zbGF0ZSh4LCB0aGlzLnkyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgeTIgcG9zaXRpb24gb2YgdGhlIGNlbGwgaW4gcGFyZW50IHRpbWV3aXNlIG1lYXN1cmUuXG4gICAqIC0gU2V0IHRoZSB5MiB2YWx1ZSB3aWxsIGNhdXNlIHRoZSBjZWxsIGVsZW1lbnQgdHJhbnNsYXRlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHkyKCkge1xuICAgIGNvbnN0IHsgcGFydEhlaWdodCwgcGFydFNlcCB9ID0gdGhpcy5sYXlvdXQub3B0aW9uc1xuICAgIGNvbnN0IHAgPSB0aGlzLl9wSW5kZXhcblxuICAgIHJldHVybiBwID8gKHAgKyAxKSAqIHBhcnRIZWlnaHQgKyBwICogcGFydFNlcCA6IHBhcnRIZWlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGVmdCBiYXIgb2YgdGhpcyBjZWxsLlxuICAgKiAtIGJhckxlZnQgYXQgZmlyc3QgbWVhc3VyZSBvZiBhIHN5c3RlbTpcbiAgICogYGBgXG4gICAqIHxdICAtPiB8XG4gICAqIDp8ICAtPiB8XG4gICAqIDp8OiAtPiB8OlxuICAgKiBgYGBcbiAgICogQHR5cGUge0Jhcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYmFyTGVmdEluU3lzdGVtKCkge1xuICAgIGxldCBiYXIgPSB0aGlzLmJhckxlZnRcbiAgICBpZiAoIWJhcikgcmV0dXJuIHsgd2lkdGg6IDAsIGhlaWdodDogMCB9XG5cbiAgICAvLyBGaXJzdCBtZWFzdXJlIGluIHRoZSBzeXN0ZW0uXG4gICAgaWYgKHRoaXMubWVhc3VyZS5pblN5c3RlbUJlZ2luKSB7XG4gICAgICBpZiAoYmFyLnZhbHVlID09PSAnZW5kJyB8fCBiYXIudmFsdWUgPT09ICdyZXBlYXQtZW5kJykge1xuICAgICAgICBiYXIgPSBuZXcgQmFyKCdzaW5nbGUnKVxuICAgICAgfSBlbHNlIGlmIChiYXIudmFsdWUgPT09ICdyZXBlYXQtYm90aCcpIHtcbiAgICAgICAgYmFyID0gbmV3IEJhcigncmVwZWF0LWJlZ2luJylcbiAgICAgIH1cbiAgICB9XG4gICAgYmFyLmRlZiA9IHRoaXMubGF5b3V0LmRlZnMuZ2V0KGJhcilcbiAgICByZXR1cm4gYmFyXG4gIH1cblxuICAvKipcbiAgICogVGhlIHJpZ2h0IGJhciBvZiB0aGlzIGNlbGwuXG4gICAqIC0gYmFyUmlnaHQgYXQgbGFzdCBtZWFzdXJlIG9mIGEgc3lzdGVtOlxuICAgKiBgYGBcbiAgICogIHw6IC0+ICB8XG4gICAqIDp8OiAtPiA6fFxuICAgKiBgYGBcbiAgICogQHR5cGUge211c2plLkJhcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYmFyUmlnaHRJblN5c3RlbSgpIHtcbiAgICBjb25zdCB7IHN5c3RlbSB9ID0gdGhpcy5tZWFzdXJlXG4gICAgbGV0IGJhciA9IHRoaXMuYmFyUmlnaHRcblxuICAgIGlmICghYmFyKSByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH1cblxuICAgIC8vIExhc3QgbWVhc3VyZSBpbiB0aGUgc3lzdGVtLlxuICAgIGlmIChzeXN0ZW0gJiYgdGhpcy5tZWFzdXJlLmluU3lzdGVtRW5kKSB7XG4gICAgICBpZiAoYmFyLnZhbHVlID09PSAncmVwZWF0LWJlZ2luJykge1xuICAgICAgICBiYXIgPSBuZXcgQmFyKCdzaW5nbGUnKVxuICAgICAgfSBlbHNlIGlmIChiYXIudmFsdWUgPT09ICdyZXBlYXQtYm90aCcpIHtcbiAgICAgICAgYmFyID0gbmV3IEJhcigncmVwZWF0LWVuZCcpXG4gICAgICB9XG4gICAgfVxuICAgIGJhci5kZWYgPSB0aGlzLmxheW91dC5kZWZzLmdldChiYXIpXG4gICAgcmV0dXJuIGJhclxuICB9XG5cbiAgLyoqXG4gICAqIEZsb3cgdGhlIGNlbGwuXG4gICAqL1xuICBmbG93KCkge1xuICAgIGNvbnN0IHsgZGVmcywgb3B0aW9ucyB9ID0gdGhpcy5sYXlvdXRcbiAgICBjb25zdCB7IG11c2ljRGF0YVNlcCB9ID0gb3B0aW9uc1xuICAgIGxldCB4ID0gMFxuICAgIGxldCBtaW5IZWlnaHRcblxuICAgIHRoaXMuZGF0YS5mb3JFYWNoKGRhdGEgPT4ge1xuICAgICAgY29uc3QgZGVmID0gZGF0YS5kZWYgPSBkZWZzLmdldChkYXRhKVxuICAgICAgZGF0YS54ID0geFxuICAgICAgZGF0YS55ID0gMFxuICAgICAgeCArPSBkZWYud2lkdGggKyBtdXNpY0RhdGFTZXBcbiAgICAgIG1pbkhlaWdodCA9IE1hdGgubWluKG1pbkhlaWdodCwgZGVmLmhlaWdodClcbiAgICB9KVxuXG4gICAgdGhpcy5taW5XaWR0aCA9IHhcbiAgICB0aGlzLm1pbkhlaWdodCA9IG1pbkhlaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgYm94IG9mIHRoZSBjZWxsLlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUgYm94IFNWRyByZWN0IGVsZW1lbnQuXG4gICAqL1xuICBkcmF3Qm94KCkge1xuICAgIHRoaXMuX2JveEVsID0gdGhpcy5lbC5yZWN0KDAsIC10aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdiYm94JylcbiAgICByZXR1cm4gdGhpcy5fYm94RWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgYm94IFNWRyBlbGVtZW50LlxuICAgKi9cbiAgY2xlYXJCb3goKSB7XG4gICAgdGhpcy5fYm94RWwucmVtb3ZlKClcbiAgICB0aGlzLl9ib3hFbCA9IHVuZGVmaW5lZFxuICB9XG5cblxuICAvKipcbiAgICogQ29udmVydCBjZWxsIHRvIHN0cmluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBDb252ZXJ0ZWQgY2VsbCBpbiBtdXNqZSBzb3VyY2UgY29kZS5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubWFwKG11c2ljRGF0YSA9PiBtdXNpY0RhdGEudG9TdHJpbmcoKSkuam9pbignICcpXG4gIH1cblxuICB0b0pTT04gPSBtYWtlVG9KU09OKHtcbiAgICBkYXRhOiB1bmRlZmluZWRcbiAgfSlcbn1cblxuLy8gUmVmbG93IHRoZSBjZWxsLlxuZnVuY3Rpb24gcmVmbG93KHRoYXQpIHtcbiAgdGhhdC5kYXRhLmZvckVhY2goZGF0YSA9PiB7IGRhdGEueCAqPSB0aGF0LndpZHRoIC8gdGhhdC5taW5XaWR0aCB9KVxufVxuXG5cbi8qKlxuICogTWFrZSBiZWFtcyBhdXRvbWF0aWNhbGx5IGluIGdyb3VwIGJ5IHRoZSBncm91cER1ci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBncm91cER1ciAtIER1cmF0aW9uIG9mIGEgYmVhbSBncm91cCBpbiBxdWFydGVyLlxuICovXG5mdW5jdGlvbiBtYWtlQmVhbXModGhhdCwgZ3JvdXBEdXIpIHtcblxuICBnZXRCZWFtR3JvdXBzKHRoYXQsIGdyb3VwRHVyKS5mb3JFYWNoKGdyb3VwID0+IHtcbiAgICBjb25zdCBiZWFtTGV2ZWwgPSB7fSAgIC8vIGl0IHN0YXJ0cyBmcm9tIDAsIHdoaWxlIHVuZGVyYmFyIHN0YXJ0cyBmcm9tIDFcblxuICAgIGNvbnN0IG5leHRIYXNTYW1lQmVhbWxldmVsID0gKGluZGV4LCBsZXZlbCkgPT4ge1xuICAgICAgY29uc3QgbmV4dCA9IGdyb3VwW2luZGV4ICsgMV1cbiAgICAgIHJldHVybiBuZXh0ICYmIG5leHQuZHVyYXRpb24udW5kZXJiYXIgPiBsZXZlbFxuICAgIH1cblxuICAgIGdyb3VwLmZvckVhY2goKGRhdGEsIGkpID0+IHtcbiAgICAgIGNvbnN0IHsgdW5kZXJiYXIgfSA9IGRhdGEuZHVyYXRpb25cblxuICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHVuZGVyYmFyOyBsZXZlbCsrKSB7XG4gICAgICAgIGlmIChuZXh0SGFzU2FtZUJlYW1sZXZlbChpLCBsZXZlbCkpIHtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEJlYW1zIG9mIHRoZSBub3RlLlxuICAgICAgICAgICAqIC0gUHJvZHVjZWQgYnkgdGhlIHtAbGluayBDZWxsI21ha2VCZWFtc30gbWV0aG9kLlxuICAgICAgICAgICAqIC0gVGhlIGFib3ZlIG1ldGhvZCBpcyBjYWxsIGluIHtAbGluayBTY29yZSNwcmVwYXJlQ2VsbHN9LlxuICAgICAgICAgICAqIEBtZW1iZXJvZiBOb3RlI1xuICAgICAgICAgICAqIEBhbGlhcyBiZWFtc1xuICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48QmVhbT59XG4gICAgICAgICAgICovXG4gICAgICAgICAgZGF0YS5iZWFtcyA9IGRhdGEuYmVhbXMgfHwgW11cblxuICAgICAgICAgIGlmIChiZWFtTGV2ZWxbbGV2ZWxdKSB7XG4gICAgICAgICAgICBkYXRhLmJlYW1zW2xldmVsXSA9IG5ldyBCZWFtKCdjb250aW51ZScsIGxldmVsLCBkYXRhKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZWFtTGV2ZWxbbGV2ZWxdID0gdHJ1ZTtcbiAgICAgICAgICAgIGRhdGEuYmVhbXNbbGV2ZWxdID0gbmV3IEJlYW0oJ2JlZ2luJywgbGV2ZWwsIGRhdGEpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChiZWFtTGV2ZWxbbGV2ZWxdKSB7XG4gICAgICAgICAgICBkYXRhLmJlYW1zID0gZGF0YS5iZWFtcyB8fCBbXTtcbiAgICAgICAgICAgIGRhdGEuYmVhbXNbbGV2ZWxdID0gbmV3IEJlYW0oJ2VuZCcsIGxldmVsLCBkYXRhKVxuICAgICAgICAgICAgZGVsZXRlIGJlYW1MZXZlbFtsZXZlbF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0QmVhbUdyb3Vwcyh0aGF0LCBncm91cER1cikge1xuICBjb25zdCBncm91cHMgPSBbXVxuICBsZXQgZ3JvdXAgPSBbXVxuICBsZXQgY291bnRlciA9IDBcblxuICBjb25zdCBpbkdyb3VwID0gKCkgPT4gY291bnRlciA8IGdyb3VwRHVyICYmICFuZWFyKGNvdW50ZXIsIGdyb3VwRHVyKVxuICBjb25zdCBwdXRHcm91cCA9ICgpID0+IHtcbiAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMSkgZ3JvdXBzLnB1c2goZ3JvdXApXG4gICAgZ3JvdXAgPSBbXVxuICB9XG5cbiAgdGhhdC5kYXRhLmZvckVhY2gobXVzaWNEYXRhID0+IHtcbiAgICBpZiAobXVzaWNEYXRhLiR0eXBlICE9PSAnbm90ZScgJiYgbXVzaWNEYXRhLiR0eXBlICE9PSAncmVzdCcpIHJldHVyblxuXG4gICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gbXVzaWNEYXRhXG4gICAgY29uc3QgZHVyID0gZHVyYXRpb24ucXVhcnRlclxuXG4gICAgY291bnRlciArPSBkdXJcblxuICAgIGlmIChpbkdyb3VwKCkpIHtcbiAgICAgIGlmIChkdXJhdGlvbi51bmRlcmJhcikgZ3JvdXAucHVzaChtdXNpY0RhdGEpXG4gICAgfSBlbHNlIGlmIChuZWFyKGNvdW50ZXIsIGdyb3VwRHVyKSkge1xuICAgICAgZ3JvdXAucHVzaChtdXNpY0RhdGEpXG4gICAgICBwdXRHcm91cCgpXG4gICAgICBjb3VudGVyID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICBwdXRHcm91cCgpXG4gICAgICBjb3VudGVyICU9IGdyb3VwRHVyXG4gICAgfVxuICB9KVxuXG4gIHB1dEdyb3VwKClcblxuICByZXR1cm4gZ3JvdXBzXG59XG5cbmV4cG9ydCBkZWZhdWx0IENlbGxcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZGVsL0NlbGwuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOF9fO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwge1wicm9vdFwiOlwiU25hcFwiLFwiY29tbW9uanMyXCI6XCJzbmFwc3ZnXCIsXCJjb21tb25qc1wiOlwic25hcHN2Z1wiLFwiYW1kXCI6XCJzbmFwc3ZnXCJ9XG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IHsgZXh0ZW5kLCBtYWtlVG9KU09OIH0gZnJvbSAnLi4vdXRpbCdcclxuaW1wb3J0IE11c2ljRGF0YSBmcm9tICcuL011c2ljRGF0YSdcclxuXHJcbi8qKlxyXG4gKiBUaW1lIHNpZ25hdHVyZS5cclxuICogQGNsYXNzXHJcbiAqIEBwYXJhbSB0aW1lIHtPYmplY3R9XHJcbiAqIEBtaXhlcyBNdXNpY0RhdGFNaXhpblxyXG4gKiBAbWl4ZXMgTXVzaWNEYXRhTGF5b3V0TWl4aW5cclxuICovXHJcbmNsYXNzIFRpbWUgZXh0ZW5kcyBNdXNpY0RhdGEge1xyXG4gIGNvbnN0cnVjdG9yKHRpbWUpIHtcclxuICAgIHN1cGVyKClcclxuICAgIGV4dGVuZCh0aGlzLCB0aW1lKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHlwZSBvZiB0aW1lLlxyXG4gICAqIEBjb25zdGFudFxyXG4gICAqIEBkZWZhdWx0IHRpbWVcclxuICAgKi9cclxuICAkdHlwZSA9ICd0aW1lJ1xyXG5cclxuICAvKipcclxuICAgKiBIb3cgbWFueSBiZWF0cyBwZXIgbWVhc3VyZS5cclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqIEBkZWZhdWx0XHJcbiAgICovXHJcbiAgYmVhdHMgPSA0XHJcblxyXG4gIC8qKlxyXG4gICAqIEJlYXQgdHlwZVxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICogQGRlZmF1bHRcclxuICAgKi9cclxuICBiZWF0VHlwZSA9IDRcclxuXHJcbiAgLyoqXHJcbiAgICogRGVmIGlkIHVzZWQgaW4gdGhlIFNWRyA8ZGVmcz4gZWxlbWVudC5cclxuICAgKiBgYGBcclxuICAgKiBpZCA6PSAndCcgYmVhdHMgJy0nIGJlYXRUeXBlXHJcbiAgICogYGBgXHJcbiAgICogRS5nLiBgdDMtNGBcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkZWZJZCgpIHsgcmV0dXJuIGB0JHt0aGlzLmJlYXRzfS0ke3RoaXMuYmVhdFR5cGV9YCB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgdG8gbXVzamUgc291cmNlIGNvZGUuXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBNdXNqZSBzb3VyY2UgY29kZS5cclxuICAgKi9cclxuICB0b1N0cmluZygpIHsgcmV0dXJuIGAke3RoaXMuYmVhdHN9LyR7dGhpcy5iZWF0VHlwZX1gIH1cclxuXHJcbiAgdG9KU09OID0gbWFrZVRvSlNPTih7XHJcbiAgICBiZWF0czogNCxcclxuICAgIGJlYXRUeXBlOiA0XHJcbiAgfSwgJ3RpbWUnKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUaW1lXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZGVsL1RpbWUuanNcbiAqKi8iLCJjbGFzcyBNdXNpY0RhdGEge1xuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBjZWxsLlxuICAgKiBAdHlwZSB7Q2VsbH1cbiAgICovXG4gIGdldCBjZWxsKCkgeyByZXR1cm4gdGhpcy5fY2VsbCB9XG5cbiAgLyoqXG4gICAqIFRoZSBhc2NlbmRhbnQgc3lzdGVtIG9mIHRoZSBtdXNpYyBkYXRhLlxuICAgKiBAdHlwZSB7U3lzdGVtTGF5b3V0fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzeXN0ZW0oKSB7IHJldHVybiB0aGlzLmNlbGwubWVhc3VyZS5zeXN0ZW0gfVxuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBtdXNpYyBkYXRhLlxuICAgKiBAdHlwZSB7TXVzaWNEYXRhTWl4aW58dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmV2KCkgeyByZXR1cm4gdGhpcy5jZWxsLmRhdGFbdGhpcy5faW5kZXggLSAxXSB9XG5cbiAgLyoqXG4gICAqIE5leHQgbXVzaWMgZGF0YS5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMuY2VsbC5kYXRhW3RoaXMuX2luZGV4ICsgMV0gfVxuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBtdXNpYyBkYXRhIGluIHBhcnQsIGFjcm9zcyBtZWFzdXJlLlxuICAgKiBAdHlwZSB7TXVzaWNEYXRhTWl4aW58dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmV2SW5QYXJ0KCkge1xuICAgIGxldCB7IHByZXYsIGNlbGwgfSA9IHRoaXNcbiAgICB3aGlsZSAoIXByZXYgJiYgY2VsbC5wcmV2KSB7XG4gICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgY2VsbCA9IGNlbGwucHJldlxuICAgICAgICBwcmV2ID0gY2VsbC5sYXN0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJldlxuICB9XG5cbiAgLyoqXG4gICAqIE5leHQgbXVzaWMgZGF0YSBpbiBwYXJ0LCBhY3Jvc3MgbWVhc3VyZS5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dEluUGFydCgpIHtcbiAgICBsZXQgeyBuZXh0LCBjZWxsIH0gPSB0aGlzXG4gICAgd2hpbGUgKCFuZXh0ICYmIGNlbGwubmV4dCkge1xuICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgIGNlbGwgPSBjZWxsLm5leHRcbiAgICAgICAgbmV4dCA9IGNlbGwuZmlyc3REYXRhXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICAvKipcbiAgICogUHJldmlvdXMgbXVzaWMgZGF0YSB3aGljaCBoYXMgYSBkdXJhdGlvbi5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJldkR1cmFibGUoKSB7XG4gICAgbGV0IHsgcHJldiB9ID0gdGhpc1xuICAgIHdoaWxlIChwcmV2ICYmICFwcmV2LmR1cmF0aW9uKSBwcmV2ID0gcHJldi5wcmV2XG4gICAgcmV0dXJuIHByZXZcbiAgfVxuXG4gIC8qKlxuICAgKiBOZXh0IG11c2ljIGRhdGEgd2hpY2ggaGFzIGEgZHVyYXRpb24uXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5leHREdXJhYmxlKCkge1xuICAgIGxldCB7IG5leHQgfSA9IHRoaXNcbiAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5kdXJhdGlvbikgbmV4dCA9IG5leHQubmV4dFxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICAvKipcbiAgICogUHJldmlvdXMgbXVzaWMgZGF0YSB3aGljaCBoYXMgYSBkdXJhdGlvbiBpbiBwYXJ0LCBhY3Jvc3MgbWVhc3VyZS5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJldkR1cmFibGVJblBhcnQoKSB7XG4gICAgbGV0IHByZXYgPSB0aGlzLnByZXZJblBhcnRcbiAgICB3aGlsZSAocHJldiAmJiAhcHJldi5kdXJhdGlvbikgcHJldiA9IHByZXYucHJldkluUGFydFxuICAgIHJldHVybiBwcmV2XG4gIH1cblxuICAvKipcbiAgICogTmV4dCBtdXNpYyBkYXRhIHdoaWNoIGhhcyBhIGR1cmF0aW9uIGluIHBhcnQsIGFjcm9zcyBtZWFzdXJlLlxuICAgKiBAdHlwZSB7TXVzaWNEYXRhTWl4aW58dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuZXh0RHVyYWJsZUluUGFydCgpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMubmV4dEluUGFydFxuICAgIHdoaWxlIChuZXh0ICYmICFuZXh0LmR1cmF0aW9uKSBuZXh0ID0gbmV4dC5uZXh0SW5QYXJ0XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBtdXNpYyBkYXRhIGluIHRoZSBjZWxsLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLl94IH1cbiAgc2V0IHgoeCkge1xuICAgIHRoaXMuX3ggPSB4XG4gICAgaWYgKHRoaXMuZWwpIHRoaXMuZWwuYXR0cigneCcsIHgpXG4gIH1cblxuICAvKipcbiAgICogVGhlIHkgcG9zaXRpb24gb2YgdGhlIG11c2ljIGRhdGEgaW4gdGhlIGNlbGwuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuX3kgfVxuICBzZXQgeSh5KSB7XG4gICAgdGhpcy5feSA9IHlcbiAgICBpZiAodGhpcy5lbCkgdGhpcy5lbC5hdHRyKCd5JywgeSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgbXVzaWMgZGF0YSBpbiB0aGUgc3lzdGVtLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHN5c3RlbVgoKSB7IHJldHVybiB0aGlzLnggKyB0aGlzLmNlbGwueCArIHRoaXMuY2VsbC5tZWFzdXJlLnggfVxuXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIG11c2ljIGRhdGEuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5kZWYud2lkdGggfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNdXNpY0RhdGFcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZGVsL011c2ljRGF0YS5qc1xuICoqLyIsImltcG9ydCBNdXNpY0RhdGEgZnJvbSAnLi9NdXNpY0RhdGEnXHJcblxyXG5jb25zdCBCQVJfVE9fU1RSSU5HID0ge1xyXG4gIHNpbmdsZTogJ3wnLCBkb3VibGU6ICd8fCcsIGVuZDogJ3xdJyxcclxuICAncmVwZWF0LWJlZ2luJzogJ3w6JywgJ3JlcGVhdC1lbmQnOiAnOnwnLCAncmVwZWF0LWJvdGgnOiAnOnw6J1xyXG59XHJcbmNvbnN0IEJBUl9UT19JRCA9IHtcclxuICBzaW5nbGU6ICdicycsIGRvdWJsZTogJ2JkJywgZW5kOiAnYmUnLFxyXG4gICdyZXBlYXQtYmVnaW4nOiAnYnJiJywgJ3JlcGVhdC1lbmQnOiAnYnJlJywgJ3JlcGVhdC1ib3RoJzogJ2JyYmUnXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFyIC0gVGhlIGJhciB2YWx1ZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBvZlxyXG4gKiAtICdzaW5nbGUnIC0gYHxgXHJcbiAqIC0gJ2RvdWJsZScgLSBgfHxgXHJcbiAqIC0gJ2VuZCcgLSBgfF1gXHJcbiAqIC0gJ3JlcGVhdC1iZWdpbicgLSBgfDpgXHJcbiAqIC0gJ3JlcGVhdC1lbmQnIC0gYDp8YFxyXG4gKiAtICdyZXBlYXQtYm90aCcgLSBgOnw6YFxyXG4gKi9cclxuY2xhc3MgQmFyIGV4dGVuZHMgTXVzaWNEYXRhIHtcclxuICBjb25zdHJ1Y3RvcihiYXIpIHtcclxuICAgIHN1cGVyKClcclxuICAgIHRoaXMuX3ZhbHVlID0gYmFyXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUeXBlIG9mIGJhci5cclxuICAgKiBAY29uc3RhbnRcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAZGVmYXVsdCBiYXJcclxuICAgKi9cclxuICAkdHlwZSA9ICdiYXInXHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbHVlIG9mIHRoZSBiYXIsIHdoaWNoIGlzIHRoZSBzYW1lIGFzIHRoZSBiYXIgcGFyYW1ldGVyIGluIHRoZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqIEBkZWZhdWx0IHNpbmdsZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlIHx8ICh0aGlzLl92YWx1ZSA9ICdzaW5nbGUnKSB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZiBpZCB1c2VkIGluIHRoZSBTVkcgPGRlZnM+IGVsZW1lbnQuXHJcbiAgICogYGBgXHJcbiAgICogZGVmSWQgICAgQmFyIHZhbHVlXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqICdicycgICAtIHNpbmdsZVxyXG4gICAqICdiZCcgICAtIGRvdWJsZVxyXG4gICAqICdiZScgICAtIHJlcGVhdC1lbmRcclxuICAgKiAnYnJiJyAgLSByZXBlYXQtYmVnaW5cclxuICAgKiAnYnJlJyAgLSByZXBlYXQtZW5kXHJcbiAgICogJ2JyYmUnIC0gcmVwZWF0LWJvdGhcclxuICAgKiBgYGBcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkZWZJZCgpIHsgcmV0dXJuIEJBUl9UT19JRFt0aGlzLnZhbHVlXSB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYmFyIHRvIHN0cmluZy5cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmcgb2YgdGhlIGJhcmxpbmUgaW4gbXVzamUgc291cmNlIGNvZGUuXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoKSB7IHJldHVybiBCQVJfVE9fU1RSSU5HW3RoaXMudmFsdWVdIH1cclxuXHJcbiAgLyoqXHJcbiAgICogW3RvSlNPTiBkZXNjcmlwdGlvbl1cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHsgYmFyOiB2YWx1ZSB9XHJcbiAgICovXHJcbiAgdG9KU09OKCkgeyByZXR1cm4geyBiYXI6IHRoaXMudmFsdWUgfSB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhclxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2RlbC9CYXIuanNcbiAqKi8iLCJpbXBvcnQgeyBleHRlbmQsIG1ha2VUb0pTT04gfSBmcm9tICcuLi91dGlsJ1xyXG5pbXBvcnQgTXVzaWNEYXRhIGZyb20gJy4vTXVzaWNEYXRhJ1xyXG5pbXBvcnQgUGl0Y2ggZnJvbScuL1BpdGNoJ1xyXG5pbXBvcnQgRHVyYXRpb24gZnJvbSAnLi9EdXJhdGlvbidcclxuaW1wb3J0IFRpZSBmcm9tICcuL1RpZSdcclxuaW1wb3J0IFNsdXIgZnJvbSAnLi9TbHVyJ1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gbm90ZVxyXG4gKiBAbWl4ZXMgTXVzaWNEYXRhTWl4aW5cclxuICogQG1peGVzIE11c2ljRGF0YUxheW91dE1peGluXHJcbiAqL1xyXG5jbGFzcyBOb3RlIGV4dGVuZHMgTXVzaWNEYXRhIHtcclxuICBjb25zdHJ1Y3Rvcihub3RlKSB7XHJcbiAgICBzdXBlcigpXHJcbiAgICBleHRlbmQodGhpcywgbm90ZSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFR5cGUgb2Ygbm90ZS5cclxuICAgKiBAY29uc3RhbnRcclxuICAgKiBAZGVmYXVsdCBub3RlXHJcbiAgICovXHJcbiAgJHR5cGUgPSAnbm90ZSdcclxuXHJcbiAgLyoqXHJcbiAgICogVW5pcXVlIGRlZiBpZCBvZiB0aGUgbm90ZSB1c2VkIGluIHRoZSBTVkcgPGRlZnM+IGVsZW1lbnQuXHJcbiAgICogYGBgXHJcbiAgICogZGVmSWQgOj0gJ24nIGFjY2lkZW50YWwgc3RlcCBvY3RhdmUgdHlwZSBkb3RcclxuICAgKiBgYGBcclxuICAgKiBFLmcuXHJcbiAgICogYGBgXHJcbiAgICogTm90ZSAgICAgZGVmSWRcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiAxICAgICAgICBuMTA0MFxyXG4gICAqIGIzLSAgICAgIG5iMzAyMFxyXG4gICAqICM1J18uICAgIG5zNTE4MVxyXG4gICAqIDYsLCAgICAgIG42LTJcclxuICAgKiBgYGBcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkZWZJZCgpIHtcclxuICAgIGNvbnN0IHsgYWNjaWRlbnRhbCwgc3RlcCwgb2N0YXZlIH0gPSB0aGlzLnBpdGNoXHJcbiAgICBjb25zdCB7IHR5cGUsIGRvdCB9ID0gdGhpcy5kdXJhdGlvblxyXG4gICAgcmV0dXJuIGBuJHthY2NpZGVudGFsLnJlcGxhY2UoLyMvZywgJ3MnKX0ke3N0ZXB9JHtvY3RhdmV9JHt0eXBlfSR7ZG90fWBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBpdGNoIG9mIHRoZSBub3RlLlxyXG4gICAqIEB0eXBlIHttdXNqZS5QaXRjaH1cclxuICAgKi9cclxuICBnZXQgcGl0Y2goKSB7IHJldHVybiB0aGlzLl9waXRjaCB8fCAodGhpcy5fcGl0Y2ggPSBuZXcgUGl0Y2godGhpcykpIH1cclxuICBzZXQgcGl0Y2gocGl0Y2gpIHsgdGhpcy5fcGl0Y2ggPSBuZXcgUGl0Y2godGhpcywgcGl0Y2gpIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHVyYXRpb24gb2YgdGhlIG5vdGUuXHJcbiAgICogQHR5cGUge211c2plLkR1cmF0aW9ufVxyXG4gICAqL1xyXG4gIGdldCBkdXJhdGlvbigpIHsgcmV0dXJuIHRoaXMuX2R1cmF0aW9uIHx8ICh0aGlzLl9kdXJhdGlvbiA9IG5ldyBEdXJhdGlvbigpKSB9XHJcbiAgc2V0IGR1cmF0aW9uIChkdXJhdGlvbikgeyB0aGlzLl9kdXJhdGlvbiA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbikgfVxyXG5cclxuICBnZXQgYmVhbXMoKSB7IHJldHVybiB0aGlzLl9iZWFtcyB8fCAodGhpcy5fYmVhbXMgPSBbXSkgfVxyXG4gIHNldCBiZWFtcyhiZWFtcykgeyB0aGlzLl9iZWFtcyA9IGJlYW1zIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGllXHJcbiAgICogQHR5cGUge211c2plLlRpZX1cclxuICAgKi9cclxuICBnZXQgdGllKCkgeyByZXR1cm4gdGhpcy5fdGllIHx8ICh0aGlzLl90aWUgPSBuZXcgVGllKHRoaXMpKSB9XHJcbiAgc2V0IHRpZSh0aWUpIHtcclxuICAgIC8qKlxyXG4gICAgICogVmFsdWUgb2YgdGhlIHRpZS5cclxuICAgICAqIEBtZW1iZXJvZiBUaWUjXHJcbiAgICAgKiBAYWxpYXMgdmFsdWVcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRpZS52YWx1ZSA9IHRpZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2x1clxyXG4gICAqIEB0eXBlIHtTbHVyfVxyXG4gICAqL1xyXG4gIGdldCBzbHVyKCkgeyByZXR1cm4gdGhpcy5fc2x1ciB8fCAodGhpcy5fc2x1ciA9IG5ldyBTbHVyKHRoaXMpKSB9XHJcbiAgc2V0IHNsdXIoc2x1cikgeyBleHRlbmQodGhpcy5zbHVyLCBzbHVyKSB9XHJcblxyXG4gIC8qKiBAbWV0aG9kICovXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zbHVyLmJlZ2luICsgdGhpcy5waXRjaCArIHRoaXMuZHVyYXRpb24gK1xyXG4gICAgICAgICAgIHRoaXMuc2x1ci5lbmQgKyB0aGlzLnRpZS52YWx1ZVxyXG4gIH1cclxuXHJcbiAgdG9KU09OID0gbWFrZVRvSlNPTih7XHJcbiAgICBwaXRjaDogdW5kZWZpbmVkLFxyXG4gICAgZHVyYXRpb246IHVuZGVmaW5lZCxcclxuICAgIHRpZTogdW5kZWZpbmVkLFxyXG4gICAgc2x1cjogdW5kZWZpbmVkXHJcbiAgfSwgJ25vdGUnKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb3RlXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZGVsL05vdGUuanNcbiAqKi8iLCJpbXBvcnQgeyBtYWtlVG9KU09OLCBleHRlbmQgfSBmcm9tICcuLi91dGlsJ1xyXG5cclxuY29uc3QgQTRfRlJFUVVFTkNZID0gNDQwXHJcbmNvbnN0IEE0X01JRElfTlVNQkVSID0gNjlcclxuY29uc3QgU1RFUF9UT19NSURJX05VTUJFUiA9IFt1bmRlZmluZWQsIDAsIDIsIDQsIDUsIDcsIDksIDExXVxyXG5jb25zdCBBQ0NJREVOVEFMX1RPX0FMVEVSID0geyAnIycgOiAxLCAnIyMnOiAyLCBuOiAwLCBiIDogLTEsIGJiOiAtMiB9XHJcblxyXG5jb25zdCBjaGFycyA9IChjaCwgbnVtKSA9PiBuZXcgQXJyYXkobnVtICsgMSkuam9pbihjaClcclxuY29uc3Qgb2N0YXZlU3RyaW5nID0gKG9jdGF2ZSkgPT5cclxuICBvY3RhdmUgPiAwID8gY2hhcnMoJ1xcJycsIG9jdGF2ZSkgOlxyXG4gIG9jdGF2ZSA8IDAgPyBjaGFycygnLCcsIC1vY3RhdmUpIDogJydcclxuXHJcbi8vIC8qKlxyXG4vLyAgKiBTdGVwIGlzIGEgdmFsdWUgb2YgYDFgLCBgMmAsIGAzYCwgYDRgLCBgNWAsIGA2YCwgb3IgYDdgLlxyXG4vLyAgKiBAdHlwZSB7bnVtYmVyfVxyXG4vLyAgKiBAZGVmYXVsdFxyXG4vLyAgKi9cclxuLy8gc3RlcCA9IDFcclxuXHJcbi8vIC8qKlxyXG4vLyAgKiBPY3RhdmUgaXMgYW4gaW50ZWdlciB2YWx1ZSBmcm9tIGAtNWAgdG8gYDVgIGluY2x1c2l2ZS5cclxuLy8gICogQHR5cGUge251bWJlcn1cclxuLy8gICogQGRlZmF1bHRcclxuLy8gICovXHJcbi8vIG9jdGF2ZSA9IDBcclxuXHJcbi8vIC8qKlxyXG4vLyAgKiBBY2NpZGVudGFsIGlzIGVpdGhlciBvZlxyXG4vLyAgKiAtIGAnIydgIC0gc2hhcnBcclxuLy8gICogLSBgJyMjJ2AgLSBkb3VibGUgc2hhcnBcclxuLy8gICogLSBgJ2InYCAtIGZsYXRcclxuLy8gICogLSBgJ2JiJ2AgLSBkb3VibGUgZmxhdFxyXG4vLyAgKiAtIGAnbidgIC0gbmF0dXJhbFxyXG4vLyAgKiAtIGAnJ2AgLSAobm9uZSlcclxuLy8gICogQHR5cGUge3N0cmluZ31cclxuLy8gICovXHJcbi8vIGFjY2lkZW50YWwgPSAnJ1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0gcGFyZW50IHtOb3RlfENob3JkfVxyXG4gKiBAcGFyYW0gcGl0Y2gge09iamVjdH1cclxuICovXHJcbmNsYXNzIFBpdGNoIHtcclxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIHtcclxuICAgIHN0ZXAgPSAxLFxyXG4gICAgb2N0YXZlID0gMCxcclxuICAgIGFjY2lkZW50YWwgPSAnJ1xyXG4gIH0pIHtcclxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxyXG4gICAgZXh0ZW5kKHRoaXMsIHsgc3RlcCwgb2N0YXZlLCBhY2NpZGVudGFsIH0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBwYXJlbnQuXHJcbiAgICogQHR5cGUge05vdGV8Q2hvcmR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZiBpZCB1c2VkIGluIHRoZSBTVkcgPGRlZnM+IGVsZW1lbnQuXHJcbiAgICogYGBgXHJcbiAgICogZGVmSWQgOj0gJ3AnIGFjY2lkZW50YWwgc3RlcCBvY3RhdmVcclxuICAgKiBgYGBcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkZWZJZCgpIHtcclxuICAgIHJldHVybiBgcCR7dGhpcy5hY2NpZGVudGFsLnJlcGxhY2UoLyMvZywgJ3MnKX0ke3RoaXMuc3RlcH0ke3RoaXMub2N0YXZlfWBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsdGVyIChmcm9tIC0yIHRvIDIgaW5jbHVzaXZlKS5cclxuICAgKlxyXG4gICAqIElmIG5vIGFjY2lkZW50YWwgaW4gdGhpcyBwaXRjaCwgaXQgbWlnaHQgYmUgYWZmZWN0ZWQgYnkgYSBwcmV2aW91cyBub3RlIGluIHRoZSBzYW1lIGNlbGwgKHRoZSBzYW1lIHBhcnQgYW5kIHRoZSBzYW1lIG1lYXN1cmUpLlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGFsdGVyKCkge1xyXG4gICAgaWYgKHRoaXMuYWNjaWRlbnRhbCkgcmV0dXJuIEFDQ0lERU5UQUxfVE9fQUxURVJbdGhpcy5hY2NpZGVudGFsXVxyXG4gICAgY29uc3QgeyBhbHRlckxpbmsgfSA9IHRoaXNcclxuICAgIHJldHVybiBhbHRlckxpbmsgPyBhbHRlckxpbmsuYWx0ZXIgOiAwXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQaXRjaCBsaW5rZWQgdGhhdCB3aWxsIGFmZmVjdCB0aGUgYWx0ZXIgaW4gdGhpcyBwaXRjaC5cclxuICAgKiBAdHlwZSB7UGl0Y2h8dW5kZWZpbmVkfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBhbHRlckxpbmsoKSB7XHJcbiAgICBsZXQgcHJldkRhdGEgPSB0aGlzLnBhcmVudC5wcmV2XHJcblxyXG4gICAgd2hpbGUocHJldkRhdGEpIHtcclxuICAgICAgaWYgKHByZXZEYXRhLiR0eXBlID09PSAnbm90ZScgJiZcclxuICAgICAgICAgIHByZXZEYXRhLnBpdGNoLnN0ZXAgPT09IHRoaXMuc3RlcCAmJiBwcmV2RGF0YS5waXRjaC5hY2NpZGVudGFsKSB7XHJcbiAgICAgICAgcmV0dXJuIHByZXZEYXRhLnBpdGNoXHJcbiAgICAgIH1cclxuICAgICAgcHJldkRhdGEgPSBwcmV2RGF0YS5wcmV2XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgTUlESSBub3RlIG51bWJlciBvZiB0aGUgcGl0Y2hcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBtaWRpTnVtYmVyKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLm9jdGF2ZSArIDUpICogMTIgKyBTVEVQX1RPX01JRElfTlVNQkVSW3RoaXMuc3RlcF0gKyB0aGlzLmFsdGVyXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcmVxdWVuY3kgb2YgdGhlIHBpdGNoXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZnJlcXVlbmN5KCkge1xyXG4gICAgcmV0dXJuIEE0X0ZSRVFVRU5DWSAqIE1hdGgucG93KDIsICh0aGlzLm1pZGlOdW1iZXIgLSBBNF9NSURJX05VTUJFUikgLyAxMilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgdG8gbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udmVydGVkIG11c2plIHNvdXJjZSBjb2RlIHN0cmluZy5cclxuICAgKi9cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiB0aGlzLmFjY2lkZW50YWwgKyB0aGlzLnN0ZXAgKyBvY3RhdmVTdHJpbmcodGhpcy5vY3RhdmUpXHJcbiAgfVxyXG5cclxuICB0b0pTT04gPSBtYWtlVG9KU09OKHtcclxuICAgIHN0ZXA6IDEsXHJcbiAgICBvY3RhdmU6IDAsXHJcbiAgICBhY2NpZGVudGFsOiAnJ1xyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBpdGNoXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZGVsL1BpdGNoLmpzXG4gKiovIiwiaW1wb3J0IHsgbWFrZVRvSlNPTiwgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbCdcclxuXHJcbmNvbnN0IFRZUEVfVE9fU1RSSU5HID0ge1xyXG4gIDE6ICcgLSAtIC0gJywgMjogJyAtICcsIDQ6ICcnLCA4OiAnXycsIDE2OiAnPScsIDMyOiAnPV8nLFxyXG4gIDY0OiAnPT0nLCAxMjg6ICc9PV8nLCAyNTY6ICc9PT0nLCA1MTI6ICc9PT1fJywgMTAyNDogJz09PT0nXHJcbn1cclxuY29uc3QgVFlQRV9UT19VTkRFUkJBUiA9IHtcclxuICAgMTogMCwgICAyOiAwLCAgIDQ6IDAsICAgODogMSwgICAxNjogMiwgMzI6IDMsXHJcbiAgNjQ6IDQsIDEyODogNSwgMjU2OiA2LCA1MTI6IDcsIDEwMjQ6IDhcclxufVxyXG5jb25zdCBET1RfVE9fU1RSSU5HID0gWycnLCAnLicsICcuLiddXHJcblxyXG5cclxuICAvLyAvKipcclxuICAvLyAgKiBCZWF0IHR5cGVcclxuICAvLyAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gIC8vICAqIEBkZWZhdWx0XHJcbiAgLy8gICovXHJcbiAgLy8gdHlwZSA9IDRcclxuXHJcbiAgLy8gKlxyXG4gIC8vICAqIERvdCB3aXRoIHZhbHVlIG9mIDAsIDEsIG9yIDIuXHJcbiAgLy8gICogQHR5cGUge251bWJlcn1cclxuICAvLyAgKiBAZGVmYXVsdFxyXG5cclxuICAvLyBkb3QgPSAwXHJcblxyXG5jbGFzcyBEdXJhdGlvbntcclxuICBjb25zdHJ1Y3Rvcih7IHR5cGUgPSA0LCBkb3QgPSAwIH0gPSB7fSkge1xyXG4gICAgZXh0ZW5kKHRoaXMsIHsgdHlwZSwgZG90IH0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUeXBlIG9mIGR1cmF0aW9uLlxyXG4gICAqIEBjb25zdGFudFxyXG4gICAqIEBkZWZhdWx0IGR1cmF0aW9uXHJcbiAgICovXHJcbiAgJHR5cGUgPSAnZHVyYXRpb24nXHJcblxyXG4gIC8qKlxyXG4gICAqIERlZiBpZCB1c2VkIGluIHRoZSBTVkcgPGRlZnM+IGVsZW1lbnQuXHJcbiAgICogYGBgXHJcbiAgICogZGVmSWQgOj0gJ2QnIHR5cGUgZG90XHJcbiAgICogYGBgXHJcbiAgICogKkUuZy4qXHJcbiAgICogYGBgXHJcbiAgICogTm90ZSAgICAgZGVmSWRcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogMS4gICAgICAgZDQxXHJcbiAgICogMV8gICAgICAgZDgwXHJcbiAgICogMT0gICAgICAgZDE2MFxyXG4gICAqIDEtLi4gICAgIGQyMlxyXG4gICAqIGBgYFxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRlZklkKCkgeyByZXR1cm4gYGQke3RoaXMudHlwZX0ke3RoaXMuZG90fWAgfVxyXG5cclxuICAvKipcclxuICAgKiBgKEdldHRlcilgIER1cmF0aW9uIG1lYXN1cmVkIGluIHF1YXJ0ZXIgbm90ZS5cclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBxdWFydGVyKCkge1xyXG4gICAgY29uc3QgZCA9IDQgLyB0aGlzLnR5cGVcclxuICAgIHJldHVybiB0aGlzLmRvdCA9PT0gMCA/IGQgOlxyXG4gICAgICAgICAgIHRoaXMuZG90ID09PSAxID8gZCAqIDEuNSA6IGQgKiAxLjc1XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBgKEdldHRlcilgIER1cmF0aW9uIGluIHNlY29uZFxyXG4gICAqIEFmZmVjdGVkIGJ5IHRoZSB0ZW1wby5cclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzZWNvbmQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5xdWFydGVyICogNjAgLyA4MCAgLy8gLyBURU1QTztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGAoR2V0dGVyKWAgTnVtYmVyIG9mIHVuZGVyYmFycyBpbiB0aGUgYmVhbS5cclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCB1bmRlcmJhcigpIHsgcmV0dXJuIFRZUEVfVE9fVU5ERVJCQVJbdGhpcy50eXBlXSB8fCAwIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKCkgeyByZXR1cm4gVFlQRV9UT19TVFJJTkdbdGhpcy50eXBlXSArIERPVF9UT19TVFJJTkdbdGhpcy5kb3RdIH1cclxuXHJcbiAgLyoqXHJcbiAgICogW3RvSlNPTiBkZXNjcmlwdGlvbl1cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgdG9KU09OID0gbWFrZVRvSlNPTih7XHJcbiAgICB0eXBlOiA0LFxyXG4gICAgZG90OiAwXHJcbiAgfSlcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHVyYXRpb25cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kZWwvRHVyYXRpb24uanNcbiAqKi8iLCIvKipcbiAqIFRpZSBvZiB0aGUgbm90ZS5cbiAqIEBwYXJhbSBwYXJlbnQge05vdGV8Q2hvcmR9XG4gKi9cbmNsYXNzIFRpZSB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICB9XG5cbiAgdmFsdWUgPSAnJ1xuXG4gIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgfVxuXG4gIGdldCBiZWdpbigpIHsgcmV0dXJuIHRoaXMudmFsdWUgfVxuXG4gIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLnByZXZQYXJlbnQgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHJldmlvdXMgZHVyYWJsZSBtdXNpYyBkYXRhIGluIHBhcnQsIGlmIGl0IGlzIGEgdGllIGJlZ2luLlxuICAgKiBAdHlwZSB7RHVyYWJsZXx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXZQYXJlbnQoKSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLnBhcmVudC5wcmV2RHVyYWJsZUluUGFydFxuICAgIHJldHVybiBwcmV2ICYmIHByZXYudGllICYmIHByZXYudGllLnZhbHVlICYmIHByZXZcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmV4dCBkdXJhYmxlIG11c2ljIGRhdGEgaW4gcGFydC5cbiAgICogQHR5cGUge0R1cmFibGV8dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuZXh0UGFyZW50KCkgeyByZXR1cm4gdGhpcy52YWx1ZSAmJiB0aGlzLnBhcmVudC5uZXh0RHVyYWJsZUluUGFydCB9XG5cbiAgLyoqXG4gICAqIElmIHByZXZpb3VzIGR1cmFibGUgbXVzaWMgZGF0YSBpbiBwYXJ0IGhhcyBlcnJvci5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXZIYXNFcnJvcigpIHtcbiAgICBjb25zdCBwcmV2ID0gdGhpcy5wcmV2UGFyZW50XG4gICAgaWYgKCFwcmV2IHx8ICFwcmV2LnBpdGNoKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBwcmV2LnBpdGNoICYmIHByZXYucGl0Y2gubWlkaU51bWJlciAhPT0gdGhpcy5wYXJlbnQucGl0Y2gubWlkaU51bWJlclxuICB9XG5cbiAgLyoqXG4gICAqIElmIG5leHQgZHVyYWJsZSBtdXNpYyBkYXRhIGluIHBhcnQgaGFzIGVycm9yLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dEhhc0Vycm9yKCkge1xuICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0UGFyZW50XG4gICAgaWYgKCFuZXh0IHx8ICFuZXh0LnBpdGNoKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBuZXh0LnBpdGNoLm1pZGlOdW1iZXIgIT09IHRoaXMucGFyZW50LnBpdGNoLm1pZGlOdW1iZXJcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpZVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kZWwvVGllLmpzXG4gKiovIiwiaW1wb3J0IHsgbWFrZVRvSlNPTiB9IGZyb20gJy4uL3V0aWwnXG5cbi8qKlxuICogU2x1clxuICogQGNsYXNzXG4gKiBAcGFyYW0gcGFyZW50IHtOb3RlfENob3JkfVxuICovXG5jbGFzcyBTbHVyIHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gIH1cblxuICBiZWdpbiA9ICcnXG5cbiAgZW5kID0gJydcblxuICAvKipcbiAgICogUGFyZW50IG11c2ljIGRhdGEuXG4gICAqIEB0eXBlIHtOb3RlfENob3JkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgfVxuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBzbHVycmVkIHBhcmVudC5cbiAgICogQHR5cGUge05vdGV8Q2hvcmR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXZQYXJlbnQoKSB7XG4gICAgaWYgKCF0aGlzLmVuZCkgcmV0dXJuXG5cbiAgICBsZXQgcHJldiA9IHRoaXMucGFyZW50LnByZXZJblBhcnRcbiAgICB3aGlsZSAocHJldikge1xuICAgICAgaWYgKHByZXYuc2x1ciAmJiAhcHJldi5zbHVyLmlzRW1wdHkpIHJldHVybiBwcmV2XG4gICAgICBwcmV2ID0gcHJldi5wcmV2SW5QYXJ0XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5leHQgU2x1cnJlZCBwYXJlbnQuXG4gICAqIEB0eXBlIHtOb3RlfENob3JkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuZXh0UGFyZW50KCkge1xuICAgIGlmICghdGhpcy5iZWdpbikgcmV0dXJuXG5cbiAgICBsZXQgbmV4dCA9IHRoaXMucGFyZW50Lm5leHRJblBhcnRcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKG5leHQuc2x1ciAmJiAhbmV4dC5zbHVyLmlzRW1wdHkpIHJldHVybiBuZXh0XG4gICAgICBuZXh0ID0gbmV4dC5uZXh0SW5QYXJ0XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0b2RvIE5lc3RlZCB0aWUgaW4gc2x1ci5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXZDcm9zc1RpZSgpIHt9XG5cbiAgLyoqXG4gICAqIEB0b2RvIE5lc3RlZCB0aWUgaW4gc2x1ci5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5leHRDcm9zc1RpZSgpIHt9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBwcmV2aW91cyBzbHVyIGhhcyBlcnJvci5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXZIYXNFcnJvcigpIHtcbiAgICBjb25zdCB7IHByZXZQYXJlbnQgfSA9IHRoaXNcbiAgICByZXR1cm4gIXByZXZQYXJlbnQgfHwgIXByZXZQYXJlbnQuc2x1ci5iZWdpblxuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBuZXh0IHNsdXIgaGFzIGVycm9yLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dEhhc0Vycm9yKCkge1xuICAgIGNvbnN0IHsgbmV4dFBhcmVudCB9ID0gdGhpc1xuICAgIHJldHVybiAhbmV4dFBhcmVudCB8fCAhbmV4dFBhcmVudC5zbHVyLmVuZFxuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBzbHVyIGlzIGVtcHR5LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaXNFbXB0eSgpIHsgcmV0dXJuICEodGhpcy5iZWdpbiB8fCB0aGlzLmVuZCkgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBzbHVyIHRvIEpTT04gb2JqZWN0LlxuICAgKiBAbWV0aG9kXG4gICAqIEByZXR1cm4ge09iamVjdH0gSlNPTiBvYmplY3QuXG4gICAqL1xuICB0b0pTT04gPSBtYWtlVG9KU09OKHtcbiAgICBiZWdpbjogdW5kZWZpbmVkLFxuICAgIGVuZDogdW5kZWZpbmVkXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNsdXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZGVsL1NsdXIuanNcbiAqKi8iLCJpbXBvcnQgeyBleHRlbmQsIG1ha2VUb0pTT04gfSBmcm9tICcuLi91dGlsJ1xyXG5pbXBvcnQgTXVzaWNEYXRhIGZyb20gJy4vTXVzaWNEYXRhJ1xyXG5pbXBvcnQgRHVyYXRpb24gZnJvbSAnLi9EdXJhdGlvbidcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtyZXN0fSByZXN0XHJcbiAqIEBtaXhlcyBNdXNpY0RhdGFNaXhpblxyXG4gKiBAbWl4ZXMgTXVzaWNEYXRhTGF5b3V0TWl4aW5cclxuICovXHJcbmNsYXNzIFJlc3QgZXh0ZW5kcyBNdXNpY0RhdGEge1xyXG4gIGNvbnN0cnVjdG9yKHJlc3QpIHtcclxuICAgIHN1cGVyKClcclxuICAgIGV4dGVuZCh0aGlzLCByZXN0KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHlwZSBvZiByZXN0LlxyXG4gICAqIEBjb25zdGFudFxyXG4gICAqIEBkZWZhdWx0IHJlc3RcclxuICAgKi9cclxuICAkdHlwZSA9ICdyZXN0J1xyXG5cclxuICAvKipcclxuICAgKiBVbmlxdWUgZGVmIGlkIG9mIHRoZSByZXN0IHVzZWQgaW4gdGhlIFNWRyA8ZGVmcz4gZWxlbWVudC5cclxuICAgKiBgYGBcclxuICAgKiBkZWZJZCA6PSAncicgdHlwZSBkb3RcclxuICAgKiBgYGBcclxuICAgKiBFLmcuXHJcbiAgICogYGBgXHJcbiAgICogUmVzdCAgICAgZGVmSWRcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogMCAgICAgICAgcjQwXHJcbiAgICogMCAtICAgICAgcjIwXHJcbiAgICogMD0uICAgICAgcjE2MVxyXG4gICAqIGBgYFxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRlZklkKCkge1xyXG4gICAgY29uc3QgeyB0eXBlLCBkb3QgfSA9IHRoaXMuZHVyYXRpb25cclxuICAgIHJldHVybiBgciR7dHlwZX0ke2RvdH1gXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEdXJhdGlvbiBvZiB0aGUgcmVzdC5cclxuICAgKiBAdHlwZSB7RHVyYXRpb259XHJcbiAgICovXHJcbiAgZ2V0IGR1cmF0aW9uKCkgeyByZXR1cm4gdGhpcy5fZHVyYXRpb24gfHwgKHRoaXMuX2R1cmF0aW9uID0gbmV3IER1cmF0aW9uKCkpIH1cclxuICBzZXQgZHVyYXRpb24oZHVyYXRpb24pIHsgdGhpcy5fZHVyYXRpb24gPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pIH1cclxuXHJcbiAgZ2V0IGJlYW1zKCkgeyByZXR1cm4gdGhpcy5fYmVhbXMgfHwgKHRoaXMuX2JlYW1zID0gW10pIH1cclxuICBzZXQgYmVhbXMoYmVhbXMpIHsgdGhpcy5fYmVhbXMgPSBiZWFtcyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgdGhlIHJlc3QgdG8gbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udmVydGVkIG11c2plIHNvdXJjZSBjb2RlLlxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKCkgeyByZXR1cm4gYDAke3RoaXMuZHVyYXRpb259YCB9XHJcblxyXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xyXG4gICAgZHVyYXRpb246IHVuZGVmaW5lZCxcclxuICB9LCAncmVzdCcpXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlc3RcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kZWwvUmVzdC5qc1xuICoqLyIsImltcG9ydCB7IGV4dGVuZCwgbWFrZVRvSlNPTiB9IGZyb20gJy4uL3V0aWwnXHJcbmltcG9ydCBNdXNpY0RhdGEgZnJvbSAnLi9NdXNpY0RhdGEnXHJcbmltcG9ydCBQaXRjaCBmcm9tICcuL1BpdGNoJ1xyXG5pbXBvcnQgRHVyYXRpb24gZnJvbSAnLi9EdXJhdGlvbidcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtPYmplY3R9IGNob3JkXHJcbiAqIEBtaXhlcyBNdXNpY0RhdGFNaXhpblxyXG4gKiBAbWl4ZXMgTXVzaWNEYXRhTGF5b3V0TWl4aW5cclxuICovXHJcbmNsYXNzIENob3JkIGV4dGVuZHMgTXVzaWNEYXRhIHtcclxuICBjb25zdHJ1Y3RvcihjaG9yZCkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgZXh0ZW5kKHRoaXMsIGNob3JkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFR5cGUgb2YgY2hvcmQuXHJcbiAgICogQGNvbnN0YW50XHJcbiAgICogQGRlZmF1bHQgY2hvcmRcclxuICAgKi9cclxuICAkdHlwZSA9ICdjaG9yZCdcclxuXHJcbiAgLyoqXHJcbiAgICogUGl0Y2hlcyBpbiB0aGUgY2hvcmQuXHJcbiAgICogQHR5cGUge0FycmF5LjxQaXRjaD59XHJcbiAgICovXHJcbiAgZ2V0IHBpdGNoZXMoKSB7IHJldHVybiB0aGlzLl9waXRjaGVzIHx8ICh0aGlzLl9waXRjaGVzID0gW10pIH1cclxuICBzZXQgcGl0Y2hlcyhwaXRjaGVzKSB7IHRoaXMuX3BpdGNoZXMgPSBwaXRjaGVzLm1hcChwaXRjaCA9PiBuZXcgUGl0Y2gocGl0Y2gpKSB9XHJcblxyXG4gIC8qKlxyXG4gICAqIER1cmF0aW9uIG9mIHRoZSBjaG9yZC5cclxuICAgKiBAdHlwZSB7RHVyYXRpb259XHJcbiAgICovXHJcbiAgZ2V0IGR1cmF0aW9uKCkgeyByZXR1cm4gdGhpcy5fZHVyYXRpb24gfHwgKHRoaXMuX2R1cmF0aW9uID0gbmV3IER1cmF0aW9uKCkpIH1cclxuICBzZXQgZHVyYXRpb24oZHVyYXRpb24pIHsgdGhpcy5fZHVyYXRpb24gPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCBjaG9yZCB0byB0aGUgbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udmVydGVkIG11c2plIHNvdXJjZSBjb2RlIG9mIHRoZSBjaG9yZC5cclxuICAgKi9cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiAnPCcgKyB0aGlzLnBpdGNoZXMubWFwKHBpdGNoID0+IHBpdGNoLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcnKSArICc+JyArIHRoaXMuZHVyYXRpb25cclxuICB9XHJcblxyXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xyXG4gICAgcGl0Y2hlczogdW5kZWZpbmVkLFxyXG4gICAgZHVyYXRpb246IHVuZGVmaW5lZCxcclxuICB9LCAnY2hvcmQnKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaG9yZFxyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2RlbC9DaG9yZC5qc1xuICoqLyIsImltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQgTXVzaWNEYXRhIGZyb20gJy4vTXVzaWNEYXRhJ1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtPYmplY3R9IHZvaWNlXG4gKi9cbmNsYXNzIFZvaWNlIGV4dGVuZHMgTXVzaWNEYXRhIHtcbiAgY29uc3RydWN0b3Iodm9pY2UpIHtcbiAgICBzdXBlcigpXG4gICAgZXh0ZW5kKHRoaXMsIHZvaWNlKVxuICB9XG5cbiAgLyoqXG4gICAqIFR5cGUgb2Ygdm9pY2UuXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdCB2b2ljZVxuICAgKi9cbiAgJHR5cGUgPSAndm9pY2UnXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIHZvaWNlIHRvIG11c2plIHNvdXJjZSBjb2RlIHN0cmluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBDb252ZXJ0ZWQgbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBWb2ljZVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kZWwvVm9pY2UuanNcbiAqKi8iLCIvKipcbiAqIEEgW2JlYW1dW3dpa2ldIGlzIGEgaG9yaXpvbnRhbCBvciBkaWFnb25hbCBsaW5lIHVzZWQgdG8gY29ubmVjdCBtdWx0aXBsZSBjb25zZWN1dGl2ZSBub3RlcyAoYW5kIG9jY2FzaW9uYWxseSByZXN0cykgaW4gb3JkZXIgdG8gaW5kaWNhdGUgcmh5dGhtaWMgZ3JvdXBpbmcuIE9ubHkgZWlnaHRoIG5vdGVzIChxdWF2ZXJzKSBvciBzaG9ydGVyIGNhbiBiZSBiZWFtZWQuXG4gKlxuICogW3dpa2ldOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CZWFtXyhtdXNpYylcbiAqXG4gKiBCZWFtIGlzIGNyZWF0ZWQgYnkge0BsaW5rIENlbGwjbWFrZUJlYW1zfSBhbmRcbiAqIGF0dGFjaGVkIHRvIHtAbGluayBEdXJhYmxlfSBpbiB7QGxpbmsgRHVyYWJsZSNiZWFtc31bbGV2ZWxdXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIEJlYW0gdmFsdWU6IGAnYmVnaW4nYCwgYCdjb250aW51ZSdgIG9yIGAnZW5kJ2AuXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgLSBCZWFtIGxldmVsIHN0YXJ0aW5nIGZyb20gMCB0byB1cC5cbiAqIEBwYXJhbSB7RHVyYWJsZX0gcGFyZW50IC0gVGhlIHBhcmVudCBkdXJhYmxlIG11c2ljIGRhdGEuXG4gKi9cbmNsYXNzIEJlYW0ge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgbGV2ZWwsIHBhcmVudCkge1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVcbiAgICB0aGlzLl9sZXZlbCA9IGxldmVsXG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gIH1cblxuICAvKipcbiAgICogUGFyZW50XG4gICAqIEB0eXBlIHtOb3RlfFJlc3R8Q2hvcmR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCB9XG5cbiAgLyoqXG4gICAqIEJlYW0gdmFsdWU6IGAnYmVnaW4nYCwgYCdjb250aW51ZSdgIG9yIGAnZW5kJ2AuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy5fdmFsdWUgfVxuXG4gIC8qKlxuICAgKiBCZWFtIGxldmVsIHN0YXJ0aW5nIGZyb20gMCB0byB1cC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbGV2ZWwoKSB7IHJldHVybiB0aGlzLl9sZXZlbCB9XG5cbiAgLyoqXG4gICAqIFRoZSBlbmQgcGFyZW50IG11c2ljIGRhdGEgb2YgdGhlIGJlYW0gZ3JvdXAuXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbn1cbiAgICovXG4gIGdldCBlbmREdXJhYmxlKCkge1xuICAgIGxldCBuZXh0RGF0YSA9IHRoaXMucGFyZW50Lm5leHRcbiAgICB3aGlsZSAobmV4dERhdGEgJiYgbmV4dERhdGEuYmVhbXNbdGhpcy5sZXZlbF0udmFsdWUgIT09ICdlbmQnKSB7XG4gICAgICBuZXh0RGF0YSA9IG5leHREYXRhLm5leHRcbiAgICB9XG4gICAgcmV0dXJuIG5leHREYXRhXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmVhbVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kZWwvQmVhbS5qc1xuICoqLyIsImltcG9ydCBUaW1ld2lzZU1lYXN1cmUgZnJvbSAnLi9UaW1ld2lzZU1lYXN1cmUnXG5cbi8qKlxuICogQ29uc3RydWN0IHRpbWV3aXNlIHNjb3JlIG1lYXN1cmVzLlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFRpbWV3aXNlIHNjb3JlIG1lYXN1cmVzLlxuICogQHBhcmFtIHNjb3JlIHtTY29yZX1cbiAqIEBhdWdtZW50cyB7QXJyYXl9XG4gKi9cbmNsYXNzIFRpbWV3aXNlTWVhc3VyZXMgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHNjb3JlKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX3Njb3JlID0gc2NvcmVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBzY29yZS5cbiAgICogQHR5cGUge1Njb3JlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzY29yZSgpIHsgcmV0dXJuIHRoaXMuX3Njb3JlIH1cblxuICAvKipcbiAgICogTWFrZSB0aW1ld2lzZSBzY29yZSBtZWFzdXJlcyBmcm9tIHRoZSBwYXJ0d2lzZSBwYXJ0cy5cbiAgICovXG4gIGZyb21QYXJ0d2lzZSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbCgpXG4gICAgdGhpcy5zY29yZS53YWxrQ2VsbHMoKGNlbGwsIG0pID0+IHtcbiAgICAgIGlmIChtID09PSB0aGlzLmxlbmd0aCAmJiAhdGhpc1ttXSkgdGhpcy5wdXNoKG5ldyBUaW1ld2lzZU1lYXN1cmUobSwgdGhpcykpXG4gICAgICB0aGlzW21dLnBhcnRzLnB1c2goY2VsbClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgbWVhc3VyZXMuXG4gICAqL1xuICByZW1vdmVBbGwoKSB7IHRoaXMubGVuZ3RoID0gMCB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWV3aXNlTWVhc3VyZXNcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZGVsL1RpbWV3aXNlTWVhc3VyZXMuanNcbiAqKi8iLCJpbXBvcnQgeyBtYXRyaXggfSBmcm9tICdzbmFwc3ZnJ1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIG1lYXN1cmUge09iamVjdH1cbiAqIEBtaXhlcyBUaW1ld2lzZU1lYXN1cmVMYXlvdXRNaXhpblxuICovXG5jbGFzcyBUaW1ld2lzZU1lYXN1cmUge1xuICBjb25zdHJ1Y3RvcihpbmRleCwgbWVhc3VyZXMpIHtcbiAgICAvLyB0aGlzLl9pbmRleCA9IGluZGV4XG4gICAgdGhpcy5fbWVhc3VyZXMgPSBtZWFzdXJlc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IG1lYXN1cmVzIGluc3RhbmNlLlxuICAgKiBAbWVtYmVyIHtUaW1ld2lzZU1lYXN1cmVzfVxuICAgKi9cbiAgZ2V0IG1lYXN1cmVzKCkgeyByZXR1cm4gdGhpcy5fbWVhc3VyZXMgfVxuXG4gIC8qKlxuICAgKiBQYXJ0cyBpbiB0aW1ld2lzZSBtZWFzdXJlLlxuICAgKiBAdHlwZSB7QXJyYXkuPENlbGw+fVxuICAgKi9cbiAgZ2V0IHBhcnRzKCkgeyByZXR1cm4gdGhpcy5fcGFydHMgfHwgKHRoaXMuX3BhcnRzID0gW10pIH1cbiAgc2V0IHBhcnRzKHBhcnRzKSB7IHRoaXMuX3BhcnRzID0gcGFydHMgfVxuXG4gIC8qKlxuICAgKiBMZWZ0IGJhciBvZiB0aGUgbWVhc3VyZS5cbiAgICogQHR5cGUge0Jhcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYmFyTGVmdCgpIHsgcmV0dXJuIHRoaXMucGFydHNbMF0uYmFyTGVmdCB9XG5cbiAgLyoqXG4gICAqIFJpZ2h0IGJhciBvZiB0aGUgbWVhc3VyZS5cbiAgICogQHR5cGUge0Jhcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYmFyUmlnaHQoKSB7IHJldHVybiB0aGlzLnBhcnRzWzBdLmJhclJpZ2h0IH1cblxuXG4gIC8qKlxuICAgKiBNZWFzdXJlIFNWRyBncm91cCBlbGVtZW50LlxuICAgKiBAdHlwZSB7U25hcC5FbGVtZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXMuX2VsIH1cblxuICAvKipcbiAgICogTWluaW11biB3aWR0aCBvZiB0aGUgbWVhc3VyZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW5XaWR0aCgpIHtcbiAgICB2YXIgbWluV2lkdGggPSAwXG4gICAgdGhpcy5wYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICBtaW5XaWR0aCA9IE1hdGgubWF4KG1pbldpZHRoLCBjZWxsLm1pbldpZHRoKVxuICAgIH0pXG4gICAgcmV0dXJuIG1pbldpZHRoICsgdGhpcy5wYWRkaW5nXG4gIH1cblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgc3lzdGVtIG9mIHRoaXMgbWVhc3VyZS5cbiAgICogLSAoR2V0dGVyKVxuICAgKiAtIChTZXR0ZXIpIFRoZSBtZWFzdXJlIGVsIHdpbGwgYmUgY3JlYXRlZCwgYW5kIHRoZSBoZWlnaHQgb2YgdGhlIG1lYXN1cmUgd2lsbCBiZSBzZXQuXG4gICAqIEB0eXBlIHtTeXN0ZW1MYXlvdXR9XG4gICAqL1xuICBnZXQgc3lzdGVtKCkgeyByZXR1cm4gdGhpcy5fcyB9XG4gIHNldCBzeXN0ZW0oc3lzdGVtKSB7XG4gICAgdGhpcy5fcyA9IHN5c3RlbVxuICAgIHRoaXMuX2VsID0gc3lzdGVtLmVsLmcoKS5hZGRDbGFzcygnbXVzLW1lYXN1cmUnKVxuICB9XG5cbiAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgY29uc3QgbG8gPSB0aGlzLmxheW91dC5vcHRpb25zXG4gICAgcmV0dXJuIGxvLm1lYXN1cmVQYWRkaW5nUmlnaHQgKyBsby5tZWFzdXJlUGFkZGluZ0xlZnRcbiAgfVxuXG4gIGdldCBvdXRlcldpZHRoKCkgeyByZXR1cm4gdGhpcy5vdXRlcldpZHRoTGVmdCArIHRoaXMub3V0ZXJXaWR0aFJpZ2h0IH1cblxuICBnZXQgb3V0ZXJXaWR0aExlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0Lm9wdGlvbnMubWVhc3VyZVBhZGRpbmdMZWZ0ICtcbiAgICAgICAgICAgIHRoaXMuYmFyTGVmdEluU3lzdGVtLndpZHRoIC8gMlxuICB9XG5cbiAgZ2V0IG91dGVyV2lkdGhSaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQub3B0aW9ucy5tZWFzdXJlUGFkZGluZ1JpZ2h0ICtcbiAgICAgICAgICAgIHRoaXMuYmFyUmlnaHRJblN5c3RlbS53aWR0aCAvIDJcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiB0aGUgbWVhc3VyZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuX3cgfHwgKHRoaXMuX3cgPSB0aGlzLm1pbldpZHRoKSB9XG4gIHNldCB3aWR0aCh3KSB7XG4gICAgdGhpcy5fdyA9IHdcbiAgICB0aGlzLnBhcnRzLmZvckVhY2goY2VsbCA9PiB7IGNlbGwud2lkdGggPSB3IC0gdGhpcy5vdXRlcldpZHRoIH0pXG4gIH1cblxuICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5zeXN0ZW0uaGVpZ2h0IH1cblxuICBnZXQgbWluSGVpZ2h0KCkge1xuICAgIGNvbnN0IHsgcGFydFNlcCB9ID0gdGhpcy5sYXlvdXQub3B0aW9uc1xuICAgIGxldCBtaW5IZWlnaHQgPSAwXG5cbiAgICB0aGlzLnBhcnRzLmZvckVhY2goY2VsbCA9PiB7IG1pbkhlaWdodCArPSBjZWxsLmhlaWdodCArIHBhcnRTZXAgfSlcbiAgICByZXR1cm4gbWluSGVpZ2h0ID8gbWluSGVpZ2h0IC0gcGFydFNlcCA6IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgbWVhc3VyZSBpbiB0aGUgc3lzdGVtLlxuICAgKiAtIChHZXR0ZXIpXG4gICAqIC0gKFNldHRlcikgU2V0IHggY2F1c2UgdGhlIG1lYXN1cmUgZWxlbWVudCB0byB0cmFuc2xhdGUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMuX3ggfVxuICBzZXQgeCh4KSB7XG4gICAgdGhpcy5feCA9IHhcbiAgICB0aGlzLmVsLnRyYW5zZm9ybShTbmFwLm1hdHJpeCgpLnRyYW5zbGF0ZSh4LCAwKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgbWVhc3VyZSBpbiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzeXN0ZW0uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBpblN5c3RlbUJlZ2luKCkgeyByZXR1cm4gdGhpcy5fc0luZGV4ID09PSAwIH1cblxuICAvKipcbiAgICogSWYgdGhlIG1lYXN1cmUgaW4gdGhlIGVuZCBvZiB0aGUgc3lzdGVtLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaW5TeXN0ZW1FbmQoKSB7IHJldHVybiB0aGlzLl9zSW5kZXggPT09IHRoaXMuc3lzdGVtLm1lYXN1cmVzLmxlbmd0aCAtIDEgfVxuXG4gIC8qKlxuICAgKiBMZWZ0IGJhciBvZiB0aGUgbWVhc3VyZSBpbiBzeXN0ZW0uXG4gICAqIEB0eXBlIHttdXNqZS5CYXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGJhckxlZnRJblN5c3RlbSgpIHsgcmV0dXJuIHRoaXMucGFydHNbMF0uYmFyTGVmdEluU3lzdGVtIH1cblxuICAvKipcbiAgICogUmlnaHQgYmFyIG9mIHRoZSBtZWFzdXJlIGluIHN5c3RlbS5cbiAgICogQHR5cGUge0Jhcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYmFyUmlnaHRJblN5c3RlbSgpIHsgcmV0dXJuIHRoaXMucGFydHNbMF0uYmFyUmlnaHRJblN5c3RlbSB9XG5cbiAgLyoqXG4gICAqIEZsb3cgdGhlIG1lYXN1cmUuXG4gICAqL1xuICBmbG93KCkge1xuICAgIHRoaXMucGFydHMuZm9yRWFjaChjZWxsID0+IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBDZWxsIFNWRyBncm91cCBlbGVtZW50LlxuICAgICAgICogQG1lbWJlcm9mIENlbGxMYXlvdXQjXG4gICAgICAgKiBAYWxpYXMgZWxcbiAgICAgICAqIEB0eXBlIHtTbmFwLkVsZW1lbnR9XG4gICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAqL1xuICAgICAgY2VsbC5lbCA9IHRoaXMuZWwuZygpLmFkZENsYXNzKCdtdXMtY2VsbCcpXG5cbiAgICAgIGNlbGwueCA9IHRoaXMub3V0ZXJXaWR0aExlZnRcblxuICAgICAgLy8gY2VsbC5kcmF3Qm94KClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERyYXcgYm94IG9mIHRoZSBjZWxsLlxuICAgKiBAcmV0dXJuIHtTbmFwLkVsZW1lbnR9IFRoZSBib3ggU1ZHIHJlY3QgZWxlbWVudC5cbiAgICovXG4gIGRyYXdCb3goKSB7XG4gICAgdGhpcy5fYm94RWwgPSB0aGlzLmVsLnJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoeyBzdHJva2U6ICdncmVlbicsIGZpbGw6ICdub25lJyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBib3ggU1ZHIGVsZW1lbnQuXG4gICAqL1xuICBjbGVhckJveCgpIHtcbiAgICB0aGlzLl9ib3hFbC5yZW1vdmUoKVxuICAgIHRoaXMuX2JveEVsID0gdW5kZWZpbmVkXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZXdpc2VNZWFzdXJlXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmUuanNcbiAqKi8iLCJpbXBvcnQgeyBtYXRyaXggfSBmcm9tICdzbmFwc3ZnJ1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vLi4vdXRpbCdcbmltcG9ydCBMYXlvdXQgZnJvbSAnLi4vTGF5b3V0L0xheW91dCdcbmltcG9ydCByZW5kZXJCYXIgZnJvbSAnLi9yZW5kZXJCYXInXG5pbXBvcnQgcmVuZGVyRHVyYXRpb24gZnJvbSAnLi9yZW5kZXJEdXJhdGlvbidcbmltcG9ydCByZW5kZXJDdXJ2ZSBmcm9tICcuL3JlbmRlckN1cnZlJ1xuXG5jbGFzcyBSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKHN2ZywgbG8pIHtcbiAgICB0aGlzLl9sbyA9IGV4dGVuZChMYXlvdXQub3B0aW9ucywgbG8pXG4gICAgdGhpcy5sYXlvdXQgPSBuZXcgTGF5b3V0KHN2ZywgdGhpcy5fbG8pXG4gIH1cblxuICByZW5kZXIoc2NvcmUpIHtcbiAgICB0aGlzLl9zY29yZSA9IHNjb3JlXG4gICAgdGhpcy5sYXlvdXQuZmxvdyhzY29yZSlcbiAgICB0aGlzLnJlbmRlckhlYWRlcigpXG4gICAgdGhpcy5yZW5kZXJDb250ZW50KClcbiAgfVxuXG4gIHJlbmRlckhlYWRlcigpIHtcbiAgICBjb25zdCBsbyA9IHRoaXMuX2xvXG4gICAgY29uc3QgeyBoZWFkZXIgfSA9IHRoaXMubGF5b3V0XG4gICAgY29uc3QgeyBlbCwgd2lkdGggfSA9IGhlYWRlclxuXG4gICAgZWwudGV4dCh3aWR0aCAvIDIsIGxvLnRpdGxlRm9udFNpemUsIHRoaXMuX3Njb3JlLmhlYWQudGl0bGUpLmF0dHIoe1xuICAgICAgZm9udFNpemU6IGxvLnRpdGxlRm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiBsby50aXRsZUZvbnRXZWlnaHQsXG4gICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJ1xuICAgIH0pXG5cbiAgICBlbC50ZXh0KHdpZHRoLCBsby50aXRsZUZvbnRTaXplICogMS41LCB0aGlzLl9zY29yZS5oZWFkLmNvbXBvc2VyKS5hdHRyKHtcbiAgICAgIGZvbnRTaXplOiBsby5jb21wb3NlckZvbnRTaXplLFxuICAgICAgZm9udFdlaWdodDogbG8uY29tcG9zZXJGb250V2VpZ2h0LFxuICAgICAgdGV4dEFuY2hvcjogJ2VuZCdcbiAgICB9KVxuXG4gICAgaGVhZGVyLmhlaWdodCA9IGVsLmdldEJCb3goKS5oZWlnaHRcbiAgfVxuXG4gIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgY29uc3QgbG8gPSB0aGlzLl9sb1xuXG4gICAgdGhpcy5sYXlvdXQuY29udGVudC5zeXN0ZW1zLmZvckVhY2goc3lzdGVtID0+IHtcbiAgICAgIGNvbnN0IHsgbWVhc3VyZXMgfSA9IHN5c3RlbVxuICAgICAgbWVhc3VyZXMuZm9yRWFjaChtZWFzdXJlID0+IHtcbiAgICAgICAgcmVuZGVyQmFyKG1lYXN1cmUsIGxvKVxuICAgICAgICBtZWFzdXJlLnBhcnRzLmZvckVhY2goY2VsbCA9PiB7IHJlbmRlckNlbGwoY2VsbCwgbG8pIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTm90ZShub3RlLCBjZWxsLCBsbykge1xuICBub3RlLmVsID0gY2VsbC5lbC5nKCkudHJhbnNmb3JtKG1hdHJpeCgpLnRyYW5zbGF0ZShub3RlLngsIG5vdGUueSkpXG4gIG5vdGUuZWwudXNlKG5vdGUuZGVmLnBpdGNoRGVmLmVsKVxuICByZW5kZXJEdXJhdGlvbihub3RlLCBsbylcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2VsbChjZWxsLCBsbykge1xuICBjZWxsLmRhdGEuZm9yRWFjaChkYXRhID0+IHtcbiAgICBzd2l0Y2ggKGRhdGEuJHR5cGUpIHtcbiAgICAgIGNhc2UgJ3Jlc3QnOlxuICAgICAgICByZW5kZXJOb3RlKGRhdGEsIGNlbGwsIGxvKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbm90ZSc6XG4gICAgICAgIHJlbmRlck5vdGUoZGF0YSwgY2VsbCwgbG8pXG4gICAgICAgIHJlbmRlckN1cnZlKCd0aWUnLCBkYXRhKVxuICAgICAgICByZW5kZXJDdXJ2ZSgnc2x1cicsIGRhdGEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd0aW1lJzpcbiAgICAgICAgZGF0YS5lbCA9IGNlbGwuZWwudXNlKGRhdGEuZGVmLmVsKS5hdHRyKHsgeDogZGF0YS54LCB5OiBkYXRhLnkgfSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcmVuZGVyZXIvUmVuZGVyZXIvUmVuZGVyZXIuanNcbiAqKi8iLCJpbXBvcnQgbGF5b3V0T3B0aW9ucyBmcm9tICcuL2xheW91dE9wdGlvbnMnXG5pbXBvcnQgRGVmcyBmcm9tICcuLi9kZWZzL0RlZnMnXG5pbXBvcnQgU3ZnTGF5b3V0IGZyb20gJy4vU3ZnTGF5b3V0J1xuaW1wb3J0IEJvZHlMYXlvdXQgZnJvbSAnLi9Cb2R5TGF5b3V0J1xuaW1wb3J0IEhlYWRlckxheW91dCBmcm9tICcuL0hlYWRlckxheW91dCdcbmltcG9ydCBDb250ZW50TGF5b3V0IGZyb20gJy4vQ29udGVudExheW91dCdcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSBzdmcge3N0cmluZ31cbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IExheW91dCBvcHRpb25zXG4gKi9cbmNsYXNzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHN2Zywgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLnN2ZyA9IHN2Z1xuXG4gICAgdGhpcy5zdmcgPSBuZXcgU3ZnTGF5b3V0KHRoaXMpXG4gICAgdGhpcy5ib2R5ID0gbmV3IEJvZHlMYXlvdXQodGhpcylcbiAgICB0aGlzLmhlYWRlciA9IG5ldyBIZWFkZXJMYXlvdXQodGhpcylcbiAgICB0aGlzLmNvbnRlbnQgPSBuZXcgQ29udGVudExheW91dCh0aGlzKVxuXG4gICAgdGhpcy5kZWZzID0gbmV3IERlZnModGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtTY29yZX0gc2NvcmVcbiAgICovXG4gIGZsb3coc2NvcmUpIHtcbiAgICBpbml0KHRoaXMsIHNjb3JlKVxuICAgIHRoaXMuY29udGVudC5mbG93KHNjb3JlLm1lYXN1cmVzKVxuICB9XG59XG5cbkxheW91dC5vcHRpb25zID0gbGF5b3V0T3B0aW9uc1xuXG5mdW5jdGlvbiBpbml0KHRoYXQsIHNjb3JlKSB7XG4gIGNvbnN0IHsgbWVhc3VyZXMgfSA9IHNjb3JlXG4gIG1lYXN1cmVzLmZvckVhY2goKG1lYXN1cmUsIG0pID0+IHtcbiAgICBtZWFzdXJlID0gbWVhc3VyZXNbbV1cbiAgICBtZWFzdXJlLmxheW91dCA9IHRoYXRcbiAgICBtZWFzdXJlLnBhcnRzLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICBjZWxsLmxheW91dCA9IHRoYXRcbiAgICAgIGNlbGwuZmxvdygpXG4gICAgfSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9yZW5kZXJlci9MYXlvdXQvTGF5b3V0LmpzXG4gKiovIiwiaW1wb3J0IHsgb2JqRWFjaCB9IGZyb20gJy4uLy4uL3V0aWwnXG5cbmNvbnN0IGxheW91dE9wdGlvbnMgPSB7XG4gIG1vZGU6ICdibG9jaycsIC8vIGlubGluZSB8IGJsb2NrIHwgcGFwZXJcbiAgLy8gd2lkdGg6IDY1MCxcbiAgLy8gaGVpZ2h0OiA2MDAsXG4gIG1hcmdpblRvcDogMjUsXG4gIG1hcmdpblJpZ2h0OiAzMCxcbiAgbWFyZ2luQm90dG9tOiAyNSxcbiAgbWFyZ2luTGVmdDogMzAsXG5cbiAgZm9udFNpemU6IDIwLFxuICBmb250RmFtaWx5OiAnSGVsdmV0aWNhLCBBcmlhbCwgU2FucyBTZXJpZicsXG5cbiAgdGl0bGVGb250U2l6ZTogJzExMCUnLFxuICAvLyB0aXRsZUZvbnRGYW1pbHlcbiAgdGl0bGVGb250V2VpZ2h0OiAnYm9sZCcsXG4gIGNvbXBvc2VyRm9udFNpemU6ICc5MCUnLFxuICAvLyBjb21wb3NlckZvbnRGYW1pbHk6XG4gIGNvbXBvc2VyRm9udFdlaWdodDogJ2JvbGQnLFxuICAvLyBjb21wb3NlckZvbnRTdHlsZSxcbiAgdGltZUZvbnRTaXplOiAnOTUlJyxcbiAgdGltZUZvbnRXZWlnaHQ6ICdib2xkJyxcblxuICBoZWFkZXJTZXA6ICcxMDAlJyxcbiAgc3lzdGVtU2VwOiAnMTgwJScsXG4gIG11c2ljRGF0YVNlcDogJzIwJScsXG5cbiAgcGFydEhlaWdodDogJzEyMCUnLFxuICBwYXJ0U2VwOiAnODAlJyxcblxuICBtZWFzdXJlUGFkZGluZ0xlZnQ6ICc1MCUnLFxuICBtZWFzdXJlUGFkZGluZ1JpZ2h0OiAnNTAlJyxcblxuICBiYXJsaW5lSGVpZ2h0OiAnMTIwJScsXG4gIHRoaW5CYXJsaW5lV2lkdGg6ICc0JScsXG4gIHRoaWNrQmFybGluZVdpZHRoOiAnMTYlJyxcbiAgYmFybGluZVNlcDogJzE4JScsXG4gIGJhcmxpbmVEb3RSYWRpdXM6ICc3LjUlJyxcbiAgYmFybGluZURvdFNlcDogJzIyJScsXG5cbiAgYWNjaWRlbnRhbEZvbnRTaXplOiAnOTUlJyxcbiAgYWNjaWRlbnRhbFNoaWZ0OiAnMTAlJyxcblxuICBvY3RhdmVSYWRpdXM6ICc2LjYlJyxcbiAgb2N0YXZlT2Zmc2V0OiAnMCUnLFxuICBvY3RhdmVTZXA6ICcyMyUnLFxuXG4gIHN0ZXBCYXNlbGluZVNoaWZ0OiAnMTIlJywgIC8vIGZvciBzdGVwIHdpdGhvdXQgbG93ZXIgb2N0YXZlIGFuZCB1bmRlcmxpbmVcblxuICB0eXBlU3Ryb2tlV2lkdGg6ICc1JScsXG4gIHR5cGViYXJPZmZzZXQ6ICczMCUnLCAgIC8vIDEgLSAtIC1cbiAgdHlwZWJhckxlbmd0aDogJzU1JScsICAgLy8gb2ZmIGxlbiBzZXAgbGVuIHNlcCBsZW4gKGRvdCkgZXh0XG4gIHR5cGViYXJTZXA6ICc0NSUnLCAgICAgIC8vIDEgLVxuICB0eXBlYmFyRXh0OiAnMjAlJywgICAgICAvLyBvZmYgbGVuIChkb3QpIGV4dFxuICB1bmRlcmJhclNlcDogJzE3JScsXG5cbiAgZG90T2Zmc2V0OiAnNjAlJywgICAgICAgLy8gZm9yIHR5cGUgPSAyXG4gIGRvdFJhZGl1czogJzYuNiUnLCAgICAgIC8vIDEgLSAuIC5cbiAgZG90U2VwOiAnNjAlJywgICAgICAgICAgLy8gb2ZmIGxlbiBkb3RPZmYgLiBkb3RTZXAgLiBleHRcbiAgdDREb3RPZmZzZXQ6ICczMCUnLFxuICB0NERvdFNlcDogJzUwJScsXG4gIHQ0RG90RXh0OiAnMjUlJyxcbiAgdDREb3RCYXNlbGluZVNoaWZ0OiAnMjAlJ1xufVxuXG5jb25zdCB7IGZvbnRTaXplIH0gPSBsYXlvdXRPcHRpb25zXG5cbm9iakVhY2gobGF5b3V0T3B0aW9ucywgKHZhbHVlLCBrZXkpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHJldHVyblxuXG4gIGNvbnN0IHVuaXQgPSB2YWx1ZS5yZXBsYWNlKC9bXFxkXFwuXSsvLCAnJylcbiAgdmFsdWUgPSArdmFsdWUucmVwbGFjZSgvW15cXGRcXC5dKy8sICcnKVxuXG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJyUnOlxuICAgICAgbGF5b3V0T3B0aW9uc1trZXldID0gZm9udFNpemUgKiB2YWx1ZSAvIDEwMFxuICAgICAgYnJlYWtcbiAgICBjYXNlICcnOlxuICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgY2FzZSAncHgnOlxuICAgICAgbGF5b3V0T3B0aW9uc1trZXldID0gdmFsdWVcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnb3RoZXJzIHRvIGJlIGltcGxlbWVudGVkJzpcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgfVxufSlcblxuZXhwb3J0IGRlZmF1bHQgbGF5b3V0T3B0aW9uc1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcmVuZGVyZXIvTGF5b3V0L2xheW91dE9wdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgQWNjaWRlbnRhbERlZiBmcm9tICcuL0FjY2lkZW50YWxEZWYnXG5pbXBvcnQgQmFyRGVmIGZyb20gJy4vQmFyRGVmJ1xuaW1wb3J0IER1cmF0aW9uRGVmIGZyb20gJy4vRHVyYXRpb25EZWYnXG5pbXBvcnQgUGl0Y2hEZWYgZnJvbSAnLi9QaXRjaERlZidcbmltcG9ydCBUaW1lRGVmIGZyb20gJy4vVGltZURlZidcbmltcG9ydCBOb3RlIGZyb20gJy4uLy4uL21vZGVsL05vdGUnXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0XG4gKi9cbmNsYXNzIERlZnMge1xuICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXRcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN2ZyBkZWYgb2YgdGhlIG11c2ljIGRhdGEuXG4gICAqIEBwYXJhbSAgbXVzaWNEYXRhIHtNdXNpY0RhdGFNaXhpbn0gbXVzaWMgZGF0YVxuICAgKiBAcmV0dXJuIHtEZWZ9XG4gICAqL1xuICBnZXQobXVzaWNEYXRhKSB7XG4gICAgdmFyIGlkID0gbXVzaWNEYXRhLmRlZklkXG4gICAgcmV0dXJuIHRoaXNbaWRdIHx8ICh0aGlzW2lkXSA9IG1ha2VEZWYoaWQsIG11c2ljRGF0YSwgdGhpcykpXG4gIH1cblxuICBnZXRBY2NpZGVudGFsKGFjY2lkZW50YWwpIHtcbiAgICB2YXIgaWQgPSAnYScgKyBhY2NpZGVudGFsLnJlcGxhY2UoLyMvZywgJ3MnKVxuICAgIHJldHVybiB0aGlzW2lkXSB8fFxuICAgICAgICAgICh0aGlzW2lkXSA9IG5ldyBBY2NpZGVudGFsRGVmKGlkLCBhY2NpZGVudGFsLCB0aGlzLl9sYXlvdXQpKVxuICB9XG5cbiAgX2dldFBpdGNoKGlkLCBwaXRjaCwgdW5kZXJiYXIpIHtcbiAgICByZXR1cm4gdGhpc1tpZF0gfHxcbiAgICAgICAgICAodGhpc1tpZF0gPSBuZXcgUGl0Y2hEZWYoaWQsIHBpdGNoLCB1bmRlcmJhciwgdGhpcykpXG4gIH1cbn1cblxuXG5mdW5jdGlvbiBtYWtlRGVmKGlkLCBtdXNpY0RhdGEsIGRlZnMpIHtcbiAgc3dpdGNoIChtdXNpY0RhdGEuJHR5cGUpIHtcbiAgICBjYXNlICdiYXInOlxuICAgICAgcmV0dXJuIG5ldyBCYXJEZWYoaWQsIG11c2ljRGF0YSwgZGVmcy5fbGF5b3V0KVxuICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgcmV0dXJuIG5ldyBUaW1lRGVmKGlkLCBtdXNpY0RhdGEsIGRlZnMuX2xheW91dClcbiAgICBjYXNlICdub3RlJzpcbiAgICAgIHJldHVybiBtYWtlTm90ZURlZihtdXNpY0RhdGEsIGRlZnMpXG4gICAgY2FzZSAncmVzdCc6XG4gICAgICByZXR1cm4gbWFrZVJlc3REZWYobXVzaWNEYXRhLCBkZWZzKVxuICAgIGNhc2UgJ2R1cmF0aW9uJzpcbiAgICAgIHJldHVybiBuZXcgRHVyYXRpb25EZWYoaWQsIG11c2ljRGF0YSwgZGVmcy5fbGF5b3V0KVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlTm90ZURlZihub3RlLCBkZWZzKSB7XG4gIGNvbnN0IHVuZGVyYmFyID0gbm90ZS5kdXJhdGlvbi51bmRlcmJhclxuICBjb25zdCBwaXRjaElkID0gbm90ZS5waXRjaC5kZWZJZCArIHVuZGVyYmFyXG4gIGNvbnN0IHBpdGNoRGVmID0gZGVmcy5fZ2V0UGl0Y2gocGl0Y2hJZCwgbm90ZS5waXRjaCwgdW5kZXJiYXIpXG4gIGNvbnN0IGR1cmF0aW9uRGVmID0gZGVmcy5nZXQobm90ZS5kdXJhdGlvbilcbiAgcmV0dXJuIHtcbiAgICBwaXRjaERlZjogcGl0Y2hEZWYsXG4gICAgZHVyYXRpb25EZWY6IGR1cmF0aW9uRGVmLFxuICAgIGhlaWdodDogcGl0Y2hEZWYuaGVpZ2h0LFxuICAgIHdpZHRoOiBwaXRjaERlZi53aWR0aCArIGR1cmF0aW9uRGVmLndpZHRoICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodW5kZXJiYXIgPyBwaXRjaERlZi5zY2FsZS54IDogMSlcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlUmVzdERlZihyZXN0LCBkZWZzKSB7XG4gIGNvbnN0IHJlc3ROb3RlID0gbmV3IE5vdGUoeyBwaXRjaDogeyBzdGVwOiAwIH0sIGR1cmF0aW9uOiByZXN0LmR1cmF0aW9uIH0pXG4gIHJldHVybiBtYWtlTm90ZURlZihyZXN0Tm90ZSwgZGVmcylcbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVmc1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcmVuZGVyZXIvZGVmcy9EZWZzLmpzXG4gKiovIiwiaW1wb3J0IFNuYXAgZnJvbSAnc25hcHN2ZydcclxuaW1wb3J0IHN2Z1BhdGhzIGZyb20gJy4uL3N2Z1BhdGhzJ1xyXG5cclxuLyoqXHJcbiAqIFNWRyBkZWZpbml0aW9uIGZvciBhY2NpZGVudGFsLlxyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtzdHJpbmd9IGlkICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYWNjaWRlbnRhbCBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgICAgIFtkZXNjcmlwdGlvbl1cclxuICovXHJcbmZ1bmN0aW9uIEFjY2lkZW50YWxEZWYoaWQsIGFjY2lkZW50YWwsIGxheW91dCkge1xyXG4gIGNvbnN0IHsgYWNjaWRlbnRhbFNoaWZ0LCBhY2NpZGVudGFsRm9udFNpemUgfSA9IGxheW91dC5vcHRpb25zXHJcbiAgY29uc3QgZWwgPSB0aGlzLmVsID0gbGF5b3V0LnN2Zy5lbC5nKCkuYXR0cignaWQnLCBpZClcclxuICBjb25zdCBhY2NLZXkgPSBhY2NpZGVudGFsLnJlcGxhY2UoL2JiLywgJ2InKSAvLyBkb3VibGUgZmxhdCB0byBiZSBzeW50aGVzaXplZFxyXG4gIGNvbnN0IHBhdGhEYXRhID0gc3ZnUGF0aHNbYWNjS2V5XVxyXG4gIGNvbnN0IHJhdGlvID0gc3ZnUGF0aHMuQUNDSURFTlRBTF9SQVRJT1NbYWNjS2V5XVxyXG4gIGNvbnN0IHNoaWZ0ID0gc3ZnUGF0aHMuQUNDSURFTlRBTF9TSElGVFNbYWNjS2V5XVxyXG4gIGNvbnN0IHBhdGggPSBlbC5wYXRoKHBhdGhEYXRhKVxyXG4gIGxldCBiYiA9IGVsLmdldEJCb3goKVxyXG5cclxuICBwYXRoLnRyYW5zZm9ybShTbmFwLm1hdHJpeCgpXHJcbiAgICAudHJhbnNsYXRlKDAuMSAqIGFjY2lkZW50YWxTaGlmdCwgLWFjY2lkZW50YWxTaGlmdClcclxuICAgIC5zY2FsZShyYXRpbyAqIGFjY2lkZW50YWxGb250U2l6ZSlcclxuICAgIC50cmFuc2xhdGUoLWJiLngsIHNoaWZ0IC0gYmIueTIpXHJcbiAgKVxyXG5cclxuICAvLyBDb21iaW5lIHR3byBmbGF0IHRvIGJlIGRvdWJsZSBmbGF0LlxyXG4gIGlmIChhY2NpZGVudGFsID09PSAnYmInKSB7XHJcbiAgICBlbC51c2UocGF0aCkuYXR0cigneCcsIGFjY2lkZW50YWxGb250U2l6ZSAqIDAuMjQpXHJcbiAgICBlbC50cmFuc2Zvcm0oJ3NjYWxlKDAuOSwxKScpXHJcbiAgfVxyXG5cclxuICBiYiA9IGVsLmdldEJCb3goKVxyXG4gIHRoaXMud2lkdGggPSBiYi53aWR0aCAqIDEuMlxyXG5cclxuICBlbC50b0RlZnMoKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBY2NpZGVudGFsRGVmXHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3JlbmRlcmVyL2RlZnMvQWNjaWRlbnRhbERlZi5qc1xuICoqLyIsImNvbnN0IHN2Z1BhdGhzID0ge1xuICAvLyBodHRwczovL3VwbG9hZC53aWtpbWVkaWEub3JnL3dpa2lwZWRpYS9jb21tb25zL2EvYTYvU2hhcnAuc3ZnXG4gICcjJzogJ002LjEwMiw3LjQ1N1YyLjc1M0w4LjEwMiwyLjIwMVY2Ljg4MUw2LjEwMiw3LjQ1N3pNMTAuMDQsNi4zMTlMOC42NjUsNi43MTNWMi4wMzNMMTAuMDQsMS42NDlWLTAuMjk1TDguNjY1LDAuMDg5Vi00LjY5Mjc3SDguMTAyVjAuMjM0TDYuMTAyLDAuODA5Vi0zLjg0MDc3SDUuNTcxVjAuOTg2TDQuMTk2LDEuMzcxVjMuMzE5TDUuNTcxLDIuOTM1VjcuNjA2TDQuMTk2LDcuOTg5VjkuOTI5TDUuNTcxLDkuNTQ1VjE0LjI5OUw2LjEwMiwxNC4yOTk3N1Y5LjM3NUw4LjEwMiw4LjgyNVYxMy40NTA3N0g4LjY2NVY4LjY1MUwxMC4wNCw4LjI2NlY2LjMxOXonLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvMy8zYS9Eb3VibGVTaGFycC5zdmdcbiAgJyMjJzogJ001LjAwOSw4LjMwNzIxQzQuMjc0NDMsOC4xOTE5MiAzLjUyNzY5LDguMTkyMDkgMi43ODU4LDguMTkyOTRDMi43NzAwNyw3LjY1MDExIDIuODU2NzQsNy4wNzI5IDIuNjQxNSw2LjU2MzQzQzIuNDk4MjEsNi4yMjQyNiAyLjIyNTMyLDUuOTU2NjUgMS45ODI2OSw1LjY4MTU1QzEuNTk1NTIsNi4wMjc4IDEuMjc3NTEsNi40ODQ3NSAxLjI0NzA0LDcuMDE2MzhDMS4yMTcwNiw3LjQwNzY3IDEuMjM5MDIsNy44MDA4NSAxLjIzMjIsOC4xOTI5NEMwLjQ5MDQsOC4yMDQxNi0wLjI1OTE4LDguMTY4MjgtMC45OTEsOC4zMTRDLTAuODQ5ODgsNy41ODYzLTAuODgxOTUsNi44NDE3MS0wLjg2OTE3LDYuMTA0OEMtMC4zMDQzLDYuMDg5NTMgMC4zMDAyMyw2LjE3MTAxIDAuODI0ODQsNS45MjUyNkMxLjEzNDQxLDUuNzgwMjMgMS4zOTY1Myw1LjU1Mjk1IDEuNjU5MSw1LjMzNjc2QzEuMzE3Myw0Ljk0OTY1IDAuODczNDYsNC42MDg2MSAwLjMzNjY1LDQuNTc2NTFDLTAuMDY0MjcsNC41NDQ4NS0wLjQ2NzM0LDQuNTY3OTMtMC44NjkxNyw0LjU2MDk3Qy0wLjg5NDM0LDMuODI5NDktMC44MDg5NSwzLjA4ODU1LTAuOTYwNzksMi4zNjYzQy0wLjIzNzMzLDIuNDk2OTcgMC41MDA2NSwyLjQ2MzQzIDEuMjMyMiwyLjQ3Mjg0QzEuMjQzMDYsMi45OTM4MyAxLjE4NDgzLDMuNTMzODEgMS4zMzE5MSw0LjAzNTVDMS40NDQxNCw0LjQxODM4IDEuNzQ5NzgsNC43MTI5MyAyLjAwNTEsNS4wMTUyMUMyLjM2NTUzLDQuNzAxMTEgMi42OTA1Nyw0LjMwNzA2IDIuNzUwMTEsMy44MTQxMkMyLjgwNCwzLjM2NzkzIDIuNzYxMjMsMi45MTk3NyAyLjc4NTgsMi40NzI4NEMzLjUyMjYzLDIuNDUzNDggNC4yODIxNSwyLjU0NzEzIDQuOTk1MzUsMi4zMTRDNC44ODg5MSwzLjA1NzExIDQuODc4ODksMy44MTE1MiA0Ljg4NzE3LDQuNTYwOTdDNC4zNjEyNyw0LjU3NTgyIDMuODA5NTQsNC41MTc0NyAzLjMwOTU1LDQuNjk0NTdDMi45Mjk3NSw0LjgyOTEgMi42MzExNCw1LjEyMzQxIDIuMzI4NjksNS4zODMyNUMyLjY1NjYxLDUuNzE4NjcgMy4wNTE2LDYuMDI4MDIgMy41NDAzLDYuMDczNjhDMy45ODgzNCw2LjExNTU0IDQuNDM4MjksNi4wOTY1OCA0Ljg4NzE3LDYuMTA0OEM0Ljg5ODI4LDYuODM5NTggNC44NjE5Myw3LjU4MjUgNS4wMDksOC4zMDcyMXonLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvYi9iYS9GbGF0LnN2Z1xuICBiOiAnTTguMTY2LDMuNjU3QzguMTY2LDQuMjMyIDcuOTUwNDI1LDQuNzgyNzMgNy4zNTksNS41MjE4OEM2LjczMjQzNSw2LjMwNDk0IDYuMjA1LDYuNzUzMTMgNS41MSw3LjI4MDEzVjMuODQ4QzUuNjY4LDMuNDQ5IDUuOTAxLDMuMTI2IDYuMjEsMi44NzhDNi41MTgsMi42MzEgNi44MywyLjUwNyA3LjE0NiwyLjUwN0M3LjY2OCwyLjUwNyA3Ljk5OSwyLjgwMyA4LjE0MiwzLjM5M0M4LjE1OCwzLjQ0MSA4LjE2NiwzLjUyOSA4LjE2NiwzLjY1N3pNOC4wOTEsMS4yNTdDNy42NiwxLjI1NyA3LjIyMiwxLjM3NiA2Ljc3NiwxLjYxNUM2LjMzLDEuODUzIDUuOTA4LDIuMTcyIDUuNTEsMi41NjlWLTQuNzAyNjdINC45NDcgVjcuNzUyMTNDNC45NDcsOC4xMDQxMyA1LjA0Myw4LjI4MDEzIDUuMjM1LDguMjgwMTNDNS4zNDYsOC4yODAxMyA1LjQ4MzkxMyw4LjE4NzEzIDUuNjksOC4wNjQxM0M2LjI3MzM0LDcuNzE1OTggNi42MzY5MzUsNy40ODMzMiA3LjAzMiw3LjIzNzg4QzcuNDgyNjE3LDYuOTU3OTIgNy45OSw2LjYzMSA4LjY2MSw1Ljk5MUM5LjEyNCw1LjUyNiA5LjQ1OSw1LjA1NyA5LjY2Nyw0LjU4NUM5Ljg3NCw0LjExMiA5Ljk3OCwzLjY0NCA5Ljk3OCwzLjE3OUM5Ljk3OCwyLjQ5MSA5Ljc5NSwyLjAwMiA5LjQyOSwxLjcxM0M5LjAxNSwxLjQwOSA4LjU2OCwxLjI1NyA4LjA5MSwxLjI1N3onLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvZi9mNC9NdXNpYy1uYXR1cmFsLnN2Z1xuICBuOiAnTSAwLDE0LjExMlY0MS41MmgtMS4yNDhWMzEuMjQ4bC02LjY3MiwxLjcyOFY1LjIzMmgxLjJ2MTAuNzA0bDYuNzIsLTEuODI0em0tNi43Miw2LjQzMnY3LjUzNmw1LjQ3MiwtMS40NHYtNy41MzZsLTUuNDcyLDEuNDR6JyxcblxuICBBQ0NJREVOVEFMX1JBVElPUzogeyAnIyc6IDAuMDQzLCAnbic6IDAuMDIzLCAnIyMnOiAwLjA2MiwgYjogMC4wNTcgfSxcbiAgQUNDSURFTlRBTF9TSElGVFM6IHsgJyMnOiAxLCAnbic6IDIsICcjIyc6IC00LCBiOiAwIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc3ZnUGF0aHNcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3JlbmRlcmVyL3N2Z1BhdGhzLmpzXG4gKiovIiwiLyoqXG4gKiBTVkcgZGVmaW5pdGlvbiBmb3IgYmFybGluZS5cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IGlkICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0Jhcn0gYmFyICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBCYXJEZWYoaWQsIGJhciwgbGF5b3V0KSB7XG4gIGNvbnN0IHtcbiAgICB0aGluQmFybGluZVdpZHRoLCB0aGlja0JhcmxpbmVXaWR0aCxcbiAgICBiYXJsaW5lU2VwLCBiYXJsaW5lRG90U2VwLCBiYXJsaW5lRG90UmFkaXVzXG4gIH0gPSBsYXlvdXQub3B0aW9uc1xuICBsZXQgeCA9IDBcbiAgbGV0IGxpbmVXaWR0aFxuICB0aGlzLmVsID0gbGF5b3V0LnN2Zy5lbC5nKCkuYXR0cignaWQnLCBpZCkudG9EZWZzKClcblxuICBzd2l0Y2ggKGJhci52YWx1ZSkge1xuICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICBsaW5lV2lkdGggPSB0aGluQmFybGluZVdpZHRoXG4gICAgICBhZGRCYXJsaW5lKHRoaXMsIHgsIGxpbmVXaWR0aClcbiAgICAgIHggKz0gbGluZVdpZHRoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICBsaW5lV2lkdGggPSB0aGluQmFybGluZVdpZHRoXG4gICAgICBhZGRCYXJsaW5lKHRoaXMsIHgsIGxpbmVXaWR0aClcbiAgICAgIHggKz0gbGluZVdpZHRoICsgYmFybGluZVNlcFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdlbmQnOlxuICAgICAgbGluZVdpZHRoID0gdGhpbkJhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aCArIGJhcmxpbmVTZXBcbiAgICAgIGxpbmVXaWR0aCA9IHRoaWNrQmFybGluZVdpZHRoXG4gICAgICBhZGRCYXJsaW5lKHRoaXMsIHgsIGxpbmVXaWR0aClcbiAgICAgIHggKz0gbGluZVdpZHRoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3JlcGVhdC1iZWdpbic6XG4gICAgICBsaW5lV2lkdGggPSB0aGlja0JhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aCArIGJhcmxpbmVTZXBcbiAgICAgIGxpbmVXaWR0aCA9IHRoaW5CYXJsaW5lV2lkdGhcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGggKyBiYXJsaW5lRG90U2VwICsgYmFybGluZURvdFJhZGl1c1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdyZXBlYXQtZW5kJzpcbiAgICAgIHggPSBiYXJsaW5lRG90U2VwICsgYmFybGluZURvdFJhZGl1c1xuICAgICAgbGluZVdpZHRoID0gdGhpbkJhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aCArIGJhcmxpbmVTZXBcbiAgICAgIGxpbmVXaWR0aCA9IHRoaWNrQmFybGluZVdpZHRoXG4gICAgICBhZGRCYXJsaW5lKHRoaXMsIHgsIGxpbmVXaWR0aClcbiAgICAgIHggKz0gbGluZVdpZHRoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3JlcGVhdC1ib3RoJzpcbiAgICAgIHggPSBiYXJsaW5lRG90U2VwICsgYmFybGluZURvdFJhZGl1c1xuICAgICAgbGluZVdpZHRoID0gdGhpbkJhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aCArIGJhcmxpbmVTZXBcbiAgICAgIGxpbmVXaWR0aCA9IHRoaWNrQmFybGluZVdpZHRoXG4gICAgICBhZGRCYXJsaW5lKHRoaXMsIHgsIGxpbmVXaWR0aClcbiAgICAgIHggKz0gbGluZVdpZHRoICsgYmFybGluZVNlcFxuICAgICAgbGluZVdpZHRoID0gdGhpbkJhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aCArIGJhcmxpbmVEb3RTZXAgKyBiYXJsaW5lRG90UmFkaXVzXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gIH1cbiAgdGhpcy53aWR0aCA9IHhcbn1cblxuZnVuY3Rpb24gYWRkQmFybGluZSh0aGF0LCB4LCB3aWR0aCkgeyB0aGF0LmVsLnJlY3QoeCwgMCwgd2lkdGgsIDEpIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFyRGVmXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9yZW5kZXJlci9kZWZzL0JhckRlZi5qc1xuICoqLyIsIi8qKlxuICogU1ZHIGRlZmluaXRpb24gZm9yIGR1cmF0aW9uLlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgICAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtIHtEdXJhdGlvbn0gZHVyYXRpb24gW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gRHVyYXRpb25EZWYoaWQsIGR1cmF0aW9uLCBsYXlvdXQpIHtcbiAgdGhpcy5faWQgPSBpZFxuICB0aGlzLl9sYXlvdXQgPSBsYXlvdXRcblxuICAvLyBvbmx5IG1ha2UgZGVmIGVsIGZvcjpcbiAgLy8gaWQgPSBkMTAsIGQxMSwgZDEyLCBkMjAsIGQyMSwgZDIwLCBkNDEsIGQ0MFxuICBzd2l0Y2ggKGR1cmF0aW9uLnR5cGUpIHtcbiAgICBjYXNlIDE6ICAgLy8gd2hvbGUgbm90ZVxuICAgICAgbWFrZUVsKHRoaXMpXG4gICAgICBtYWtlVHlwZTEodGhpcywgaWQsIGR1cmF0aW9uLmRvdClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAyOiAgIC8vIGhhbGYgbm90ZVxuICAgICAgbWFrZUVsKHRoaXMpXG4gICAgICBtYWtlVHlwZTIodGhpcywgaWQsIGR1cmF0aW9uLmRvdClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDogIC8vIG90aGVyIG5vdGUgdHlwZXMgdHlwZSBxdWFydGVyIG5vdGUgZGVmXG4gICAgICBpZiAoZHVyYXRpb24uZG90ID09PSAwKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWtlRWwodGhpcylcbiAgICAgICAgbWFrZVR5cGU0KHRoaXMsIGlkLCBkdXJhdGlvbi5kb3QpXG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZVR5cGUxKHRoYXQsIGlkLCBkb3QpIHtcbiAgY29uc3QgeyB0eXBlYmFyTGVuZ3RoLCB0eXBlYmFyU2VwLCB0eXBlYmFyT2Zmc2V0IH0gPSB0aGF0Ll9sYXlvdXQub3B0aW9uc1xuICBsZXQgeCA9IHR5cGViYXJPZmZzZXRcblxuICBhZGRMaW5lKHRoYXQsIHgpXG4gIHggKz0gdHlwZWJhckxlbmd0aCArIHR5cGViYXJTZXBcbiAgYWRkTGluZSh0aGF0LCB4KVxuICB4ICs9IHR5cGViYXJMZW5ndGggKyB0eXBlYmFyU2VwXG4gIGFkZExpbmUodGhhdCwgeClcbiAgeCArPSB0eXBlYmFyTGVuZ3RoXG5cbiAgdGhhdC53aWR0aCA9IGFkZERvdCh0aGF0LCB4LCBkb3QsIDEpXG59XG5cbmZ1bmN0aW9uIG1ha2VUeXBlMih0aGF0LCBpZCwgZG90KSB7XG4gIGNvbnN0IHsgdHlwZWJhck9mZnNldCwgdHlwZWJhckxlbmd0aCB9ID0gdGhhdC5fbGF5b3V0Lm9wdGlvbnNcbiAgbGV0IHggPSB0eXBlYmFyT2Zmc2V0XG5cbiAgYWRkTGluZSh0aGF0LCB0eXBlYmFyT2Zmc2V0KVxuICB4ICs9IHR5cGViYXJMZW5ndGhcbiAgdGhhdC53aWR0aCA9IGFkZERvdCh0aGF0LCB4LCBkb3QsIDIpXG59XG5cbmZ1bmN0aW9uIG1ha2VUeXBlNCh0aGF0LCBpZCwgZG90KSB7XG4gIGNvbnN0IHtcbiAgICB0NERvdE9mZnNldCwgdDREb3RCYXNlbGluZVNoaWZ0LCB0NERvdFNlcCwgdDREb3RFeHQsIGRvdFJhZGl1c1xuICB9ID0gdGhhdC5fbGF5b3V0Lm9wdGlvbnNcbiAgbGV0IHggPSB0NERvdE9mZnNldFxuXG4gIHRoYXQuZWwuY2lyY2xlKHgsIC10NERvdEJhc2VsaW5lU2hpZnQsIGRvdFJhZGl1cylcblxuICBpZiAoZG90ID4gMSkge1xuICAgIHggKz0gdDREb3RTZXBcbiAgICB0aGF0LmVsLmNpcmNsZSh4LCAtdDREb3RCYXNlbGluZVNoaWZ0LCBkb3RSYWRpdXMpXG4gIH1cbiAgdGhhdC53aWR0aCA9IHggKyB0NERvdEV4dFxufVxuXG5mdW5jdGlvbiBtYWtlRWwodGhhdCkge1xuICB0aGF0LmVsID0gdGhhdC5fbGF5b3V0LnN2Zy5lbC5nKClcbiAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgdGhhdC5faWQpXG4gICAgICAgICAgICAgIC50b0RlZnMoKVxufVxuXG5mdW5jdGlvbiBhZGRMaW5lKHRoYXQsIHgpIHtcbiAgY29uc3QgeyB0eXBlU3Ryb2tlV2lkdGgsIHR5cGViYXJMZW5ndGggfSA9IHRoYXQuX2xheW91dC5vcHRpb25zXG4gIHRoYXQuZWwucmVjdCh4LCAtdHlwZVN0cm9rZVdpZHRoLCB0eXBlYmFyTGVuZ3RoLCB0eXBlU3Ryb2tlV2lkdGgpXG59XG5cbi8vIEFkZCBkb3QgZm9yIHR5cGUgMSAod2hvbGUpIG9yIHR5cGUgMiAoaGFsZikgbm90ZS5cbmZ1bmN0aW9uIGFkZERvdCh0aGF0LCB4LCBkb3QsIHR5cGUpIHtcbiAgY29uc3QgeyBkb3RPZmZzZXQsIGRvdFNlcCwgZG90UmFkaXVzLCB0eXBlYmFyRXh0IH0gPSB0aGF0Ll9sYXlvdXQub3B0aW9uc1xuXG4gIGlmIChkb3QgPiAwKSB7XG4gICAgeCArPSBkb3RPZmZzZXQgKiAodHlwZSA9PT0gMSA/IDEuMiA6IDEpXG4gICAgdGhhdC5lbC5jaXJjbGUoeCwgMCwgZG90UmFkaXVzKVxuICB9XG4gIGlmIChkb3QgPiAxKSB7XG4gICAgeCArPSBkb3RTZXAgKiAodHlwZSA9PT0gMSA/IDEuMiA6IDEpXG4gICAgdGhhdC5lbC5jaXJjbGUoeCwgMCwgZG90UmFkaXVzKVxuICB9XG4gIHJldHVybiB4ICsgdHlwZWJhckV4dFxufVxuXG5leHBvcnQgZGVmYXVsdCBEdXJhdGlvbkRlZlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcmVuZGVyZXIvZGVmcy9EdXJhdGlvbkRlZi5qc1xuICoqLyIsImltcG9ydCBTbmFwIGZyb20gJ3NuYXBzdmcnXG5pbXBvcnQgeyBleHRlbmQsIG5lYXIgfSBmcm9tICcuLi8uLi91dGlsJ1xuXG4vKipcbiAqIFNWRyBkZWZpbml0aW9uIGZvciBwaXRjaC5cbiAqIFRoZSBgUGl0Y2hEZWZgIGlzIGRlZmluZWQgYnkgcHJvcGVydGllczogYSBzIG8gdVxuICogYWNjaWRlbnRhbCBzdGVwIG9jdGF2ZSB1bmRlcmJhclxuICogQGNsYXNzXG4gKiBAcGFyYW0gaWQge3N0cmluZ30gICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSBwaXRjaCB7UGl0Y2h9ICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtIGxheW91dCB7TGF5b3V0fSBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIFBpdGNoRGVmKGlkLCBwaXRjaCwgdW5kZXJiYXIsIGRlZnMpIHtcbiAgY29uc3QgbGF5b3V0ID0gdGhpcy5fbGF5b3V0ID0gZGVmcy5fbGF5b3V0XG4gIGNvbnN0IHsgYWNjaWRlbnRhbCwgb2N0YXZlIH0gPSBwaXRjaFxuICBjb25zdCBzY2FsZSA9IGdldFNjYWxlKGFjY2lkZW50YWwsIG9jdGF2ZSwgdW5kZXJiYXIpXG4gIGNvbnN0IGVsID0gdGhpcy5lbCA9IGxheW91dC5zdmcuZWwuZygpLmF0dHIoe1xuICAgIGlkLFxuICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICBzdHJva2VXaWR0aDogMiAtIChzY2FsZS54ICsgc2NhbGUueSlcbiAgfSlcbiAgbGV0IG1hdHJpeCwgc2Jib3gsIHBiYm94XG5cbiAgdGhpcy5fZGVmcyA9IGRlZnNcbiAgYWRkQWNjaWRlbnRhbCh0aGlzLCBhY2NpZGVudGFsKVxuICBhZGRTdGVwKHRoaXMsIHBpdGNoLnN0ZXApXG4gIGFkZE9jdGF2ZSh0aGlzLCBvY3RhdmUpXG5cbiAgbWF0cml4ID0gZ2V0TWF0cml4KHRoaXMsIHNjYWxlLCBvY3RhdmUsIHVuZGVyYmFyKVxuICBlbC50cmFuc2Zvcm0obWF0cml4KVxuXG4gIHNiYm94ID0gdGhpcy5fc2Jib3hcbiAgc2Jib3ggPSBnZXRCQm94QWZ0ZXJUcmFuc2Zvcm0odGhpcy5lbCwgc2Jib3gsIG1hdHJpeClcblxuICBwYmJveCA9IGVsLmdldEJCb3goKVxuICBlbC50b0RlZnMoKVxuXG4gIGV4dGVuZCh0aGlzLCB7XG4gICAgc2NhbGUsXG4gICAgbWF0cml4LFxuICAgIHdpZHRoOiBwYmJveC53aWR0aCxcbiAgICBoZWlnaHQ6IC1wYmJveC55LFxuICAgIHN0ZXBDeDogc2Jib3guY3gsXG4gICAgc3RlcFk6IHNiYm94LnksXG4gICAgc3RlcEN5OiBzYmJveC5jeSxcbiAgICBzdGVwWTI6IHNiYm94LnkyLFxuICAgIHN0ZXBUb3A6IG9jdGF2ZSA+IDAgPyBwYmJveC55IDogc2Jib3gueSArIGxheW91dC5vcHRpb25zLmZvbnRTaXplICogMC4yXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZEFjY2lkZW50YWwodGhhdCwgYWNjaWRlbnRhbCkge1xuICBpZiAoIWFjY2lkZW50YWwpIHtcbiAgICB0aGF0Ll9hY2NpZGVudGFsWDIgPSAwXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgYWNjRGVmID0gdGhhdC5fZGVmcy5nZXRBY2NpZGVudGFsKGFjY2lkZW50YWwpXG4gIHRoYXQuZWwudXNlKGFjY0RlZi5lbCkuYXR0cigneScsIC10aGF0Ll9sYXlvdXQub3B0aW9ucy5hY2NpZGVudGFsU2hpZnQpXG4gIHRoYXQuX2FjY2lkZW50YWxYMiA9IGFjY0RlZi53aWR0aFxufVxuXG5mdW5jdGlvbiBhZGRTdGVwKHRoYXQsIHN0ZXApIHtcbiAgdGhhdC5fc2Jib3ggPSB0aGF0LmVsXG4gICAgLnRleHQodGhhdC5fYWNjaWRlbnRhbFgyLCAwLCAnJyArIHN0ZXApXG4gICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIHRoYXQuX2xheW91dC5vcHRpb25zLmZvbnRTaXplKVxuICAgIC5nZXRCQm94KClcbn1cblxuZnVuY3Rpb24gYWRkT2N0YXZlKHRoYXQsIG9jdGF2ZSkge1xuICBpZiAoIW9jdGF2ZSkgcmV0dXJuXG5cbiAgY29uc3QgeyBvY3RhdmVSYWRpdXMsIG9jdGF2ZU9mZnNldCwgb2N0YXZlU2VwIH0gPSB0aGF0Ll9sYXlvdXQub3B0aW9uc1xuICBjb25zdCBvY3RhdmVFbCA9IHRoYXQuZWwuZygpXG5cbiAgaWYgKG9jdGF2ZSA+IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9jdGF2ZTsgaSsrKSB7XG4gICAgICBvY3RhdmVFbC5jaXJjbGUoXG4gICAgICAgIHRoYXQuX3NiYm94LmN4LFxuICAgICAgICB0aGF0Ll9zYmJveC55ICsgb2N0YXZlT2Zmc2V0IC0gb2N0YXZlU2VwICogaSxcbiAgICAgICAgb2N0YXZlUmFkaXVzXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpID4gb2N0YXZlOyBpLS0pIHtcbiAgICAgIG9jdGF2ZUVsLmNpcmNsZShcbiAgICAgICAgdGhhdC5fc2Jib3guY3gsXG4gICAgICAgIHRoYXQuX3NiYm94LnkyIC0gb2N0YXZlT2Zmc2V0IC0gb2N0YXZlU2VwICogaSxcbiAgICAgICAgb2N0YXZlUmFkaXVzXG4gICAgICApXG4gICAgfVxuICB9XG4gIHRoYXQuZWwuYWRkKG9jdGF2ZUVsKVxufVxuXG4vLyBUcmFuc2Zvcm0gdGhlIHBpdGNoIHRvIGJlIGluIGEgZ29vZCBiYXNlbGluZSBwb3NpdGlvbiBhbmRcbi8vIHNjYWxlIGl0IHRvIGJlIG1vcmUgc3F1YXJlLlxuZnVuY3Rpb24gZ2V0TWF0cml4KHRoYXQsIHNjYWxlLCBvY3RhdmUsIHVuZGVyYmFyKSB7XG4gIGNvbnN0IHsgc3RlcEJhc2VsaW5lU2hpZnQsIHVuZGVyYmFyU2VwIH0gPSB0aGF0Ll9sYXlvdXQub3B0aW9uc1xuICBjb25zdCBwYmJveCA9IHRoYXQuZWwuZ2V0QkJveCgpXG4gIGNvbnN0IGR5ID0gKG9jdGF2ZSA+PSAwICYmIHVuZGVyYmFyID09PSAwID8gLXN0ZXBCYXNlbGluZVNoaWZ0IDogMCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmJhciAqIHVuZGVyYmFyU2VwXG4gIHJldHVybiBTbmFwLm1hdHJpeCgpXG4gICAgLnRyYW5zbGF0ZSgtcGJib3gueCwgZHkpXG4gICAgLnNjYWxlKHNjYWxlLngsIHNjYWxlLnkpXG4gICAgLnRyYW5zbGF0ZSgwLCBuZWFyKHBiYm94LnkyLCB0aGF0Ll9zYmJveC55MikgPyAwIDogLXBiYm94LnkyKVxufVxuXG5mdW5jdGlvbiBnZXRCQm94QWZ0ZXJUcmFuc2Zvcm0oY29udGFpbmVyLCBiYm94LCBtYXRyaXgpIHtcbiAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5yZWN0KGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodClcbiAgY29uc3QgZyA9IGNvbnRhaW5lci5nKHJlY3QpXG4gIHJlY3QudHJhbnNmb3JtKG1hdHJpeClcbiAgYmJveCA9IGcuZ2V0QkJveCgpXG4gIGcucmVtb3ZlKClcbiAgcmV0dXJuIGJib3hcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGUoaGFzQWNjaWRlbnRhbCwgb2N0YXZlLCB1bmRlcmJhcikge1xuICBjb25zdCBhYnNPY3RhdmUgPSBNYXRoLmFicyhvY3RhdmUpXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5wb3coMC45NywgYWJzT2N0YXZlICsgdW5kZXJiYXIgKyAoaGFzQWNjaWRlbnRhbCA/IDIgOiAwKSksXG4gICAgeTogTWF0aC5wb3coMC45NSwgYWJzT2N0YXZlICsgdW5kZXJiYXIgKyAoaGFzQWNjaWRlbnRhbCA/IDEgOiAwKSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaXRjaERlZlxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcmVuZGVyZXIvZGVmcy9QaXRjaERlZi5qc1xuICoqLyIsImltcG9ydCBTbmFwIGZyb20gJ3NuYXBzdmcnXG5cbi8qKlxuICogU1ZHIGRlZmluaXRpb24gZm9yIHRpbWUgc2lnbmF0dXJlLlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSB7VGltZX0gdGltZSAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBUaW1lRGVmKGlkLCB0aW1lLCBsYXlvdXQpIHtcbiAgY29uc3QgeyB0aW1lRm9udFNpemU6IGZvbnRTaXplLCB0aW1lRm9udFdlaWdodDogZm9udFdlaWdodCB9ID0gbGF5b3V0Lm9wdGlvbnNcbiAgY29uc3QgbGluZUV4dGVuZCA9IGZvbnRTaXplICogMC4xXG4gIGNvbnN0IGVsID0gdGhpcy5lbCA9IGxheW91dC5zdmcuZWwuZygpLmF0dHIoe1xuICAgIGlkLFxuICAgIGZvbnRTaXplLFxuICAgIGZvbnRXZWlnaHQsXG4gICAgdGV4dEFuY2hvcjogJ21pZGRsZSdcbiAgfSlcbiAgY29uc3QgbGluZVkgPSAtMC44NSAqIGZvbnRTaXplXG4gIGxldCBiYlxuXG4gIGVsLnRleHQoMCwgLTEgKiBmb250U2l6ZSwgdGltZS5iZWF0cylcbiAgZWwudGV4dCgwLCAwLCB0aW1lLmJlYXRUeXBlKSAgIC8vIGJhc2VsaW5lIHkgPSAwXG4gIGJiID0gZWwuZ2V0QkJveCgpXG4gIGVsLmxpbmUoYmIueCAtIGxpbmVFeHRlbmQsIGxpbmVZLCBiYi54MiArIGxpbmVFeHRlbmQsIGxpbmVZKVxuICBlbC50cmFuc2Zvcm0oU25hcC5tYXRyaXgoKS5zY2FsZSgxLCAwLjgpLnRyYW5zbGF0ZShsaW5lRXh0ZW5kIC0gYmIueCwgMCkpXG5cbiAgYmIgPSBlbC5nZXRCQm94KClcbiAgZWwudG9EZWZzKClcblxuICB0aGlzLndpZHRoID0gYmIud2lkdGhcbiAgdGhpcy5oZWlnaHQgPSAtYmIueVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lRGVmXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9yZW5kZXJlci9kZWZzL1RpbWVEZWYuanNcbiAqKi8iLCJpbXBvcnQgU25hcCBmcm9tICdzbmFwc3ZnJ1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIGxheW91dCB7TGF5b3V0fVxuICovXG5jbGFzcyBTdmdMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXRcbiAgICBjb25zdCB7IGZvbnRGYW1pbHksIHdpZHRoIH0gPSBsYXlvdXQub3B0aW9uc1xuICAgIHRoaXMuX2VsID0gU25hcChsYXlvdXQuc3ZnKVxuICAgICAgLmF0dHIoeyBmb250RmFtaWx5IH0pXG4gICAgICAuYWRkQ2xhc3MoJ211c2plJylcbiAgICB0aGlzLmVsLmNsZWFyKClcbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgfVxuXG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXMuX2VsIH1cblxuICAvKipcbiAgICogV2lkdGggb2YgdGhlIHN2Zy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuX3cgfVxuICBzZXQgd2lkdGgodykge1xuICAgIHRoaXMuX3cgPSB3XG4gICAgdGhpcy5lbC5hdHRyKCd3aWR0aCcsIHcpXG4gICAgY29uc3QgeyBib2R5IH0gPSB0aGlzLl9sYXlvdXRcbiAgICBpZiAoYm9keSkgYm9keS53aWR0aCA9IHdcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWlnaHQgb2YgdGhlIHN2Zy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLl9oIH1cbiAgc2V0IGhlaWdodChoKSB7XG4gICAgdGhpcy5faCA9IGhcbiAgICB0aGlzLmVsLmF0dHIoJ2hlaWdodCcsIGgpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3ZnTGF5b3V0XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9yZW5kZXJlci9MYXlvdXQvU3ZnTGF5b3V0LmpzXG4gKiovIiwiaW1wb3J0IHsgbWF0cml4IH0gZnJvbSAnc25hcHN2ZydcblxuLyoqXG4gKiBCb2R5XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXRcbiAqL1xuY2xhc3MgQm9keUxheW91dCB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgIHRoaXMuX2xheW91dCA9IGxheW91dFxuICAgIGNvbnN0IHsgc3ZnLCBvcHRpb25zIH0gPSBsYXlvdXRcbiAgICBjb25zdCB7IG1hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkxlZnQsIHdpZHRoIH0gPSBvcHRpb25zXG4gICAgdGhpcy5fZWwgPSBzdmcuZWwuZygpXG4gICAgICAgIC50cmFuc2Zvcm0obWF0cml4KCkudHJhbnNsYXRlKG1hcmdpbkxlZnQsIG1hcmdpblRvcCkpXG4gICAgICAgIC5hZGRDbGFzcygnbXVzLWJvZHknKVxuICAgIHRoaXMud2lkdGggPSB3aWR0aCAtIG1hcmdpbkxlZnQgLSBtYXJnaW5SaWdodFxuICB9XG5cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpcy5fZWwgfVxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiB0aGUgYm9keS5cbiAgICogLSAoR2V0dGVyKSBHZXQgdGhlIGJvZHkgd2lkdGguXG4gICAqIC0gKFNldHRlcikgU2V0IHRoZSBib2R5IHdpZHRoIGFuZCB0aGlzIGFsc28gaW5kdWNlcyBzZXR0aW5nIHRoZVxuICAgKiBoZWFkZXIgYW5kIGNvbnRlbnQgd2lkdGggaWYgb25lIGV4aXN0cy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuX3cgfVxuICBzZXQgd2lkdGgodykge1xuICAgIHRoaXMuX3cgPSB3XG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5fbGF5b3V0XG4gICAgaWYgKGxheW91dC5oZWFkZXIpIGxheW91dC5oZWFkZXIud2lkdGggPSB3XG4gICAgaWYgKGxheW91dC5jb250ZW50KSBsYXlvdXQuY29udGVudC53aWR0aCA9IHdcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWlnaHQgb2YgdGhlIGJvZHkuXG4gICAqIC0gKEdldHRlcikgR2V0IHRoZSBib2R5IGhlaWdodC5cbiAgICogLSAoU2V0dGVyKSBTZXQgdGhlIGJvZHkgaGVpZ2h0IGFuZCB0aGlzIHdpbGwgYWxzbyBjYXVzZSB0aGUgaGVpZ2h0IG9mIHN2ZyB0byB2YXJ5LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMuX2ggfVxuICBzZXQgaGVpZ2h0KGgpIHtcbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLl9sYXlvdXRcbiAgICBjb25zdCB7IG1hcmdpblRvcCwgbWFyZ2luQm90dG9tIH0gPSBsYXlvdXQub3B0aW9uc1xuICAgIGxheW91dC5zdmcuaGVpZ2h0ID0gaCArIG1hcmdpblRvcCArIG1hcmdpbkJvdHRvbVxuICAgIHRoaXMuX2ggPSBoXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQm9keUxheW91dFxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0JvZHlMYXlvdXQuanNcbiAqKi8iLCIvKipcbiAqIEhlYWRlciBsYXlvdXQuXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0XG4gKi9cbmNsYXNzIEhlYWRlckxheW91dCB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgIHRoaXMuX2xheW91dCA9IGxheW91dFxuICAgIHRoaXMuZWwgPSBsYXlvdXQuYm9keS5lbC5nKCkuYWRkQ2xhc3MoJ211cy1oZWFkZXInKVxuICAgIHRoaXMud2lkdGggPSBsYXlvdXQuYm9keS53aWR0aFxuICB9XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIHRoZSBoZWFkZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl93IH1cbiAgc2V0IHdpZHRoKHcpIHsgdGhpcy5fdyA9IHcgfVxuXG4gIC8qKlxuICAgKiBIZWlnaHQgb2YgdGhlIGhlYWRlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLl9oIH1cbiAgc2V0IGhlaWdodChoKSB7XG4gICAgdGhpcy5faCA9IGhcbiAgICBjb25zdCB7IGNvbnRlbnQsIG9wdGlvbnMgfSA9IHRoaXMuX2xheW91dFxuICAgIGNvbnRlbnQueSA9IGggPyBoICsgb3B0aW9ucy5oZWFkZXJTZXAgOiAwXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSGVhZGVyTGF5b3V0XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9yZW5kZXJlci9MYXlvdXQvSGVhZGVyTGF5b3V0LmpzXG4gKiovIiwiaW1wb3J0IHsgbWF0cml4IH0gZnJvbSAnc25hcHN2ZydcbmltcG9ydCBTeXN0ZW1MYXlvdXQgZnJvbSAnLi9TeXN0ZW1MYXlvdXQnXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0IC0gUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgbGF5b3V0IGluc3RhbmNlLlxuICovXG5jbGFzcyBDb250ZW50TGF5b3V0IHtcbiAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgdGhpcy5sYXlvdXQgPSBsYXlvdXRcbiAgICB0aGlzLmVsID0gbGF5b3V0LmJvZHkuZWwuZygpLmFkZENsYXNzKCdtdXMtY29udGVudCcpXG4gICAgdGhpcy53aWR0aCA9IGxheW91dC5ib2R5LndpZHRoXG4gIH1cblxuICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuX3kgfVxuICBzZXQgeSh5KSB7XG4gICAgdGhpcy5feSA9IHlcbiAgICB0aGlzLmVsLnRyYW5zZm9ybShtYXRyaXgoKS50cmFuc2xhdGUoMCwgeSkpXG4gICAgcmVzaXplQm9keSh0aGlzKVxuICB9XG5cbiAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5fdyB9XG4gIHNldCB3aWR0aCh3KSB7IHRoaXMuX3cgPSB3IH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLnN5c3RlbXNbdGhpcy5zeXN0ZW1zLmxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIGxhc3QgPyBsYXN0LnkgKyBsYXN0LmhlaWdodCA6IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gc2NvcmVNZWFzdXJlIHttdXNqZS5UaW1ld2lzZU1lYXN1cmVzfSBUaGUgdGltZXdpc2Ugc2NvcmUgbWVhc3VyZS5cbiAgICovXG4gIGZsb3coc2NvcmVNZWFzdXJlcykge1xuICAgIG1ha2VTeXN0ZW1zKHRoaXMsIHNjb3JlTWVhc3VyZXMpXG4gICAgYmFsYW5jZVN5c3RlbXModGhpcylcbiAgICB0aGlzLnN5c3RlbXMuZm9yRWFjaChzeXN0ZW0gPT4geyBzeXN0ZW0uZmxvdygpIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzaXplQm9keSh0aGF0KSB7XG4gIGNvbnN0IGxheW91dCA9IHRoYXQubGF5b3V0XG4gIGNvbnN0IGhIZWlnaHQgPSBsYXlvdXQuaGVhZGVyLmhlaWdodFxuXG4gIGxheW91dC5ib2R5LmhlaWdodCA9IHRoYXQuaGVpZ2h0ICtcbiAgICAgICAgKGhIZWlnaHQgPyBoSGVpZ2h0ICsgbGF5b3V0Lm9wdGlvbnMuaGVhZGVyU2VwIDogMClcbn1cblxuLyoqXG4gKiBEaXZpZGUgbWVhc3VyZXMgaW4gdGltZXdpc2Ugc2NvcmUgaW50byB0aGUgc3lzdGVtcy5cbiAqIEBwYXJhbSBzY29yZU1lYXN1cmUge211c2plLlRpbWV3aXNlTWVhc3VyZXN9IFRoZSB0aW1ld2lzZSBzY29yZSBtZWFzdXJlLlxuICovXG5mdW5jdGlvbiBtYWtlU3lzdGVtcyh0aGF0LCBzY29yZU1lYXN1cmVzKSB7XG4gIGNvbnN0IHsgbGF5b3V0IH0gPSB0aGF0XG4gIGNvbnN0IHsgbWVhc3VyZVBhZGRpbmdSaWdodCwgbWVhc3VyZVBhZGRpbmdMZWZ0IH0gPSBsYXlvdXQub3B0aW9uc1xuICBjb25zdCBtZWFzdXJlUGFkZGluZyA9IG1lYXN1cmVQYWRkaW5nTGVmdCArIG1lYXN1cmVQYWRkaW5nUmlnaHRcbiAgY29uc3Qgc3lzdGVtcyA9IHRoYXQuc3lzdGVtcyA9IFtdXG4gIGxldCBzeXN0ZW0gPSBuZXcgU3lzdGVtTGF5b3V0KGxheW91dCwgMClcbiAgc3lzdGVtcy5wdXNoKHN5c3RlbSlcblxuICBzY29yZU1lYXN1cmVzLmZvckVhY2gobWVhc3VyZSA9PiB7XG4gICAgY29uc3QgbWluV2lkdGggPSBtZWFzdXJlLm1pbldpZHRoICsgbWVhc3VyZVBhZGRpbmcgK1xuICAgICAgICAgICAgICAgICAgKG1lYXN1cmUuYmFyTGVmdEluU3lzdGVtLndpZHRoICtcbiAgICAgICAgICAgICAgICAgICBtZWFzdXJlLmJhclJpZ2h0SW5TeXN0ZW0ud2lkdGgpIC8gMlxuXG4gICAgLy8gQ29udGludWUgcHV0IHRoaXMgbWVhc3VyZSBpbiB0aGUgc3lzdGVtLlxuICAgIGlmIChzeXN0ZW0ubWluV2lkdGggKyBtaW5XaWR0aCA8IHRoYXQud2lkdGgpIHtcbiAgICAgIHN5c3RlbS5tZWFzdXJlcy5wdXNoKG1lYXN1cmUpXG5cbiAgICAvLyBOZXcgc3lzdGVtXG4gICAgfSBlbHNlIHtcbiAgICAgIHN5c3RlbSA9IG5ldyBTeXN0ZW1MYXlvdXQobGF5b3V0LCBzeXN0ZW1zLmxlbmd0aClcbiAgICAgIHN5c3RlbXMucHVzaChzeXN0ZW0pXG4gICAgICBzeXN0ZW0ubWVhc3VyZXMucHVzaChtZWFzdXJlKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0TWF4TGVuZ3RoU3lzdGVtKHRoYXQpIHtcbiAgbGV0IG1heExlbmd0aCA9IDBcbiAgbGV0IHN5c3RlbVxuXG4gIHRoYXQuc3lzdGVtcy5mb3JFYWNoKHN5c3RlbSA9PiB7XG4gICAgbWF4TGVuZ3RoID0gTWF0aC5tYXgobWF4TGVuZ3RoLCBzeXN0ZW0ubWVhc3VyZXMubGVuZ3RoKVxuICB9KVxuXG4gIC8vIEZpbmQgdGhlIGZpcnN0IG1heCBsZW5ndGggc3lzdGVtIGJhY2t3YXJkLlxuICBmb3IobGV0IGkgPSB0aGF0LnN5c3RlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBzeXN0ZW0gPSB0aGF0LnN5c3RlbXNbaV1cbiAgICBpZiAoc3lzdGVtLm1lYXN1cmVzLmxlbmd0aCA9PT0gbWF4TGVuZ3RoKSByZXR1cm4gc3lzdGVtXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOb3RCYWxhbmNhYmxlKHRoYXQpIHtcbiAgY29uc3QgeyBzeXN0ZW1zLCB3aWR0aCB9ID0gdGhhdFxuICBjb25zdCB7IGxlbmd0aCB9ID0gc3lzdGVtc1xuICByZXR1cm4gbGVuZ3RoID09PSAxIHx8ICAgICAgIC8vIG9ubHkgMSBzeXN0ZW1cbiAgICAobGVuZ3RoID09PSAyICYmIHN5c3RlbXNbMV0ubWluV2lkdGggPCB3aWR0aCAqIDAuNCkgLy8gMSAyLzUgc3lzdGVtc1xufVxuXG5mdW5jdGlvbiBiYWxhbmNlU3lzdGVtcyh0aGF0KSB7XG4gIGlmIChpc05vdEJhbGFuY2FibGUodGhhdCkpIHJldHVyblxuXG4gIGNvbnN0IHsgc3lzdGVtcyB9ID0gdGhhdFxuICBjb25zdCBsYXN0ID0gc3lzdGVtc1tzeXN0ZW1zLmxlbmd0aCAtIDFdXG4gIGxldCBzeXN0ZW0gPSBnZXRNYXhMZW5ndGhTeXN0ZW0odGhhdClcbiAgbGV0IG5leHQsIHByZXZcblxuICAvLyBNb3ZlIG1lYXN1cmVzIGRvd24gdG8gYmFsYW5jZSB0aGUgbGFzdCBzeXN0ZW0uXG4gIHdoaWxlIChsYXN0Lm1lYXN1cmVzLmxlbmd0aCA8IHN5c3RlbS5tZWFzdXJlcy5sZW5ndGggLSAxKSB7XG5cbiAgICAvLyBNb3ZlIGEgbWVhc3VyZSB0YWlsLXRvLWhlYWQgZG93bndhcmQgdG8gdGhlIGxhc3QgbWVhc3VyZS5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbmV4dCA9IHN5c3RlbS5uZXh0XG4gICAgICBpZiAoIW5leHQpIGJyZWFrXG4gICAgICBuZXh0Lm1lYXN1cmVzLnVuc2hpZnQoc3lzdGVtLm1lYXN1cmVzLnBvcCgpKVxuICAgICAgc3lzdGVtID0gbmV4dFxuICAgIH1cbiAgICBzeXN0ZW0gPSBnZXRNYXhMZW5ndGhTeXN0ZW0odGhhdClcbiAgfVxuXG4gIC8vIE1vdmUgYmFjayBtZWFzdXJlcyBpZiB0aGUgc3lzdGVtIGV4Y2VlZHMgdGhlIGNvbnRlbnQgd2lkdGguXG4gIHN5c3RlbSA9IGxhc3RcbiAgd2hpbGUgKHN5c3RlbSkge1xuICAgIHByZXYgPSBzeXN0ZW0ucHJldlxuICAgIHdoaWxlIChzeXN0ZW0ubWluV2lkdGggPiB0aGF0LndpZHRoKSB7XG4gICAgICBwcmV2Lm1lYXN1cmVzLnB1c2goc3lzdGVtLm1lYXN1cmVzLnNoaWZ0KCkpXG4gICAgfVxuICAgIHN5c3RlbSA9IHByZXZcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250ZW50TGF5b3V0XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9yZW5kZXJlci9MYXlvdXQvQ29udGVudExheW91dC5qc1xuICoqLyIsImltcG9ydCB7IG1hdHJpeCB9IGZyb20gJ3NuYXBzdmcnXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXRcbiAqL1xuY2xhc3MgU3lzdGVtTGF5b3V0IHtcbiAgY29uc3RydWN0b3IobGF5b3V0LCBpbmRleCkge1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXhcbiAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXRcbiAgICB0aGlzLl9lbCA9IGxheW91dC5jb250ZW50LmVsLmcoKS5hZGRDbGFzcygnbXVzLXN5c3RlbScpXG4gIH1cblxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzLl9lbCB9XG5cbiAgLyoqXG4gICAqIE1lYXN1cmVzIGluIGEgc3lzdGVtLlxuICAgKiBAdHlwZSB7QXJyYXkuPFRpbWV3aXNlTWVhc3VyZT59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG1lYXN1cmVzKCkgeyByZXR1cm4gdGhpcy5fbWVhc3VyZXMgfHwgKHRoaXMuX21lYXN1cmVzID0gW10pIH1cblxuICAvKipcbiAgICogUHJldmlvdXMgc3lzdGVtLlxuICAgKiBAdHlwZSB7U3lzdGVtTGF5b3V0fVxuICAgKi9cbiAgZ2V0IHByZXYoKSB7IHJldHVybiB0aGlzLl9sYXlvdXQuY29udGVudC5zeXN0ZW1zW3RoaXMuX2luZGV4IC0gMV0gfVxuXG4gIC8qKlxuICAgKiBOZXh0IHN5c3RlbS5cbiAgICogQHR5cGUge1N5c3RlbUxheW91dH1cbiAgICovXG4gIGdldCBuZXh0KCkgeyByZXR1cm4gdGhpcy5fbGF5b3V0LmNvbnRlbnQuc3lzdGVtc1t0aGlzLl9pbmRleCArIDFdIH1cblxuICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuX3kgfVxuICBzZXQgeSh5KSB7XG4gICAgdGhpcy5feSA9IHlcbiAgICB0aGlzLmVsLnRyYW5zZm9ybShtYXRyaXgoKS50cmFuc2xhdGUoMCwgeSkpXG4gIH1cblxuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl9sYXlvdXQuY29udGVudC53aWR0aCB9XG5cbiAgZ2V0IG1pbldpZHRoKCkge1xuICAgIGxldCBtaW4gPSAwXG4gICAgdGhpcy5tZWFzdXJlcy5mb3JFYWNoKG1lYXN1cmUgPT4geyBtaW4gKz0gbWVhc3VyZS5taW5XaWR0aCB9KVxuICAgIHJldHVybiBtaW5cbiAgfVxuXG4gIGdldCBjb250ZW50KCkgeyByZXR1cm4gdGhpcy5fbGF5b3V0LmNvbnRlbnQgfVxuXG4gIGdldCBzeXN0ZW1zKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LnN5c3RlbXMgfVxuXG4gIGZsb3coKSB7XG4gICAgbGV0IG1pbkhlaWdodCA9IDBcbiAgICBsZXQgeCA9IDBcblxuICAgIHR1bmVNZWFzdXJlc1dpZHRocyh0aGlzKVxuXG4gICAgdGhpcy5tZWFzdXJlcy5mb3JFYWNoKChtZWFzdXJlLCBtKSA9PiB7XG4gICAgICBtZWFzdXJlLnN5c3RlbSA9IHRoaXNcbiAgICAgIG1lYXN1cmUuX3NJbmRleCA9IG1cbiAgICAgIG1lYXN1cmUuZmxvdygpXG4gICAgICBtZWFzdXJlLnggPSB4XG4gICAgICB4ICs9IG1lYXN1cmUud2lkdGhcbiAgICAgIG1pbkhlaWdodCA9IE1hdGgubWF4KG1pbkhlaWdodCwgbWVhc3VyZS5taW5IZWlnaHQpXG4gICAgfSlcblxuICAgIGNvbnN0IHsgcHJldiB9ID0gdGhpc1xuICAgIHRoaXMueSA9IHByZXYgPyBwcmV2LnkgKyBwcmV2LmhlaWdodCArIHRoaXMuX2xheW91dC5vcHRpb25zLnN5c3RlbVNlcCA6IDBcbiAgICB0aGlzLmhlaWdodCA9IG1pbkhlaWdodFxuICB9XG59XG5cbmZ1bmN0aW9uIHR1bmVNZWFzdXJlc1dpZHRocyh0aGF0KSB7XG4gIGlmICghaXNUdW5hYmxlKHRoYXQpKSByZXR1cm5cblxuICB2YXIgcGFpcnMgPSBnZXRQYWlycyh0aGF0Lm1lYXN1cmVzKVxuICB2YXIgbGVuZ3RoID0gcGFpcnMubGVuZ3RoXG4gIHZhciB3aWR0aExlZnQgPSB0aGF0LndpZHRoXG4gIHZhciBpdGVtTGVmdCA9IGxlbmd0aFxuICB2YXIgaSA9IDAgICAgLy8gaSArIGl0ZW1MZWZ0ID09PSBsZW5ndGhcbiAgdmFyIHdpZHRoXG5cbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBpZiAod2lkdGhMZWZ0ID49IHBhaXJzW2ldLndpZHRoICogaXRlbUxlZnQpIHtcbiAgICAgIHdpZHRoID0gd2lkdGhMZWZ0IC8gaXRlbUxlZnRcbiAgICAgIGRvIHtcbiAgICAgICAgcGFpcnNbaV0ubWVhc3VyZS53aWR0aCA9IHdpZHRoXG4gICAgICAgIGkrK1xuICAgICAgfSB3aGlsZSAoaSA8IGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gcGFpcnNbaV0ud2lkdGhcbiAgICAgIHBhaXJzW2ldLm1lYXN1cmUud2lkdGggPSB3aWR0aFxuICAgICAgd2lkdGhMZWZ0IC09IHdpZHRoXG4gICAgICBpKytcbiAgICAgIGl0ZW1MZWZ0LS1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUdW5hYmxlKHRoYXQpIHtcbiAgY29uc3QgY3RXaWR0aCA9IHRoYXQuY29udGVudC53aWR0aFxuICBjb25zdCBzID0gdGhhdC5faW5kZXhcbiAgY29uc3Qgc3NMZW4gPSB0aGF0LnN5c3RlbXMubGVuZ3RoXG4gIHJldHVybiBzc0xlbiA+IDIgfHxcbiAgICAgKHNzTGVuID09PSAxICYmIHRoYXQubWluV2lkdGggPiBjdFdpZHRoICogMC43KSB8fFxuICAgICAoc3NMZW4gPT09IDIgJiYgKHMgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgIChzID09PSAxICYmIHRoYXQubWluV2lkdGggPiBjdFdpZHRoICogMC40KSkpXG59XG5cbmNvbnN0IGRlc2NlbmRpbmdTb3J0ID0gKGEsIGIpID0+IGIud2lkdGggLSBhLndpZHRoXG5cbmNvbnN0IGdldFBhaXJzID0gbWVhc3VyZXMgPT4gbWVhc3VyZXMubWFwKG1lYXN1cmUgPT4gKHtcbiAgd2lkdGg6IG1lYXN1cmUubWluV2lkdGgsXG4gIG1lYXN1cmU6IG1lYXN1cmVcbn0pKS5zb3J0KGRlc2NlbmRpbmdTb3J0KVxuXG5leHBvcnQgZGVmYXVsdCBTeXN0ZW1MYXlvdXRcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3JlbmRlcmVyL0xheW91dC9TeXN0ZW1MYXlvdXQuanNcbiAqKi8iLCJpbXBvcnQgeyBtYXRyaXggfSBmcm9tICdzbmFwc3ZnJ1xuXG5mdW5jdGlvbiByZW5kZXJEb3RzKGVsLCB4LCByYWRpdXMsIG1lYXN1cmVIZWlnaHQpIHtcbiAgY29uc3QgY3kgPSBtZWFzdXJlSGVpZ2h0IC8gMlxuICBjb25zdCBkeSA9IG1lYXN1cmVIZWlnaHQgKiAwLjE1XG5cbiAgZWwuY2lyY2xlKHgsIGN5IC0gZHksIHJhZGl1cylcbiAgZWwuY2lyY2xlKHgsIGN5ICsgZHksIHJhZGl1cylcbn1cblxuZnVuY3Rpb24gcmVuZGVyKGJhciwgbWVhc3VyZSwgbG8pIHtcbiAgY29uc3QgeyBiYXJsaW5lRG90UmFkaXVzIH0gPSBsb1xuICBjb25zdCB7IGhlaWdodCB9ID0gbWVhc3VyZVxuICBjb25zdCBlbCA9IG1lYXN1cmUuZWwuZygpLmFkZENsYXNzKCdtdXMtYmFybGluZScpXG4gIGVsLnVzZShiYXIuZGVmLmVsKS50cmFuc2Zvcm0obWF0cml4KCkuc2NhbGUoMSwgaGVpZ2h0KSlcblxuICBzd2l0Y2ggKGJhci52YWx1ZSkge1xuICAgIGNhc2UgJ3JlcGVhdC1iZWdpbic6XG4gICAgICByZW5kZXJEb3RzKGVsLCBiYXIud2lkdGggLSBiYXJsaW5lRG90UmFkaXVzLCBiYXJsaW5lRG90UmFkaXVzLCBoZWlnaHQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3JlcGVhdC1lbmQnOlxuICAgICAgcmVuZGVyRG90cyhlbCwgYmFybGluZURvdFJhZGl1cywgYmFybGluZURvdFJhZGl1cywgaGVpZ2h0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdyZXBlYXQtYm90aCc6XG4gICAgICByZW5kZXJEb3RzKGVsLCBiYXIud2lkdGggLSBiYXJsaW5lRG90UmFkaXVzLCBiYXJsaW5lRG90UmFkaXVzLCBoZWlnaHQpXG4gICAgICByZW5kZXJEb3RzKGVsLCBiYXJsaW5lRG90UmFkaXVzLCBiYXJsaW5lRG90UmFkaXVzLCBoZWlnaHQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gIH1cblxuICByZXR1cm4gZWxcbn1cblxuY29uc3QgdHJhbnNsYXRlID0gKGVsLCB4KSA9PiB7IGVsLnRyYW5zZm9ybShtYXRyaXgoKS50cmFuc2xhdGUoeCwgMCkpIH1cblxuLy8gQHBhcmFtIG0ge251bWJlcn0gTWVhc3VyZSBpbmRleCBpbiBtZWFzdXJlcy5cbi8vIEBwYXJhbSBsZW4ge251bWJlcn0gTGVuZ3RoIG9mIG1lYXN1cmVzLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVuZGVyQmFyKG1lYXN1cmUsIGxvKSB7XG4gIGxldCBiYXIgPSBtZWFzdXJlLmJhclJpZ2h0SW5TeXN0ZW1cbiAgbGV0IGVsXG5cbiAgaWYgKGJhci5kZWYpIHtcbiAgICBlbCA9IHJlbmRlcihiYXIsIG1lYXN1cmUsIGxvKVxuXG4gICAgLy8gQWxpZ24gZW5kIGluIHN5c3RlbSBlbmQuXG4gICAgaWYgKG1lYXN1cmUuaW5TeXN0ZW1FbmQpIHRyYW5zbGF0ZShlbCwgbWVhc3VyZS53aWR0aCAtIGJhci53aWR0aClcbiAgICAvLyBPdGhlcnMgYWxpZ24gbWlkZGxlLlxuICAgIGVsc2UgdHJhbnNsYXRlKGVsLCBtZWFzdXJlLndpZHRoIC0gYmFyLndpZHRoIC8gMilcbiAgfVxuXG4gIC8vIFJlbmRlciByaWdodCBiYXIgYW5kIGFsaWduIGJlZ2luIGluIHN5c3RlbSBiZWdpbi5cbiAgaWYgKG1lYXN1cmUuaW5TeXN0ZW1CZWdpbikge1xuICAgIGJhciA9IG1lYXN1cmUuYmFyTGVmdEluU3lzdGVtXG4gICAgaWYgKGJhci5kZWYpIHJlbmRlcihiYXIsIG1lYXN1cmUsIGxvKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9yZW5kZXJlci9SZW5kZXJlci9yZW5kZXJCYXIuanNcbiAqKi8iLCJpbXBvcnQgeyBtYXRyaXggfSBmcm9tICdzbmFwc3ZnJ1xuXG5mdW5jdGlvbiByZW5kZXJEdXJhdGlvbihub3RlLCBsbykge1xuICBjb25zdCB7IGR1cmF0aW9uRGVmLCBwaXRjaERlZiB9ID0gbm90ZS5kZWZcbiAgY29uc3QgeyB1bmRlcmJhciB9ID0gbm90ZS5kdXJhdGlvblxuICBsZXQgeSA9IDBcblxuICAvLyBXaG9sZSBhbmQgaGFsZiBub3Rlc1xuICBpZiAobm90ZS5kdXJhdGlvbi50eXBlIDwgNCkge1xuICAgIG5vdGUuZWwudXNlKGR1cmF0aW9uRGVmLmVsKS5hdHRyKHtcbiAgICAgIHg6IHBpdGNoRGVmLndpZHRoLFxuICAgICAgeTogcGl0Y2hEZWYuc3RlcEN5XG4gICAgfSlcblxuICAvLyBRdWFydGVyIG9yIHNob3J0ZXIgbm90ZXNcbiAgfSBlbHNlIHtcblxuICAgIC8vIEFkZCBkb3RzXG4gICAgaWYgKG5vdGUuZHVyYXRpb24uZG90KSB7XG4gICAgICBub3RlLmVsLmcoKS50cmFuc2Zvcm0obWF0cml4KCkudHJhbnNsYXRlKHBpdGNoRGVmLndpZHRoLCAwKSlcbiAgICAgICAgLnVzZShkdXJhdGlvbkRlZi5lbCkudHJhbnNmb3JtKHBpdGNoRGVmLm1hdHJpeClcbiAgICB9XG5cbiAgICAvLyBBZGQgdW5kZXJiYXJzIGZvciBlaWd0aCBvciBzaG9ydGVyIG5vdGVzXG4gICAgaWYgKHVuZGVyYmFyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuZGVyYmFyOyBpKyspIHtcblxuICAgICAgICAvLyBPbmx5IHJlbmRlciBiZWFtIGZvciB0aGUgYmVnaW4gb25lLlxuICAgICAgICBpZiAobm90ZS5iZWFtc1tpXSkge1xuICAgICAgICAgIGlmIChub3RlLmJlYW1zW2ldLnZhbHVlID09PSAnYmVnaW4nKSB7XG4gICAgICAgICAgICByZW5kZXJVbmRlcmJhcihub3RlLCBub3RlLmJlYW1zW2ldLmVuZER1cmFibGUsIHksIGxvKVxuICAgICAgICAgIH1cblxuICAgICAgICAvLyBVbmJlYW1lZCB1bmRlcmJhclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlclVuZGVyYmFyKG5vdGUsIG5vdGUsIHksIGxvKVxuICAgICAgICB9XG4gICAgICAgIHkgLT0gbG8udW5kZXJiYXJTZXBcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyVW5kZXJiYXIobm90ZTEsIG5vdGUyLCB5LCBsbykge1xuICBub3RlMS5lbC5saW5lKDAsIHksIG5vdGUyLnggLSBub3RlMS54ICsgbm90ZTIud2lkdGgsIHkpXG4gICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgbG8udHlwZVN0cm9rZVdpZHRoKVxufVxuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJEdXJhdGlvblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvcmVuZGVyZXIvUmVuZGVyZXIvcmVuZGVyRHVyYXRpb24uanNcbiAqKi8iLCJpbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdzbmFwc3ZnJ1xuXG5mdW5jdGlvbiBnZXRDdXJ2ZVBhdGgoeDEsIHkxLCB4MiwgeTIpIHtcbiAgY29uc3QgZHggPSB4MiAtIHgxXG4gIGNvbnN0IGR5ID0geTIgLSB5MVxuICBjb25zdCBjMXggPSAwIC8vLTAuMSAqIGR4XG4gIGNvbnN0IGMxeSA9IDAgLy8tMC4xICogZHlcbiAgY29uc3QgYzJ4ID0gZHggLy8xLjEgKiBkeFxuICBjb25zdCBjMnkgPSBkeSAvLzEuMSAqIGR5XG5cbiAgcmV0dXJuIGZvcm1hdCgnTXt4MX0se3kxfWN7YzF4fSx7YzF5fSB7YzJ4fSx7YzJ5fSB7ZHh9LHtkeX1je2MzeH0se2MzeX0ge2M0eH0se2M0eX0ge25lZ0R4fSx7bmVnRHl9Jywge1xuICAgIHgxLFxuICAgIHkxLFxuICAgIGMxeCxcbiAgICBjMXk6IGMxeSAtIDgsXG4gICAgYzJ4LFxuICAgIGMyeTogYzJ5IC0gOCxcbiAgICBkeCxcbiAgICBkeSxcbiAgICBjM3g6IC1jMXgsXG4gICAgYzN5OiAtYzF5IC0gMTAsXG4gICAgYzR4OiAtYzJ4LFxuICAgIGM0eTogLWMyeSAtIDEwLFxuICAgIG5lZ0R4OiAtZHgsXG4gICAgbmVnRHk6IC1keVxuICB9KVxufVxuXG5mdW5jdGlvbiByZW5kZXJFbmRDdXJ2ZShub3RlLCBlcnJvcikge1xuICBjb25zdCB7IHN0ZXBDeDogeDEsIHN0ZXBUb3A6IHkxIH0gPSBub3RlLmRlZi5waXRjaERlZlxuICBjb25zdCB4MiA9IC0gbm90ZS5zeXN0ZW1YIC0gM1xuICBjb25zdCBlbCA9IG5vdGUuZWwucGF0aChnZXRDdXJ2ZVBhdGgoeDEsIHkxLCB4MiwgeTEgLSAzKSlcblxuICBpZiAoZXJyb3IpIGVsLmFkZENsYXNzKCdtdXMtZXJyb3InKVxuICByZXR1cm4gZWxcbn1cblxuZnVuY3Rpb24gcmVuZGVyQmVnaW5DdXJ2ZShub3RlLCBlcnJvcikge1xuICBjb25zdCB7IHN0ZXBDeDogeDEsIHN0ZXBUb3A6IHkxIH0gPSBub3RlLmRlZi5waXRjaERlZlxuICBjb25zdCB4MiA9IG5vdGUuc3lzdGVtLndpZHRoIC0gbm90ZS5zeXN0ZW1YICsgM1xuICBjb25zdCBlbCA9IG5vdGUuZWwucGF0aChnZXRDdXJ2ZVBhdGgoeDEsIHkxLCB4MiwgeTEgLSAzKSlcblxuICBpZiAoZXJyb3IpIGVsLmFkZENsYXNzKCdtdXMtZXJyb3InKVxuICByZXR1cm4gZWxcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29tcGxldGVDdXJ2ZShub3RlMSwgbm90ZTIsIGVycm9yKSB7XG4gIGNvbnN0IHsgc3RlcEN4OiB4MSwgc3RlcFRvcDogeTEgfSA9IG5vdGUxLmRlZi5waXRjaERlZlxuICBjb25zdCB7IHN0ZXBDeDogeDIsIHN0ZXBUb3A6IHkyIH0gPSBub3RlMi5kZWYucGl0Y2hEZWZcbiAgY29uc3Qgbm90ZUR4ID0gbm90ZTIuc3lzdGVtWCAtIG5vdGUxLnN5c3RlbVhcbiAgY29uc3QgZWwgPSBub3RlMS5lbC5wYXRoKGdldEN1cnZlUGF0aCh4MSwgeTEsIG5vdGVEeCArIHgyLCB5MikpXG5cbiAgaWYgKGVycm9yKSBlbC5hZGRDbGFzcygnbXVzLWVycm9yJylcbiAgcmV0dXJuIGVsXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlbmRlckN1cnZlKHR5cGUsIG5vdGUpIHtcbiAgaWYgKG5vdGVbdHlwZV0uZW5kKSB7XG4gICAgY29uc3QgcHJldiA9IG5vdGVbdHlwZV0ucHJldlBhcmVudFxuICAgIGNvbnN0IHsgcHJldkhhc0Vycm9yIH0gPSBub3RlW3R5cGVdXG5cbiAgICBpZiAoIXByZXYgfHwgcHJldi5zeXN0ZW0gIT09IG5vdGUuc3lzdGVtKSByZW5kZXJFbmRDdXJ2ZShub3RlLCBwcmV2SGFzRXJyb3IpXG4gICAgZWxzZSBpZiAocHJldkhhc0Vycm9yKSByZW5kZXJDb21wbGV0ZUN1cnZlKG5vdGUsIHByZXYsIHByZXZIYXNFcnJvcilcbiAgfVxuXG4gIGlmIChub3RlW3R5cGVdLmJlZ2luKSB7XG4gICAgY29uc3QgbmV4dCA9IG5vdGVbdHlwZV0ubmV4dFBhcmVudFxuICAgIGNvbnN0IHsgbmV4dEhhc0Vycm9yIH0gPSBub3RlW3R5cGVdXG5cbiAgICBpZiAoIW5leHQgfHwgbmV4dC5zeXN0ZW0gIT09IG5vdGUuc3lzdGVtKSByZW5kZXJCZWdpbkN1cnZlKG5vdGUsIG5leHRIYXNFcnJvcilcbiAgICBlbHNlIHJlbmRlckNvbXBsZXRlQ3VydmUobm90ZSwgbmV4dCwgbmV4dEhhc0Vycm9yKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9yZW5kZXJlci9SZW5kZXJlci9yZW5kZXJDdXJ2ZS5qc1xuICoqLyIsImltcG9ydCBNSURJIGZyb20gJ01JREknXG5cbmNvbnN0IHRpbWVvdXRzID0gW11cblxuY29uc3QgUGxheWVyTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHBsYXlpbmcgdGhlIHNvbmcuXG4gICAqL1xuICBwbGF5KCkge1xuICAgIGNvbnN0IHsgbWVhc3VyZXMgfSA9IHRoaXMucGFydHNbMF1cbiAgICB2YXIgdGltZSA9IDAgLy9hdWRpb0N0eC5jdXJyZW50VGltZVxuXG4gICAgbWVhc3VyZXMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgIGNlbGwuZGF0YS5mb3JFYWNoKGRhdGEgPT4ge1xuICAgICAgICBzd2l0Y2ggKGRhdGEuJHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdub3RlJzpcbiAgICAgICAgICAgIC8vIHBsYXlOb3RlKHRpbWUsIGR1ciwgZnJlcSlcbiAgICAgICAgICAgIHRpbWVvdXRzLnB1c2gobWlkaVBsYXlOb3RlKGRhdGEsIHRpbWUpKVxuICAgICAgICAgICAgdGltZSArPSBkYXRhLmR1cmF0aW9uLnNlY29uZFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdyZXN0JzpcbiAgICAgICAgICAgIHRpbWUgKz0gZGF0YS5kdXJhdGlvbi5zZWNvbmRcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9wIHBsYXlpbmcgdGhlIHNvbmcuXG4gICAqL1xuICBzdG9wKCkge1xuICAgIHRpbWVvdXRzLmZvckVhY2godGltZW91dCA9PiB7IGNsZWFyVGltZW91dCh0aW1lb3V0KSB9KVxuICAgIHRpbWVvdXRzLmxlbmd0aCA9IDBcbiAgfVxufVxuXG4vLyBpZiAod2luZG93LkF1ZGlvQ29udGV4dCkge1xuLy8gICB2YXIgYXVkaW9DdHggPSBuZXcgd2luZG93LkF1ZGlvQ29udGV4dCgpXG4vLyAgIHZhciBnYWluTm9kZSA9IGF1ZGlvQ3R4LmNyZWF0ZUdhaW4oKVxuLy8gICBnYWluTm9kZS5jb25uZWN0KGF1ZGlvQ3R4LmRlc3RpbmF0aW9uKVxuLy8gICBnYWluTm9kZS5nYWluLnZhbHVlID0gMC41ICAvLyBzZXQgdGhlIHZvbHVtZVxuLy8gfVxuXG4vLyAvLyB2YXIgb3NjaWxsYXRvciA9IGF1ZGlvQ3R4LmNyZWF0ZU9zY2lsbGF0b3IoKVxuLy8gLy8gb3NjaWxsYXRvci5jb25uZWN0KGdhaW5Ob2RlKVxuLy8gLy8gb3NjaWxsYXRvci50eXBlID0gJ3NxdWFyZScgLy8gc2luZSB8IHNxdWFyZSB8IHNhd3Rvb3RoIHwgdHJpYW5nbGUgfCBjdXN0b21cblxuLy8gZnVuY3Rpb24gcGxheU5vdGUodGltZSwgZHVyLCBmcmVxKSB7XG4vLyAgIGlmICghYXVkaW9DdHgpIHsgcmV0dXJuIH1cblxuLy8gICB2YXIgb3NjaWxsYXRvciA9IGF1ZGlvQ3R4LmNyZWF0ZU9zY2lsbGF0b3IoKVxuLy8gICBvc2NpbGxhdG9yLnR5cGUgPSAnc2luZSdcbi8vICAgb3NjaWxsYXRvci5jb25uZWN0KGF1ZGlvQ3R4LmRlc3RpbmF0aW9uKVxuLy8gICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS52YWx1ZSA9IGZyZXFcbi8vICAgb3NjaWxsYXRvci5zdGFydCh0aW1lKVxuLy8gICBvc2NpbGxhdG9yLnN0b3AodGltZSArIGR1ciAtIDAuMDUpXG4vLyB9XG5cbmZ1bmN0aW9uIG1pZGlQbGF5Tm90ZShub3RlLCB0aW1lKSB7XG4gIGNvbnN0IHsgbWlkaU51bWJlciB9ID0gbm90ZS5waXRjaFxuICBjb25zdCBkdXIgPSBub3RlLmR1cmF0aW9uLnNlY29uZFxuXG4gIGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgaWYgKCFub3RlLnRpZS5wcmV2UGFyZW50IHx8IG5vdGUudGllLnByZXZIYXNFcnJvcikge1xuICAgICAgTUlESS5ub3RlT24oMCwgbWlkaU51bWJlciwgMTAwLCAwKVxuICAgIH1cbiAgICBpZiAoIW5vdGUudGllLm5leHRQYXJlbnQgfHwgbm90ZS50aWUubmV4dEhhc0Vycm9yKSB7XG4gICAgICBNSURJLm5vdGVPZmYoMCwgbWlkaU51bWJlciwgZHVyKVxuICAgIH1cbiAgICBub3RlLmVsLmFkZENsYXNzKCdtdXMtcGxheWluZycpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7IG5vdGUuZWwucmVtb3ZlQ2xhc3MoJ211cy1wbGF5aW5nJykgfSwgZHVyICogODAwICsgMTAwKVxuICAgIGNvbnNvbGUubG9nKCdQbGF5OiAnICsgbm90ZSwgdGltZSwgZHVyLCBtaWRpTnVtYmVyKVxuICB9XG5cbiAgcmV0dXJuIHNldFRpbWVvdXQocGxheSwgdGltZSAqIDgwMClcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxheWVyTWl4aW5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3BsYXllci9QbGF5ZXJNaXhpbi5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV80Ml9fO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJNSURJXCJcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==